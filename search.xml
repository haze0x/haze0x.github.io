<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jvm内存模型深度剖析与优化</title>
    <url>/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Jvm内存模型深度剖析与优化"><a href="#Jvm内存模型深度剖析与优化" class="headerlink" title="Jvm内存模型深度剖析与优化"></a>Jvm内存模型深度剖析与优化</h2><p><img src="/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/clipboard.png"></p>
<p><strong>Java语言的跨平台特性</strong></p>
<p><img src="/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/clipboard-1650033076633.png" alt="img"></p>
<p><strong>JVM整体结构及内存模型</strong></p>
<p><img src="/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="img"></p>
<p><strong>栈帧结构：</strong></p>
<p>局部变量表：存放局部变量</p>
<p>操作数栈：存放运算时的操作数</p>
<p>方法出口：方法执行完回到方法的初始位置，这个位置在调用方法的时候就已经记录到方法出口了</p>
<p>动态链接：区别于静态链接【静态链接是类加载过程中，符号引用替换为直接引用，比如 public main 等符号转化为原空间的地址】，动态链接是运行过程中，把符号引用转换成符号对应的代码的直接地址，比如上节课的main方法的 compute()方法</p>
<p><strong>虚拟机栈和堆之间的关系：</strong></p>
<p>堆中存放着虚拟机栈中的对象，虚拟机栈存放的是队中对象的引用</p>
<p><strong>方法区和堆之间的关系：</strong></p>
<p>方法区里面主要存放一些常量信息、静态变量和类元信息，堆中才是存放的实际对象，方法区里面存放的常量信息实际是d堆中对象的地址</p>
<p><strong>本地方法栈：</strong></p>
<p>存放调用本地方法的一些内存</p>
<p><strong>补充一个问题：</strong></p>
<p><strong>在minor gc过程中对象挪动后，引用如何修改？</strong></p>
<p>对象在堆内部挪动的过程其实是复制，原有区域对象还在，一般不直接清理，JVM内部清理过程只是将对象分配指针移动到区域的头位置即可，比如扫描s0区域，扫到gcroot引用的非垃圾对象是将这些对象<strong>复制</strong>到s1或老年代，最后扫描完了将s0区域的对象分配指针移动到区域的起始位置即可，s0区域之前对象并不直接清理，当有新对象分配了，原有区域里的对象也就被清除了。</p>
<p>minor gc在根扫描过程中会记录所有被扫描到的对象引用(在年轻代这些引用很少，因为大部分都是垃圾对象不会扫描到)，如果引用的对象被复制到新地址了，最后会一并更新引用指向新地址。</p>
<p>这里面内部算法比较复杂，感兴趣可以参考R大的这篇文章：</p>
<p><a href="https://www.zhihu.com/question/42181722/answer/145085437">https://www.zhihu.com/question/42181722/answer/145085437</a></p>
<p><a href="https://hllvm-group.iteye.com/group/topic/39376#post-257329">https://hllvm-group.iteye.com/group/topic/39376#post-257329</a></p>
<p><strong>二、JVM内存参数设置</strong></p>
<p><img src="/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/clipboard-1650033076634.png" alt="img"></p>
<p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p>
<p>java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar</p>
<p>-Xss：每个线程的栈大小</p>
<p>-Xms：设置堆的初始可用大小，默认物理内存的1/64 </p>
<p>-Xmx：设置堆的最大可用大小，默认物理内存的1/4</p>
<p>-Xmn：新生代大小</p>
<p>-XX:NewRatio：默认2表示新生代占年老代的1/2，占整个堆内存的1/3。</p>
<p>-XX:SurvivorRatio：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。</p>
<p>关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N</p>
<p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。</p>
<p><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，-<strong>XX:PermSize</strong>代表永久代的初始容量。</p>
<p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p>
<p><strong>StackOverflowError</strong>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JVM设置  -Xss128k(默认1M)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        redo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redo();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:<span class="number">12</span>)</span><br><span class="line">	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:<span class="number">13</span>)</span><br><span class="line">	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:<span class="number">13</span>)</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p>
<p><strong>JVM内存参数大小该如何设置？</strong></p>
<p>JVM参数大小设置并没有固定标准，需要根据实际项目情况分析，给大家举个例子</p>
<p><strong>日均百万级订单交易系统如何设置JVM参数</strong></p>
<p><img src="/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9Fjvm%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96.png" alt="img"></p>
<p><strong>结论：****通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</strong></p>
<p>每日总结：</p>
<p>1、JDK体系结构及跨平台性：Jdk包含JRE【java运行时环境】，java语言的跨平台性，jvm在windows和linux上各自有对应的实现，javac编译的字节码文件可以运行在windows和linux环境，jvm屏蔽了底层操作系统的细节，使得java代码可以实现一次编译，到处运行。</p>
<p>2、Jvm整体结构和内存模型：Jvm分为三部分：类加载子系统【装载class类文件】、运行时数据区【Jvm内存区域】、执行引擎【执行字节码指令】</p>
<p>3、Jvm内存模型详解：</p>
<p>1)方法区：也叫元空间，存放class文件的地方</p>
<p>2)堆：存放内存对象</p>
<p>3)虚拟机栈：一个线程运行对应一个栈，线程内的方法对应一个栈帧【非嵌套】，栈帧包含：局部变量表、操作数栈、动态链接、方法出口</p>
<p>4)程序计数器：指针指令执行的行号。</p>
<p>5)本地方法栈</p>
<p>每日总结：</p>
<p>整理笔记：<a href="https://haze0x.github.io/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/">https://haze0x.github.io/2022/04/14/00-00-02-Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</a></p>
<p>1、jvm内存模型详解</p>
<p>共享</p>
<p>方法区【原空间】：存放常量+静态变量+类信息</p>
<p>堆：存放对象的地方</p>
<p>线程独占</p>
<p>程序计数器：指示程序执行的行号，线程上下文切换时可以通过程序计数器回复线程执行</p>
<p>本地方法栈：存放执行本地native方法的变量</p>
<p>虚拟机栈：一个线程运行对应一个栈，线程内的方法对应一个栈帧【非嵌套】，</p>
<p>栈帧包含：</p>
<p>局部变量表：存放局部变量</p>
<p>操作数栈：存放运算时的操作数</p>
<p>方法出口：方法执行完回到方法的初始位置，这个位置在调用方法的时候就已经记录到方法出口了</p>
<p>动态链接：区别于静态链接【静态链接是类加载过程中，符号引用替换为直接引用，比如 public main 等符号转化为原空间的地址】，动态链接是运行过程中，把符号引用转换成符号对应的代码的直接地址，比如上节课的main方法的 compute()方法</p>
<p>2、堆区内存模型</p>
<p>堆=新生代【eden(8/10)+s0(1/10)+s1(1/10)】+老年代</p>
<p>新生代：老年代=1：2</p>
<p>3、JVM内存参数配置</p>
<p>-Xss：每个线程的栈大小</p>
<p>-Xms：设置堆的初始可用大小，默认物理内存的1/64 </p>
<p>-Xmx：设置堆的最大可用大小，默认物理内存的1/4</p>
<p>-Xmn：新生代大小</p>
<p>-XX:NewRatio：默认2表示新生代占年老代的1/2，占整个堆内存的1/3。</p>
<p>-XX:SurvivorRatio：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。</p>
<p>关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N</p>
<p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。</p>
<p><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，-<strong>XX:PermSize</strong>代表永久代的初始容量。</p>
<p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm总结</title>
    <url>/2022/04/20/00-00-04-Jvm%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>



	<div class="row">
    <embed src="Jvm-xmind.png" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm总结大全</title>
    <url>/2022/04/26/00-00-10-Jvm%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>





	<div class="row">
    <embed src="Jvm-whole.png" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
        <tag>ZGC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引底层数据结构</title>
    <url>/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="MySQL索引底层数据结构"><a href="#MySQL索引底层数据结构" class="headerlink" title="MySQL索引底层数据结构"></a>MySQL索引底层数据结构</h2><h3 id="1、索引的本质"><a href="#1、索引的本质" class="headerlink" title="1、索引的本质"></a>1、索引的本质</h3><p>​    1、索引是帮助MySQL高效获取数据的排好序的数据结构</p>
<h3 id="2、索引的数据结构"><a href="#2、索引的数据结构" class="headerlink" title="2、索引的数据结构"></a>2、索引的数据结构</h3><ul>
<li>二叉树（对于单边增长的列，可能形成链表结构（单边树），导致查询次数很大，效率没有提升，所以不用二叉树做数据结构）         </li>
<li>红黑树（二叉平衡树，虽然有平衡功能，但是，数据量大时，树的高度会很高，查询次数很大）         </li>
<li>Hash表         </li>
<li>B-Tree</li>
</ul>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210408205955684.png" alt="img"></p>
<p>​    <strong>B-Tree：</strong></p>
<p>​    叶节点具有相同的深度，叶节点的指针为空 所有索引元素不重复 节点中的数据索引从左到右递增排列</p>
<p>​    一个节点存放多个索引元素，每个元素存放data数据（非叶子节点也存储data数据，获取data磁盘地址）</p>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210411114300848.png" alt="img"></p>
<p>​    <strong>B+Tree(B-Tree变种)</strong>       </p>
<p>​    非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引，有效的控制了树的高度 叶子节点包含所有索引字段（非叶子节点为冗余索引，为了构建B+树）       叶子节点用指针连接，提高区间访问的性能</p>
<p>​    B+树每个节点大小为一个页（通常为16kb 通过 show global status like ‘Innodb_page_size’;查询）</p>
<p>​    相比B Tree改动点：1&gt;非叶子节点不存储数据；2&gt;相邻叶子节点互相指向（其实也算是B+树的变种，B+树本身只是单向指向，方便范围查找）</p>
<p>​    查找数据过程：</p>
<p>​    先从磁盘加载根节点到内存（按页取数据，有版本的mysql是直接把根节点或非叶子节点常存在内存中），然后比对定位要查找数据的位置，依次查询下一个节    点，最后定位到叶子节点</p>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210411114329152.png" alt="img"></p>
<p>​    <strong>Hash</strong> </p>
<p>​    对索引的key进行一次hash计算就可以定位出数据存储的位置 很多时候Hash索引要比B+ 树索引更高效 仅能满足 “=”，“IN”，不支持范围查询 hash冲突问题</p>
<p>​    如果是等值查询，哈希索引明显有绝对优势， 前提：键值唯一</p>
<p>​    哈希索引没办法完成范围查询检索</p>
<p>​    哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询</p>
<p>​    哈希索引也不支持多列联合索引的</p>
<p>​    在有大量重复键值情况下，哈希索引的效率也最左前缀原则是极低的，因为存在哈希碰撞问题</p>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210411115009545.png" alt="img"></p>
<h3 id="3、存储引擎"><a href="#3、存储引擎" class="headerlink" title="3、存储引擎"></a>3、存储引擎</h3><ol>
<li><p>MyISAM存储引擎索引实现</p>
<p>所谓存储引擎是针对表的而非数据库的</p>
<p>MyISAM类型引擎的表包含三个文件.frm(框架文件，数据表结构相关的)、.MYD（存储数据的文件）、.MYI（存放索引的文件）</p>
<p>.MYI文件存储索引数据，MyISAM查找数据时先从索引文件拿到查找值的磁盘地址，然后去.MYD文件去检索数据</p>
<p>索引和数据不在同一个文件中，因此MyISAM索引被称为非聚集索引</p>
</li>
</ol>
<p>​        MyISAM 索引叶子节点data 存储的是索引所在行的磁盘文件地址</p>
<p>​        MyISAM索引文件和数据文件是分离的(非聚集)</p>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210411172128158.png" alt="img"></p>
<ol start="2">
<li><p>InnoDB存储引擎索引实现</p>
<p>使用InnoDB引擎的表包含两个文件：.frm文件为框架文件，存储数据结构相关信息的、.ibd文件存储索引和数据（索引和数据在同一个文件中，因此InnoDB索引被称为聚集索引）</p>
</li>
</ol>
<p>​        InnoDB 索引叶子节点data 存储的是索引所在行的是其它列的数据（对于主键索引来说）</p>
<p>​        InnoDB索引实现(聚集)     表数据文件本身就是按B+Tree组织的一个索引结构文件     聚集索引-叶节点包含了完整的数据记录（针对主键索引来说，二级索引通过回表取数）</p>
<ol start="3">
<li>问题</li>
</ol>
<p><strong>问：</strong>为什么InnoDB表必须有主键。并且推荐使用整型的自增主键：（整型：索引查找过程中涉及很多次比较，整型比较比字符串比较大小效率高；自增：）</p>
<p>1、如果设置了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增)。</p>
<p>2、如果表使用自增主键</p>
<p>那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页</p>
<p>3、如果使用非自增主键（如果身份证号或学号等）</p>
<p>由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p><strong>问：</strong>为什么非主键索引结构叶子结点存储的是主键值：(数据一致性和存储空间)</p>
<p>减少了出现行移动或者数据页分裂时二级索引的维护工作（当数据需要更新的时候，二级索引不需要修改，只需要修改聚簇索引，一个表只能有一个聚簇索引，其他的都是二级索引，这样只需要修改聚簇索引就可以了，不需要重新构建二级索引）</p>
<p>聚簇索引也称为主键索引，其索引树的叶子节点中存的是整行数据，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。因为索引（目录）只能按照一种方法进行排序。</p>
<p>非聚簇索引（普通索引）的叶子节点内容是主键的值。</p>
<p>在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
<p>但从索引角度讲：聚集索引比非聚集索引要快，聚集索引不需要跨文件取数据，效率更高</p>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210411172715616.png" alt="img"></p>
<h3 id="4、索引最左前缀原理"><a href="#4、索引最左前缀原理" class="headerlink" title="4、索引最左前缀原理"></a>4、索引最左前缀原理</h3><p>​        开发中用的最多的是联合索引，通过建立几个联合索引，可以满足90%左右的查询需求，不建议建立太多的单值索引</p>
<p>​        联合索引的底层存储结构长什么样?以下是组合主键所构成的索引结构</p>
<p><img src="/2022/05/20/00-02-00-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210411211835040.png" alt="img"></p>
<p>底层数据结构还是B+树    </p>
<p>排序时，逐个比较name age position字段；第一个字段name排好后，第二个age相对name是有序的</p>
<h3 id="5、二级索引查找数据过程"><a href="#5、二级索引查找数据过程" class="headerlink" title="5、二级索引查找数据过程"></a>5、二级索引查找数据过程</h3><p>​        先从二级索引中查出主键，在去主键所在索引查询数据（回表），好处：数据一致性、节省存储空间</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引优化实战一</title>
    <url>/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="MySQL索引优化实战"><a href="#MySQL索引优化实战" class="headerlink" title="MySQL索引优化实战"></a>MySQL索引优化实战</h2><p>索引优化使用的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `employees` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">  `age` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `position` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class="line">  `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工记录表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;LiLei&#x27;,22,&#x27;manager&#x27;,NOW());</span><br><span class="line">INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;HanMeimei&#x27;, 23,&#x27;dev&#x27;,NOW());</span><br><span class="line">INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;Lucy&#x27;,23,&#x27;dev&#x27;,NOW());</span><br><span class="line"></span><br><span class="line">-- 插入一些示例数据</span><br><span class="line">drop procedure if exists insert_emp; </span><br><span class="line">delimiter ;;</span><br><span class="line">create procedure insert_emp()        </span><br><span class="line">begin</span><br><span class="line">  declare i int;                    </span><br><span class="line">  set i=1;                          </span><br><span class="line">  while(i&lt;=100000)do                 </span><br><span class="line">    insert into employees(name,age,position) values(CONCAT(&#x27;zhuge&#x27;,i),i,&#x27;dev&#x27;);  </span><br><span class="line">    set i=i+1;                       </span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call insert_emp();</span><br></pre></td></tr></table></figure>

<h3 id="1、索引优化案例"><a href="#1、索引优化案例" class="headerlink" title="1、索引优化案例"></a>1、索引优化案例</h3><p>（1）、<strong>联合索引第一个字段用范围不会走索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name &gt; &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525003930519.png" alt="image-20220525003930519"></p>
<p>（2）、<strong>强制走索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees force index(idx_name_age_position) WHERE name &gt; &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004029952.png" alt="image-20220525004029952"></p>
<p>结论：虽然使用了强制走索引让联合索引第一个字段范围查找也走索引，扫描的行rows看上去也少了点，但是最终查找效率不一定比全表扫描高，因为回表效率不高。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 关闭查询缓存</span><br><span class="line">set global query_cache_size=0;  </span><br><span class="line">set global query_cache_type=0;</span><br><span class="line">-- 执行时间0.333s</span><br><span class="line">SELECT * FROM employees WHERE name &gt; &#x27;LiLei&#x27;;</span><br><span class="line">-- 执行时间0.444s</span><br><span class="line">SELECT * FROM employees force index(idx_name_age_position) WHERE name &gt; &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>

<p>（3）、<strong>覆盖索引优化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,age,position FROM employees WHERE name &gt; &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004234854.png" alt="image-20220525004234854"></p>
<p>可以看到，使用了覆盖索引，会走索引，不会出现（1）的情况</p>
<p>（4）、<strong>in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name in (&#x27;LiLei&#x27;,&#x27;HanMeimei&#x27;,&#x27;Lucy&#x27;) AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004346240.png" alt="image-20220525004346240"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE (name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;) AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004441564.png" alt="image-20220525004441564"></p>
<p>做一个小实验，将employees 表复制一张employees_copy的表，里面保留两三条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees_copy WHERE name in (&#x27;LiLei&#x27;,&#x27;HanMeimei&#x27;,&#x27;Lucy&#x27;) AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004539976.png" alt="image-20220525004539976"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees_copy WHERE (name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;) AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004557496.png" alt="image-20220525004557496"></p>
<p>结论：</p>
<p>sql语句走不走索引，还跟数据量有关系，底层会有个cost成功计算 。</p>
<p>（5）、<strong>like KK% 一般情况都会走索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name like &#x27;LiLei%&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004722547.png" alt="image-20220525004722547"></p>
<p>结论：右模糊相当于等值查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees_copy WHERE name like &#x27;LiLei%&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525004812843.png" alt="image-20220525004812843"></p>
<p><strong>索引下堆</strong></p>
<p>例如如下sql语句：</p>
<p><strong>SELECT * FROM employees WHERE name like ‘LiLei%’ AND age = 22 AND position =’manager’</strong></p>
<p>在<strong>MySQL5.6之前</strong>的版本，这个查询只能在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引，然后拿这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再比对<strong>age</strong>和<strong>position</strong>这两个字段的值是否符合。</p>
<p>MySQL 5.6引入了索引下推优化，<strong>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数</strong>。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引之后，同时还会在索引里过滤<strong>age</strong>和<strong>position</strong>这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。</p>
<p><strong>索引下堆好处：</strong></p>
<p>索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）树叶子节点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p>
<p><strong>为什么范围查找Mysql没有用索引下推优化？</strong></p>
<p>估计应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。</p>
<h3 id="2、MySQL如何选择合适索引"><a href="#2、MySQL如何选择合适索引" class="headerlink" title="2、MySQL如何选择合适索引"></a>2、MySQL如何选择合适索引</h3><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from employees where name &gt; &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525005129177.png" alt="image-20220525005129177"></p>
<p>如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select name,age,position from employees where name &gt; &#x27;a&#x27; ;    </span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525005237563.png" alt="image-20220525005237563"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from employees where name &gt; &#x27;zzz&#x27; ;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/24/00-02-03-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%80/image-20220525005302647.png" alt="image-20220525005302647"></p>
<p><strong>Trace工具的使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;  --开启trace</span><br><span class="line">mysql&gt; select * from employees where name &gt; &#x27;a&#x27; order by position;</span><br><span class="line">mysql&gt; SELECT * FROM information_schema.OPTIMIZER_TRACE;</span><br></pre></td></tr></table></figure>

<h3 id="3、常见SQL优化"><a href="#3、常见SQL优化" class="headerlink" title="3、常见SQL优化"></a>3、常见SQL优化</h3><p>1、MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。</p>
<p>2、order by满足两种情况会使用Using index。</p>
<ol>
<li><p>order by语句使用索引最左前列。</p>
</li>
<li><p>使用where子句与order by子句条件列组合满足索引最左前列。</p>
</li>
</ol>
<p>3、尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则。</p>
<p>4、如果order by的条件不在索引列上，就会产生Using filesort。</p>
<p>5、能用覆盖索引尽量用覆盖索引</p>
<p>6、group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上<strong>order by null禁止排序</strong>。注意，where高于having（尽量少用），能写在where中的限定条件就不要去having限定了。</p>
<h3 id="4、Using-filesort文件排序原理详解"><a href="#4、Using-filesort文件排序原理详解" class="headerlink" title="4、Using filesort文件排序原理详解"></a>4、<strong>Using filesort文件排序原理详解</strong></h3><p><strong>filesort文件排序方式</strong></p>
<ul>
<li>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</li>
<li>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</li>
</ul>
<p>MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p>
<ul>
<li>如果 字段的总长度小于max_length_for_sort_data ，那么使用 单路排序模式；</li>
<li>如果 字段的总长度大于max_length_for_sort_data ，那么使用 双路排序模·式。</li>
</ul>
<h3 id="5、索引设计原则"><a href="#5、索引设计原则" class="headerlink" title="5、索引设计原则"></a>5、索引设计原则</h3><p><strong>1、代码先行，索引后上</strong></p>
<p><strong>2、联合索引尽量覆盖条件</strong></p>
<p><strong>3、不要在小基数字段上建立索引</strong></p>
<p><strong>4、长字符串我们可以采用前缀索引</strong></p>
<p><strong>5、where与order by冲突时优先where</strong></p>
<p><strong>6、基于慢sql查询做优化</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>索引优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中sql语句执行过程</title>
    <url>/2022/05/23/00-02-02-MySQL%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="MySQL中sql语句执行过程"><a href="#MySQL中sql语句执行过程" class="headerlink" title="MySQL中sql语句执行过程"></a>MySQL中sql语句执行过程</h2><h3 id="1、MySQL的内部组件结构"><a href="#1、MySQL的内部组件结构" class="headerlink" title="1、MySQL的内部组件结构"></a>1、<strong>MySQL的内部组件结构</strong></h3><p><img src="/2022/05/23/00-02-02-MySQL%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/image-20220523225349348.png" alt="image-20220523225349348"></p>
<p>mysql由以下几部分组成：</p>
<h4 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h4><p>指链接mysql的客户端</p>
<h4 id="2-Server层"><a href="#2-Server层" class="headerlink" title="2.Server层"></a>2.Server层</h4><p>主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<ul>
<li><p><strong>连接器</strong></p>
<p>连接器负责跟客户端建立连接、获取权限、维持和管理连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 链接命令格式</span><br><span class="line">[root@192 ~]# mysql -h host[数据库地址] -u root[用户] -p root[密码] -P 3306</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>
<p>2、如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>
</blockquote>
<p>用户的权限表在系统表空间的mysql的user表中。</p>
<p>修改user密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;; //创建新用户</span><br><span class="line">mysql&gt; grant all privileges on *.* to &#x27;username&#x27;@&#x27;%&#x27;; //赋权限,%表示所有(host)</span><br><span class="line">mysql&gt; flush privileges //刷新数据库</span><br><span class="line">mysql&gt; update user set password=password(”123456″) where user=’root’;(设置用户名密码)</span><br><span class="line">mysql&gt; show grants for root@&quot;%&quot;; 查看当前用户的权限</span><br></pre></td></tr></table></figure>

<p>查看进程 show processlist 命令 关闭连接 kill 。</p>
<p><img src="/2022/05/23/00-02-02-MySQL%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/image-20220523230000412.png" alt="image-20220523230000412"></p>
<p>客户端如果长时间不发送command到Server端，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global variables like &quot;wait_timeout&quot;;</span><br><span class="line">mysql&gt;set global wait_timeout=28800; 设置全局服务器关闭非交互连接之前等待活动的秒数</span><br></pre></td></tr></table></figure></li>
<li><p><strong>查询缓存</strong></p>
<p>查询过程：</p>
<p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p>为什么说查询缓存很鸡肋？</p>
<p>因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p>一般建议大家在静态表里使用查询缓存，什么叫静态表呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表，那这张表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将my.cnf参数 query_cache_type 设置成 DEMAND。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my.cnf</span><br><span class="line">#query_cache_type有3个值 0代表关闭查询缓存OFF，1代表开启ON，2（DEMAND）代表当sql语句中有SQL_CACHE关键词时才缓存</span><br><span class="line">query_cache_type=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</span><br><span class="line">mysql&gt; select SQL_CACHE * from test where ID=5；</span><br><span class="line">## 查看当前mysql实例是否开启缓存机制</span><br><span class="line">mysql&gt; show global variables like &quot;%query_cache_type%&quot;;</span><br><span class="line">## 监控查询缓存的命中率:</span><br><span class="line">mysql&gt; show status like&#x27;%Qcache%&#x27;; //查看运行的缓存信息</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/23/00-02-02-MySQL%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/image-20220523230304435.png" alt="image-20220523230304435"></p>
<p>常用参数：</p>
<ul>
<li>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。</li>
<li>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。</li>
<li>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</li>
<li>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。</li>
<li>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。</li>
<li>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。</li>
<li>Qcache_queries_in_cache:当前缓存中缓存的查询数量。</li>
<li>Qcache_total_blocks:当前缓存的block数量。</li>
</ul>
<p><strong>mysql8.0已经移除了查询缓存功能</strong></p>
</li>
<li><p><strong>分析器</strong></p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么</p>
</li>
<li><p><strong>词法分析器原理</strong></p>
<p>词法分析器分成6个主要步骤完成对sql语句的分析</p>
<p>1、词法分析</p>
<p>2、语法分析</p>
<p>3、语义分析</p>
<p>4、构造执行树</p>
<p>5、生成执行计划</p>
<p>6、计划的执行</p>
<p>下图是SQL词法分析的过程步骤：</p>
<p><img src="/2022/05/23/00-02-02-MySQL%E4%B8%ADsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/image-20220523230439072.png" alt="image-20220523230439072"></p>
</li>
<li><p><strong>优化器</strong></p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p>
</li>
<li><p><strong>执行器</strong></p>
<p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>
<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p>
</li>
<li><p><strong>bin-log归档</strong></p>
<p>删库是不需要跑路的，因为我们的SQL执行时，会将sql语句的执行逻辑记录在我们的bin-log当中，什么是bin-log呢？</p>
<p>binlog是Server层实现的二进制日志,他会记录我们的cud操作。Binlog有以下几个特点：</p>
<p>1、Binlog在MySQL的Server层实现（引擎共用）</p>
<p>2、Binlog为逻辑日志,记录的是一条语句的原始逻辑</p>
<p>3、Binlog不限大小,追加写入,不会覆盖以前的日志    </p>
<p>如果，我们误删了数据库,可以使用binlog进行归档!要使用binlog归档，首先我们得记录binlog，因此需要先开启MySQL的binlog功能。只能恢复开启binlog之后的数据</p>
<p>配置my.cnf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 配置开启binlog</span><br><span class="line">log-bin=/usr/local/mysql/data/binlog/mysql-bin</span><br><span class="line">注意5.7以及更高版本需要配置本项：server-id=123454（自定义,保证唯一性）;</span><br><span class="line">#binlog格式，有3种statement,row,mixed</span><br><span class="line">binlog-format=ROW</span><br><span class="line">#表示每1次执行写入就与硬盘同步，会影响性能，为0时表示，事务提交时mysql不做刷盘操作，由系统决定</span><br><span class="line">sync-binlog=1</span><br></pre></td></tr></table></figure>

<p>binlog-format选项：</p>
<p>1、statement：记录的是sql语句，可能影响主从数据不一致（性能较好，安全性不是很高，比如一个更新语句  update set a=xxx where a=1 limit1 这种，多条数据的时候主从执行的时候可能更新的不是同一条数据），关注的是sql语句，是过程</p>
<p>2、row：记录的是语句执行后影响的记录的结果（性能差点，安全性高），关注的是结果</p>
<p>3、mixed：1和2的混合</p>
<p>如果对安全性要求比较高，建议用row</p>
</li>
</ul>
<h4 id="3-引擎层（Store层）"><a href="#3-引擎层（Store层）" class="headerlink" title="3.引擎层（Store层）"></a>3.引擎层（<strong>Store层</strong>）</h4><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说如果我们在create table时不指定表的存储引擎类型,默认会给你设置存储引擎为InnoDB。</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引优化实战二</title>
    <url>/2022/05/25/00-02-04-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="MySQL索引优化实战二"><a href="#MySQL索引优化实战二" class="headerlink" title="MySQL索引优化实战二"></a>MySQL索引优化实战二</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例表：</span><br><span class="line">CREATE TABLE `employees` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">  `age` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `position` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class="line">  `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工记录表&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="1、分页查询优化"><a href="#1、分页查询优化" class="headerlink" title="1、分页查询优化"></a>1、分页查询优化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employees limit 10000,10;</span><br></pre></td></tr></table></figure>

<p>此句执行语义：</p>
<p>从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。</p>
<p><code><strong>分页优化一</strong></code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employees where id &gt; 90000 limit 5;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/2022/05/25/00-02-04-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%BA%8C/image-20220525231814834.png" alt="image-20220525231814834"></p>
<p><strong>执行计划</strong></p>
<p><img src="/2022/05/25/00-02-04-MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%BA%8C/image-20220525231928709.png" alt="image-20220525231928709"></p>
<p><strong>结论:</strong></p>
<ul>
<li><p>SQL 走了索引，而且扫描的行数大大减少，执行效率更高。</p>
</li>
<li><p>在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致</p>
</li>
</ul>
<p><strong>此种方法使用条件</strong></p>
<ul>
<li>主键自增且连续</li>
<li>结果是按照主键排序的</li>
</ul>
<p><code><strong>根据非主键字段排序的分页查询</strong></code></p>
<p>根据非主键字段排序的分页查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;  select * from employees ORDER BY name limit 90000,5;</span><br></pre></td></tr></table></figure>

<p>此SQL不会走索引 <strong>扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p>
<p>优化如下===  ===&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;</span><br></pre></td></tr></table></figure>

<p>需要的结果与原 SQL 一致，执行时间减少了一半以上</p>
<h3 id="2、Join关联查询优化"><a href="#2、Join关联查询优化" class="headerlink" title="2、Join关联查询优化"></a>2、<strong>Join关联查询优化</strong></h3><p>驱动表与被驱动表</p>
<p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动表</strong>）里取出满足条件的行，然后取出两张表的结果合集。</p>
<p>left join：坐标是驱动表，右表是被驱动表</p>
<p>当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。</p>
<p><strong>1、</strong> <strong>嵌套循环连接</strong> <strong>Nested-Loop Join(NLJ) 算法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from t1 inner join t2 on t1.a= t2.a;</span><br></pre></td></tr></table></figure>

<p>NLJ过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从表 t2 中读取一行数据（如果t2表有查询过滤条件的，用先用条件过滤完，再从过滤结果里取出一行数据）；</span><br><span class="line">从第 1 步的数据中，取出关联字段 a，到表 t1 中查找；</span><br><span class="line">取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端；</span><br><span class="line">重复上面 3 步。</span><br><span class="line">整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100行)。因此整个过程扫描了 200 行。</span><br><span class="line">如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join算法。</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong> <strong>基于块的嵌套循环连接</strong> <strong>Block Nested-Loop Join(BNL)算法</strong></p>
<p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。</p>
<p>BNL过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把 t2 的所有数据放入到 join_buffer 中</span><br><span class="line">把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</span><br><span class="line">返回满足 join 条件的数据</span><br><span class="line">整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</span><br><span class="line">这个例子里表 t2 才 100 行，要是表 t2 是一个大表，join_buffer 放不下怎么办呢？·</span><br><span class="line">join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t2 的所有数据话，策略很简单，就是分段放。</span><br><span class="line">比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空  join_buffer ，再放入 t2 表剩余200行记录，再次从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</span><br></pre></td></tr></table></figure>

<p><strong>3、被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢？</strong></p>
<p>如上面两种：</p>
<p>如果在无索引情况下使用BNL，则扫描次数为100*10000次，显然次数比较多，使用BNL比较合理</p>
<h3 id="3、重点优化点"><a href="#3、重点优化点" class="headerlink" title="3、重点优化点"></a>3、重点优化点</h3><p><strong>（1）、关联sql的优化</strong></p>
<ul>
<li><strong>关联字段加索引</strong></li>
<li><strong>小表驱动大表</strong></li>
</ul>
<p>对于小表定义的明确：在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，<strong>过滤完成之后</strong>，计算参与 join 的各个字段的总数据量，<strong>数据量小的那个表，就是“小表”</strong>，应该作为驱动表。</p>
<p><strong>（2）、in和exsits优化</strong></p>
<p>原则：<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集</p>
<p>in后面跟小表数据</p>
<p>exist后面跟大表数据</p>
<p><strong>（3）、count优化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 临时关闭mysql查询缓存，为了查看sql多次执行的真实时间</span><br><span class="line">mysql&gt; set global query_cache_size=0;</span><br><span class="line">mysql&gt; set global query_cache_type=0;</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN select count(1) from employees;</span><br><span class="line">mysql&gt; EXPLAIN select count(id) from employees;</span><br><span class="line">mysql&gt; EXPLAIN select count(name) from employees;</span><br><span class="line">mysql&gt; EXPLAIN select count(*) from employees;</span><br></pre></td></tr></table></figure>

<p>字段有索引：count(*)≈count(1)&gt;count(字段)&gt;count(主键 id)    //字段有索引，count(字段)统计走二级索引，二级索引存储数据比主键索引少，所以count(字段)&gt;count(主键 id)</p>
<p>字段无索引：count(*)≈count(1)&gt;count(主键 id)&gt;count(字段)    //字段没有索引count(字段)统计走不了索引，count(主键 id)还可以走主键索引，所以count(主键 id)&gt;count(字段)</p>
<p><strong>（4）、查询mysql自己维护的总行数</strong></p>
<p>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算</p>
<p>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数(因为有MVCC机制，后面会讲)，查询count需要实时计算</p>
<p><strong>（5）、show table status</strong></p>
<p>如果只需要知道表总行数的估计值可以用如下sql查询，性能很高</p>
<p><strong>（6）、将总数维护到Redis里</strong></p>
<p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难保证表操作和redis操作的事务一致性</p>
<p><strong>（7）、增加数据库计数表</strong></p>
<p>插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>索引优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离级别及锁机制</title>
    <url>/2022/05/26/00-02-05-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Mysql事务隔离级别与锁机制"><a href="#Mysql事务隔离级别与锁机制" class="headerlink" title="Mysql事务隔离级别与锁机制"></a>Mysql事务隔离级别与锁机制</h2><h3 id="1、事务并发如何解决"><a href="#1、事务并发如何解决" class="headerlink" title="1、事务并发如何解决"></a>1、事务并发如何解决</h3><ul>
<li><strong>事务隔离机制</strong></li>
<li><strong>锁机制</strong></li>
<li><strong>MVCC多版本并发控制隔离机制</strong></li>
</ul>
<h3 id="2、事务及其ACID属性"><a href="#2、事务及其ACID属性" class="headerlink" title="2、事务及其ACID属性"></a>2、<strong>事务及其ACID属性</strong></h3><p>事务具有以下4个属性（ACID）</p>
<ul>
<li>原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。  从操作的维度</li>
<li>一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。  从数据一致性的维度</li>
<li>隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</li>
<li>持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</li>
</ul>
<h3 id="3、并发事务带来的问题"><a href="#3、并发事务带来的问题" class="headerlink" title="3、并发事务带来的问题"></a>3、并发事务带来的问题</h3><ul>
<li><p>更新丢失(Lost Update)或脏写</p>
<p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–<strong>最后的更新覆盖了由其他事务所做的更新</strong>。</p>
</li>
<li><p>脏读（Dirty Reads）</p>
<p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。</p>
</li>
</ul>
<p>　　一句话：<strong>事务A读取到了事务B已经修改但尚未提交的数据</strong>，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p>
<ul>
<li><p>不可重读（Non-Repeatable Reads） </p>
<p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。</p>
</li>
</ul>
<p>　　一句话：<strong>事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性</strong></p>
<ul>
<li>幻读（Phantom Reads）</li>
</ul>
<p>　　一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p>
<p>　　一句话：<strong>事务A读取到了事务B提交的新增数据，不符合隔离性</strong></p>
<h3 id="4、事务隔离级别"><a href="#4、事务隔离级别" class="headerlink" title="4、事务隔离级别"></a>4、事务隔离级别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常看当前数据库的事务隔离级别: show variables like &#x27;tx_isolation&#x27;;</span><br><span class="line">设置事务隔离级别：set tx_isolation=&#x27;REPEATABLE-READ&#x27;;</span><br><span class="line">Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别</span><br></pre></td></tr></table></figure>



<p><img src="/2022/05/26/00-02-05-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E9%94%81%E6%9C%BA%E5%88%B6/image-20220527000218134.png" alt="image-20220527000218134"></p>
<p>注：隔离级别控制的越严格，事务的副作用越小，性能会更低</p>
<h3 id="5、MySQL中的锁"><a href="#5、MySQL中的锁" class="headerlink" title="5、MySQL中的锁"></a>5、MySQL中的锁</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p><strong>锁分类</strong></p>
<ul>
<li>从性能上分为乐观锁(用版本对比来实现)和悲观锁</li>
<li>从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)</li>
</ul>
<p>读锁（共享锁，S锁(<strong>S</strong>hared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响</p>
<p>写锁（排它锁，X锁(e<strong>X</strong>clusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁</p>
<ul>
<li>从对数据操作的粒度分，分为表锁和行锁</li>
</ul>
<p><strong>表锁</strong>：一般用于迁移数据</p>
<p>INNER/MYISAM 存储引擎都有表锁</p>
<p>每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。</p>
<p>不允许更新和插入</p>
<p><strong>行锁</strong></p>
<p>每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p>
<p>InnoDB与MYISAM的最大不同有两点：</p>
<ul>
<li><strong>InnoDB支持事务（TRANSACTION）</strong></li>
<li><strong>InnoDB支持行级锁</strong></li>
<li><strong>MYISAM不支持行锁，不支持事务</strong></li>
</ul>
<p><strong>锁总结</strong></p>
<p>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</p>
<p>InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。</p>
<p>简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</p>
<p><strong>间隙锁(Gap Lock)</strong></p>
<p>间隙锁，锁的就是两个值之间的空隙。在一定程度上可以解决幻读问题。</p>
<p>假设account表里数据如下：</p>
<p>​    <img src="/2022/05/26/00-02-05-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E9%94%81%E6%9C%BA%E5%88%B6/image-20220527000626327.png" alt="image-20220527000626327"></p>
<p>那么间隙就有 id 为 (3,10)，(10,20)，(20,正无穷) 这三个区间，</p>
<p>在Session_1下面执行 update account set name = ‘zhuge’ where id &gt; 8 and id &lt;18;，则其他Session没法在这个<strong>范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙</strong>里插入或修改任何数据，即id在(3,20]区间都无法修改数据，注意最后那个20也是包含在内的。【只要sql语句范围有一个落在了上面三个区间里，则那个区间就会被加锁】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例说明：</span><br><span class="line">以上图作为例子</span><br><span class="line">Session_1执行update account set name = &#x27;zhuge&#x27; where id &gt; 8 and id &lt;18 事务还未提交</span><br><span class="line">Session_2执行了</span><br><span class="line">insert into account(id,name,balance)values(21,&#x27;xg&#x27;,123)  可以插入</span><br><span class="line">insert into account(id,name,balance)values(19,&#x27;xg&#x27;,123)  不可以插入 虽然你锁的范围是8~18 但实际占两个空间 即（3，10）、（10，20）</span><br><span class="line">**间隙锁是在可重复读隔离级别下才会生效。**</span><br></pre></td></tr></table></figure>



<p>**临键锁(Next-key Locks)**：间隙锁+表锁 = 临键锁</p>
<p>Next-Key Locks是行锁与间隙锁的组合。像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。</p>
<p><strong>无索引行锁会升级为表锁(RR级别会升级为表锁，RC级别不会升级为表锁)</strong></p>
<p>锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁</p>
<p>session1 执行：update account set balance = 800 where name = ‘lilei’;（name没有加索引）</p>
<p>session2 对该表任一行操作都会阻塞住</p>
<p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁****。</strong></p>
<p>锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如：select * from test_innodb_lock where a = 2 for update; 这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交</p>
<p><strong>锁优化建议</strong></p>
<ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少检索条件范围，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行</li>
<li>尽可能低级别事务隔离</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>隔离级别</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解MVCC与BufferPool缓存机制</title>
    <url>/2022/05/27/00-02-06-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="1、MVCC"><a href="#1、MVCC" class="headerlink" title="1、MVCC"></a>1、MVCC</h2><p><strong>概念：</strong></p>
<p>MVCC：<strong>Multi-Version Concurrency Control</strong>，多版本并发控制</p>
<p>作用：读已提交和可重复读隔离级别下，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，保证并发事务的安全性。</p>
<p><strong>undo日志版本链与read view机制</strong></p>
<p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p>
<p>具体对于MVCC的理解，详见下图的示例</p>
<p><strong>需要注意的点</strong></p>
<p>读已提交是每次执行select就生成一次一致性试图，可重复读只在第一次select的时候生成。</p>
<p>在可重复读隔离级别下，在一个事务中，一致性试图实在第一次执行select语句的时候生成的，除非有其它增删改操作，否则一致性试图不会变。同时无论第一次执行的是哪个表的select语句，其它表的一致性试图都不会变，即开始执行的select语句，会生成当前所有表的一致性视图；</p>
<p>示例如下：</p>
<p>（1）begin，执行actor表的select语句</p>
<p><img src="/2022/05/27/00-02-06-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20220528135240234.png" alt="image-20220528135240234"></p>
<p>（2）查询account表：</p>
<p><img src="/2022/05/27/00-02-06-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20220528135303794.png" alt="image-20220528135303794"></p>
<p>（3）更改account表的数据，添加一条</p>
<p><img src="/2022/05/27/00-02-06-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20220528135325995.png" alt="image-20220528135325995"></p>
<p>（4）再次查询account表数据，结果没变</p>
<p><img src="/2022/05/27/00-02-06-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20220528135359550.png" alt="image-20220528135359550"></p>
<p><a href="https://www.processon.com/view/link/6291a3ea637689545dd6d4ae">MVCC示例图</a></p>
<h2 id="2、Innodb引擎SQL执行的BufferPool缓存机制"><a href="#2、Innodb引擎SQL执行的BufferPool缓存机制" class="headerlink" title="2、Innodb引擎SQL执行的BufferPool缓存机制"></a>2、<strong>Innodb引擎SQL执行的BufferPool缓存机制</strong></h2><p><a href="https://www.processon.com/view/link/6291e2e57d9c085adb719a5f">Innodb引擎底层结构</a></p>
<p><img src="/2022/05/27/00-02-06-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20220528165311124.png" alt="image-20220528165311124"></p>
<p><strong>注：</strong></p>
<p><strong>上述步骤说明：</strong></p>
<p><strong>（1）、先按页查出老的数据所在页数据，</strong></p>
<p><strong>（2）、将老数据存储到undo 日志文件中，便于回滚</strong></p>
<p><strong>（3）、将内存数据（缓存数据）更新为新值，即zhuge-&gt;zhuge666</strong></p>
<p><strong>（4）、写Redo Log（重做日志），有缓存机制，批量写入</strong></p>
<p><strong>（5）、准备提交事务，redo log日志写入磁盘</strong></p>
<p><strong>（6）、准备提交事务，binlog日志写入磁盘</strong></p>
<p><strong>（7）、binlog日志写入磁盘完毕后，写入commit标记到redo日志文件里面，然后真正的提交事务；此步目的是为了保证redo日志和binlog日志数据一致；此步做完，客户端任务事务已经执行成功了，实际上数据可能还没有写入磁盘</strong></p>
<p><strong>（8）、随机写入磁盘，以page为单位写入，此步做完，磁盘里面的数据就变成了zhuge666。可能在执行此步前，mysql宕机了，可以通过redo log日志恢复数据</strong></p>
<p><strong>redo Log是什么？</strong></p>
<p><strong>是重做日志，用来恢复buffer pool里面的数据</strong></p>
<p><strong>bin Log是什么？</strong></p>
<p><strong>恢复磁盘数据</strong></p>
<p><strong>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？</strong></p>
<p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。</p>
<p>因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。</p>
<p>Mysql这套机制看起来复杂，但它可以保证每个更新请求都是<strong>更新内存BufferPool</strong>，然后<strong>顺序写日志文件</strong>，同时还能保证各种异常情况下的数据一致性。</p>
<p>更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。</p>
<p>正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求。</p>
<p>通过这样一套机制，既能保证数据不丢失，也能保证高效率</p>
<p>针对数据库磁盘数据的写是随机写，针对redo log是顺序写</p>
<p>为什么数据库磁盘数据文件不能顺序io，而redo log日志文件可以顺序io?</p>
<p>数据库磁盘文件会涉及到数据段额删除，可能一段顺序io中间一部分会被删除掉，插入其它的数据；而redo log文件只会顺序地在末尾新增，不会删除</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL总结</title>
    <url>/2022/05/28/00-02-07-MySQL%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://www.processon.com/view/link/6292d8a20e3e74603c4a31a8">MySQL脑图</a></p>
<p><a href="https://www.processon.com/view/link/6291e2e57d9c085adb719a5f">MySQL结构图</a></p>
<p><a href="https://www.processon.com/view/link/6291a3ea637689545dd6d4ae">MVCC示例图</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>隔离级别</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载机制深度解析</title>
    <url>/2021/12/11/00_00_01_JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之深入理解JMM</title>
    <url>/2022/04/27/01-00-00-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="并发编程之深入理解JMM-amp-并发三大特性"><a href="#并发编程之深入理解JMM-amp-并发三大特性" class="headerlink" title="并发编程之深入理解JMM&amp;并发三大特性"></a>并发编程之深入理解JMM&amp;并发三大特性</h2><p><strong>并发解决什么问题？</strong></p>
<p>并发是为了解决多线程同步【线程依赖，一个或多个线程依赖另一个线程的执行】、互斥【共享资源一个线程占用了，其它的就不可用，必须等资源释放掉】、分工【把一个大的任务拆分成小的任务最后在合并】问题的。主要是解决线程协作问题。</p>
<h3 id="1、并发和并行"><a href="#1、并发和并行" class="headerlink" title="1、并发和并行"></a>1、并发和并行</h3><p>目标都是最大化CPU的使用率</p>
<p>**并行(parallel)**：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><img src="/2022/04/27/01-00-00-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/28460.png" alt="img"></p>
<p>**并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。 </p>
<p><img src="/2022/04/27/01-00-00-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/28461.png" alt="img"></p>
<p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行） </p>
<p>JMM模型：</p>
<p>内存模型，与线程间通信有关、共享内存模型。</p>
<h3 id="2、并发三大特性"><a href="#2、并发三大特性" class="headerlink" title="2、并发三大特性"></a>2、并发三大特性</h3><p>并发编程Bug的源头：可见性、原子性和有序性问题</p>
<p><strong>可见性</strong></p>
<p>当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。</p>
<p><em>如何保证可见性</em></p>
<ul>
<li>通过 volatile 关键字保证可见性。</li>
<li>通过 内存屏障保证可见性。</li>
<li>通过 synchronized 关键字保证可见性。</li>
<li>通过 Lock保证可见性。</li>
<li>通过 final 关键字保证可见性</li>
</ul>
<p><strong>有序性</strong></p>
<p>即程序执行的顺序按照代码的先后顺序执行。JVM 存在指令重排，所以存在有序性问题。</p>
<p><em>如何保证有序性</em></p>
<ul>
<li><p>通过 volatile 关键字保证可见性。</p>
</li>
<li><p>通过 内存屏障保证可见性。</p>
</li>
<li><p>通过 synchronized关键字保证有序性。</p>
</li>
<li><p>通过 Lock保证有序性。</p>
</li>
</ul>
<p><strong>原子性</strong></p>
<p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作（64位处理器）。不采取任何的原子性保障措施的自增操作并不是原子性的。</p>
<p><em>如何保证原子性</em></p>
<ul>
<li><p>通过 synchronized 关键字保证原子性。</p>
</li>
<li><p>通过 Lock保证原子性。</p>
</li>
<li><p>通过 CAS保证原子性。</p>
<p>思考：在 32 位的机器上对 long 型变量进行加减操作是否存在并发隐患？</p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7">https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7</a></p>
<p><strong>可见性问题深入分析例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  storeLoad  JVM内存屏障  ----&gt;  (汇编层面指令)  lock; addl $0,0(%%rsp)</span></span><br><span class="line">    <span class="comment">// lock前缀指令不是内存屏障的指令，但是有内存屏障的效果   缓存失效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改flag:&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行.....&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//TODO  业务逻辑</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//JMM模型    内存模型： 线程间通信有关   共享内存模型</span></span><br><span class="line">            <span class="comment">//没有跳出循环   可见性的问题</span></span><br><span class="line">            <span class="comment">//能够跳出循环   内存屏障</span></span><br><span class="line">            <span class="comment">//UnsafeFactory.getUnsafe().storeFence();</span></span><br><span class="line">            <span class="comment">//能够跳出循环    ?   释放时间片，上下文切换   加载上下文：flag=true</span></span><br><span class="line">            <span class="comment">//Thread.yield();</span></span><br><span class="line">            <span class="comment">//能够跳出循环    内存屏障</span></span><br><span class="line">            <span class="comment">//System.out.println(count);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//LockSupport.unpark(Thread.currentThread());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//shortWait(1000000); //1ms</span></span><br><span class="line">            <span class="comment">//shortWait(1000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(1);   //内存屏障</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//总结：  Java中可见性如何保证？ 方式归类有两种：</span></span><br><span class="line">            <span class="comment">//1.  jvm层面 storeLoad内存屏障    ===&gt;  x86   lock替代了mfence</span></span><br><span class="line">            <span class="comment">// 2.  上下文切换   Thread.yield();</span></span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 自己总结：</span></span><br><span class="line">            <span class="comment">// 1、不加任何代码，线程不会终止，不会跳出循环，可见性问题，当前线程不会感知到其它线程对这个变量的更改    </span></span><br><span class="line">			<span class="comment">// 2、Thread.yield(); 能够跳出循环 与 释放时间片 上下文切换有关，上下文切换会去主存种加载最新的值【还原上下文会重新获取主内存数据】</span></span><br><span class="line">			<span class="comment">// 3、System.out.println(count); 能够跳出循环 底层synchronized语义可以保证可见性-&gt;调用UnsafeFactory.getUnsafe().storeFence()</span></span><br><span class="line">            <span class="comment">// 4、UnsafeFactory.getUnsafe().storeFence(); 能够跳出循环</span></span><br><span class="line">            <span class="comment">// 5、LockSupport.unpark(Thread.currentThread()); 能够跳出循环</span></span><br><span class="line">            <span class="comment">// 6、flag加volatile;能够跳出循环 volatile 保证可见性</span></span><br><span class="line">            <span class="comment">// 7、count 加volatile;能够跳出循环 </span></span><br><span class="line">            <span class="comment">// 8、count用Integer包装类型【开始用基本类型】；能够跳出循环 包装类属性值value是final类型的，jmm对final修饰的变量也要保证可见性</span></span><br><span class="line">            <span class="comment">// 9、shortWait(1000000); //1ms 能够跳出循环 线程本地缓存被清掉了，然后又去主内存里面加载最新的数据了</span></span><br><span class="line">            <span class="comment">// 10、shortWait(1000); //1us 不能够跳出循环 时间太短，线程本地缓存没有清理掉</span></span><br><span class="line">            <span class="comment">// 11、Thread.sleep(1); // 能够跳出循环 也可以保证可见性</span></span><br><span class="line">            <span class="comment">// 总结：Java中可见性如何保证的： 1&gt;jvm层面storeLoad内存屏障(x86下 lock替换了mFence)</span></span><br><span class="line">            <span class="comment">//						     2&gt;上下文切换  Thread.yield()</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;跳出循环: count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VisibilityTest test = <span class="keyword">new</span> VisibilityTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程threadA模拟数据加载场景</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; test.load(), <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让threadA执行一会儿</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 线程threadB通过flag控制threadA的执行时间</span></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; test.refresh(), <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125; <span class="keyword">while</span> (start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ##备注：</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这种代码不会释放时间片，在分时调度系统中，会按照优先级进行分时调度，这种代码优先级很高，所以不会释放时间片，及时时间片释放了，下次竞争获取的时候会认为它优先级比较高，优先分配时间片-&gt;这种导致的问题，可能导致优先级比较低的线程饥饿</span></span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3></li>
</ul>
<h3 id="3、Java内存模型（JMM）"><a href="#3、Java内存模型（JMM）" class="headerlink" title="3、Java内存模型（JMM）"></a>3、<strong>Java内存模型（JMM）</strong></h3><p><strong>JMM定义</strong></p>
<p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。</p>
<p><img src="/2022/04/27/01-00-00-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/28523.png" alt="img"></p>
<p><img src="/2022/04/27/01-00-00-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/image-20220427232919763.png" alt="image-20220427232919763"></p>
<h3 id="4、volatile的内存语义"><a href="#4、volatile的内存语义" class="headerlink" title="4、volatile的内存语义"></a>4、volatile的内存语义</h3><p>volatile底层对应汇编的lock前缀指令，lock前缀指令不是内存屏障，但是可以起到内存屏障的作用，可以使缓存失效</p>
<p><strong>volatile的特性</strong></p>
<ul>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性（基于这点，我们通过会认为volatile不具备原子性）。volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。 </li>
</ul>
<p>64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。</p>
<ul>
<li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性。</li>
</ul>
<p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p><strong>volatile写-读的内存语义</strong></p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</li>
</ul>
<p><strong>volatile可见性实现原理</strong></p>
<p><strong>JMM内存交互层面实现</strong></p>
<p>volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量操作对多线程的可见性。</p>
<p><strong>硬件层面实现</strong></p>
<p>通过lock前缀指令，会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<p>总结：</p>
<p>Java中可见性如何保证的</p>
<p>1&gt;jvm层面storeLoad内存屏障(x86下 lock替换了mFence)</p>
<p>2&gt;上下文切换  Thread.yield()</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之深入理解CAS</title>
    <url>/2022/04/30/01-00-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="并发编程之深入理解CAS"><a href="#并发编程之深入理解CAS" class="headerlink" title="并发编程之深入理解CAS"></a>并发编程之深入理解CAS</h2><h3 id="1、什么是CAS"><a href="#1、什么是CAS" class="headerlink" title="1、什么是CAS"></a>1、什么是CAS</h3><p>CAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == expectedValue) &#123;</span><br><span class="line">    value = newValue;</span><br></pre></td></tr></table></figure>

<p>以上伪代码描述了一个由比较和赋值两阶段组成的复合操作，CAS 可以看作是它们合并后的整体——一个不可分割的原子操作，并且其原子性是直接在硬件层面得到保障的。</p>
<p>CAS可以看做是乐观锁（对比数据库的悲观、乐观锁）的一种实现方式，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<p>CAS是一种无锁算法，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p>
<p><strong>CAS在java x86架构下由底层cmpxchgi汇编指令实现（不同的架构下实现的指令不同，cas底层指令本身并不能保证可见性，但是java中的cas经过jdk底层封装，给其加了lock前缀指令，所以可以保证可见性，原子性和有序性）</strong></p>
<h3 id="2、CAS的应用"><a href="#2、CAS的应用" class="headerlink" title="2、CAS的应用"></a>2、CAS的应用</h3><p>在 Java 中，CAS 操作是由 Unsafe 类提供支持的，该类定义了三种针对不同类型变量的 CAS 操作，如图</p>
<p><img src="/2022/04/30/01-00-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/image-20220430203356047.png" alt="image-20220430203356047"></p>
<p>它们都是 native 方法，由 Java 虚拟机提供具体实现，这意味着不同的 Java 虚拟机对它们的实现可能会略有不同。</p>
<p>以 compareAndSwapInt 为例，Unsafe 的 compareAndSwapInt 方法接收 4 个参数，分别是：对象实例、内存偏移量、字段期望值、字段新值。该方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作。</p>
<h3 id="3、CAS底层源码"><a href="#3、CAS底层源码" class="headerlink" title="3、CAS底层源码"></a>3、CAS底层源码</h3><p>Hotspot 虚拟机对compareAndSwapInt 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#unsafe.<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="title">UNSAFE_ENTRY</span><span class="params">(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)</span>)</span></span><br><span class="line"><span class="function">  <span class="title">UnsafeWrapper</span><span class="params">(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>)</span></span>;</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// 根据偏移量，计算value的地址</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// Atomic::cmpxchg(x, addr, e) cas逻辑 x:要交换的值   e:要比较的值</span></span><br><span class="line">  <span class="comment">//cas成功，返回期望值e，等于e,此方法返回true </span></span><br><span class="line">  <span class="comment">//cas失败，返回内存中的value值，不等于e，此方法返回false</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br></pre></td></tr></table></figure>

<p>核心逻辑在Atomic::cmpxchg方法中，这个根据不同操作系统和不同CPU会有不同的实现。这里我们以linux_64x的为例，查看Atomic::cmpxchg的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#atomic_linux_x86.inline.hpp</span><br><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="comment">//判断当前执行环境是否为多处理器环境</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="comment">//LOCK_IF_MP(%4) 在多处理器环境下，为 cmpxchgl 指令添加 lock 前缀，以达到内存屏障的效果</span></span><br><span class="line">  <span class="comment">//cmpxchgl 指令是包含在 x86 架构及 IA-64 架构中的一个原子条件指令，</span></span><br><span class="line">  <span class="comment">//它会首先比较 dest 指针指向的内存值是否和 compare_value 的值相等，</span></span><br><span class="line">  <span class="comment">//如果相等，则双向交换 dest 与 exchange_value，否则就单方面地将 dest 指向的内存值交给exchange_value。</span></span><br><span class="line">  <span class="comment">//这条指令完成了整个 CAS 操作，因此它也被称为 CAS 指令。</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> &quot;cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>&quot;</span></span><br><span class="line"><span class="function">                    : &quot;</span>=a<span class="string">&quot; (exchange_value)</span></span><br><span class="line"><span class="string">                    : &quot;</span>r<span class="string">&quot; (exchange_value), &quot;</span>a<span class="string">&quot; (compare_value), &quot;</span>r<span class="string">&quot; (dest), &quot;</span>r<span class="string">&quot; (mp)</span></span><br><span class="line"><span class="string">                    : &quot;</span>cc<span class="string">&quot;, &quot;</span>memory<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  return exchange_value;</span></span><br></pre></td></tr></table></figure>

<p>cmpxchgl的详细执行过程：</p>
<p>首先，输入是”r” (exchange_value), “a” (compare_value), “r” (dest), “r” (mp)，表示compare_value存入eax寄存器，而exchange_value、dest、mp的值存入任意的通用寄存器。嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以“%0”开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。</p>
<p>因此，cmpxchg %1,(%3)实际上表示cmpxchg exchange_value,(dest)</p>
<p>需要注意的是cmpxchg有个隐含操作数eax，其实际过程是先比较eax的值(也就是compare_value)和dest地址所存的值是否相等，</p>
<p>输出是”=a” (exchange_value)，表示把eax中存的值写入exchange_value变量中。</p>
<p>Atomic::cmpxchg这个函数最终返回值是exchange_value，也就是说，如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成exchange_value，最终eax存的compare_value赋值给了exchange_value变量，即函数最终返回的值是原先的compare_value。此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给exchange_value变量作为返回值，导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。</p>
<p>现代处理器指令集架构基本上都会提供 CAS 指令，例如 x86 和 IA-64 架构中的 cmpxchgl 指令和 comxchgq 指令，sparc 架构中的 cas 指令和 casx 指令。</p>
<p>不管是 Hotspot 中的 Atomic::cmpxchg 方法，还是 Java 中的 compareAndSwapInt 方法，它们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然的原子性，这也正是 CAS 的价值所在。</p>
<h3 id="4、CAS存在的问题"><a href="#4、CAS存在的问题" class="headerlink" title="4、CAS存在的问题"></a>4、CAS存在的问题</h3><p>CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：</p>
<ul>
<li>自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销</li>
<li>只能保证一个共享变量原子操作</li>
<li><strong>ABA 问题</strong></li>
</ul>
<h3 id="5、ABA问题及解决方案"><a href="#5、ABA问题及解决方案" class="headerlink" title="5、ABA问题及解决方案"></a>5、ABA问题及解决方案</h3><p><strong>ABA问题</strong></p>
<p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差内会导致数据的变化。</p>
<p><strong>什么是ABA问题</strong></p>
<p>当有多个线程对一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，此时其他线程不感知，还是会修改成功。</p>
<p><img src="/2022/04/30/01-00-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/image-20220430203553693.png" alt="image-20220430203553693"></p>
<p><strong>ABA问题解决方案</strong></p>
<p>数据库有个锁称为乐观锁，是一种基于数据版本实现数据同步的机制，每次修改一次数据，版本就会进行累加。</p>
<p>同样，Java也提供了相应的原子引用类AtomicStampedReference</p>
<ul>
<li>原子引用类AtomicStampedReference</li>
</ul>
<p><img src="/2022/04/30/01-00-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/image-20220430203642742.png" alt="image-20220430203642742"></p>
<p>reference即我们实际存储的变量，stamp是版本，每次修改可以通过+1保证版本唯一性。这样就可以保证每次修改后的版本也会往上递增。</p>
<ul>
<li>AtomicMarkableReference</li>
</ul>
<p>AtomicMarkableReference可以理解为上面AtomicStampedReference的简化版，就是不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。</p>
<p><img src="/2022/04/30/01-00-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/image-20220430203739491.png" alt="image-20220430203739491"></p>
<h3 id="6、并发工具之Atomic原子操作类"><a href="#6、并发工具之Atomic原子操作类" class="headerlink" title="6、并发工具之Atomic原子操作类"></a>6、并发工具之Atomic原子操作类</h3><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
<table>
<thead>
<tr>
<th>原子操作类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AtomicInteger、AtomicLong、AtomicBoolean；</td>
<td>适用于基本类型</td>
</tr>
<tr>
<td>AtomicReference、AtomicStampedRerence、AtomicMarkableReference</td>
<td>适用于引用类型</td>
</tr>
<tr>
<td>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</td>
<td>适用于数组类型</td>
</tr>
<tr>
<td>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</td>
<td>对象属性原子修改器</td>
</tr>
<tr>
<td>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64</td>
<td>原子类型累加器（jdk1.8增加的类）</td>
</tr>
</tbody></table>
<p><strong>LongAdder/DoubleAdder详解</strong></p>
<p>LongAdder/DoubleAdder引入的初衷——解决高并发环境下<strong>AtomicInteger，AtomicLong</strong>的自旋瓶颈问题。</p>
<p><strong>LongAdder原理</strong></p>
<p><strong>设计思路</strong></p>
<p>AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。LongAdder的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。 </p>
<p><img src="/2022/04/30/01-00-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS/image-20220430204225389.png" alt="image-20220430204225389"></p>
<p><strong>LongAdder的内部结构</strong></p>
<p>LongAdder内部有一个base变量，一个Cell[]数组：</p>
<p>base变量：非竞态条件下，直接累加到该变量上</p>
<p>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解synchronized</title>
    <url>/2022/05/02/01-00-05-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h2><h3 id="1、偏向锁批量重偏向-amp-批量撤销"><a href="#1、偏向锁批量重偏向-amp-批量撤销" class="headerlink" title="1、偏向锁批量重偏向&amp;批量撤销"></a>1、偏向锁批量重偏向&amp;批量撤销</h3><p>从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong></p>
<p>以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。</p>
<p>每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。</p>
<p>当达到重偏向阈值（默认20）后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<p><strong>应用场景</strong></p>
<p>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。 </p>
<p>批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p><strong>JVM的默认参数值</strong></p>
<p>设置JVM参数-XX:+PrintFlagsFinal，在项目启动时即可输出JVM的默认参数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intx BiasedLockingBulkRebiasThreshold   = <span class="number">20</span>   <span class="comment">//默认偏向锁批量重偏向阈值</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过-XX:BiasedLockingBulkRebiasThreshold 和 -XX:BiasedLockingBulkRevokeThreshold 来手动设置阈值</p>
<p><strong>总结</strong></p>
<ol>
<li>批量重偏向和批量撤销是针对类的优化，和对象无关。</li>
<li>偏向锁重偏向一次之后不可再次重偏向。</li>
<li>当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利</li>
</ol>
<h3 id="2、自旋优化"><a href="#2、自旋优化" class="headerlink" title="2、自旋优化"></a>2、<strong>自旋优化</strong></h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li>
<li>在 Java 6 之后自旋是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能。 </li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p>注意：自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调用，存在用户态和内核态切换，这才是重量级锁最大的开销） </p>
<h3 id="3、锁粗化"><a href="#3、锁粗化" class="headerlink" title="3、锁粗化"></a>3、<strong>锁粗化</strong></h3><p>假设一系列的连续操作都会对同一个对象反复加锁及解锁，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁粗化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">()</span></span>&#123;</span><br><span class="line">    buffer.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot; bbb&quot;</span>).append(<span class="string">&quot; ccc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码每次调用 buffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h3 id="4、锁消除"><a href="#4、锁消除" class="headerlink" title="4、锁消除"></a>4、<strong>锁消除</strong></h3><p>锁消除即删除不必要的加锁操作。锁消除是Java虚拟机在JIT编译期间，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockEliminationTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁消除</span></span><br><span class="line"><span class="comment">     * -XX:+EliminateLocks 开启锁消除(jdk8默认开启）</span></span><br><span class="line"><span class="comment">     * -XX:-EliminateLocks 关闭锁消除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LockEliminationTest demo = <span class="keyword">new</span> LockEliminationTest();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            demo.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer的append是个同步方法，但是append方法中的 StringBuffer 属于一个局部变量，不可能从该方法中逃逸出去，因此其实这过程是线程安全的，可以将锁消除。</p>
<p>测试结果： 关闭锁消除执行时间4688 ms   开启锁消除执行时间：2601 ms</p>
<p><strong>逃逸分析(Escape Analysis）</strong></p>
<p>逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域。</p>
<p><strong>方法逃逸(对象逃出当前方法)</strong></p>
<p>当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p>
<p><strong>线程逃逸((对象逃出当前线程)</strong></p>
<p> 这个对象甚至可能被其它线程访问到，例如赋值给类变量或可以在其它线程中访问的实例变量。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>1.同步省略或锁消除(Synchronization Elimination)。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>2.将堆分配转化为栈分配(Stack Allocation)。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>3.分离对象或标量替换(Scalar Replacement)。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>jdk6才开始引入该技术，jdk7开始默认开启逃逸分析。在Java代码运行时，可以通过JVM参数指定是否开启逃逸分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis  //表示开启逃逸分析 (jdk1.8默认开启）</span><br><span class="line">-XX:-DoEscapeAnalysis //表示关闭逃逸分析。</span><br><span class="line">-XX:+EliminateAllocations   //开启标量替换(默认打开)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发总结</title>
    <url>/2022/05/03/01-00-06-Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p>今天总结了一下Java并发编程的知识</p>
<p><a href="https://www.processon.com/view/link/62721614f346fb6712b78ca7">https://www.processon.com/view/link/62721614f346fb6712b78ca7</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS之独占锁ReentrantLock</title>
    <url>/2022/05/04/01-00-07-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8B%E7%8B%AC%E5%8D%A0%E9%94%81ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="深入理解AQS之独占锁ReentrantLock源码分析"><a href="#深入理解AQS之独占锁ReentrantLock源码分析" class="headerlink" title="深入理解AQS之独占锁ReentrantLock源码分析"></a>深入理解AQS之独占锁ReentrantLock源码分析</h2><h3 id="1、AQS原理分析"><a href="#1、AQS原理分析" class="headerlink" title="1、AQS原理分析"></a>1、AQS原理分析</h3><p>java.util.concurrent包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这些行为的抽象就是基于AbstractQueuedSynchronizer（简称AQS）实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。</p>
<p>JDK中提供的大多数的同步器如Lock, Latch, Barrier等，都是基于AQS框架来实现的</p>
<p><strong>AQS具备的特性：</strong></p>
<ul>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平（新来的线程会尝试加锁，加锁失败才会放入等待队列这种非公平，新来的线程发现锁已经被别的线程占用，直接入队，这种是公平锁）</li>
<li>可重入（已经获取锁的线程可以再次获取这个锁）</li>
<li>允许中断 </li>
</ul>
<p>AQS内部维护属性volatile int state （同步状态，共享锁：资源个数；独占锁：可以递增表示重入次数）</p>
<ul>
<li>state表示资源的可用状态</li>
</ul>
<p>State三种访问方式：</p>
<ul>
<li>getState() </li>
<li>setState() </li>
<li>compareAndSetState()</li>
</ul>
<p>AQS定义两种资源共享方式</p>
<ul>
<li>Exclusive-独占，只有一个线程能执行，如ReentrantLock</li>
<li>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</li>
</ul>
<p>AQS定义两种队列</p>
<ul>
<li>同步等待队列（双向链表）： 主要用于维护获取锁失败时入队的线程</li>
<li>条件等待队列（单向链表）： 调用await()的时候会释放锁，然后线程会加入到条件队列，调用signal()唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁</li>
</ul>
<p>AQS 定义了5个队列中节点状态：</p>
<ol>
<li>值为0，初始化状态，表示当前节点在sync队列中，等待着获取锁。</li>
<li>CANCELLED，值为1，表示当前的线程被取消；</li>
<li>SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</li>
<li>CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</li>
<li>PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</li>
</ol>
<p>不同的自定义同步器竞争共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<h3 id="2、同步等待队列（双向链表）"><a href="#2、同步等待队列（双向链表）" class="headerlink" title="2、同步等待队列（双向链表）"></a>2、同步等待队列（双向链表）</h3><p>AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列，是FIFO先进先出线程等待队列，Java中的CLH队列是原CLH队列的一个变种,线程由原自旋机制改为阻塞机制。</p>
<p>AQS 依赖CLH同步队列来完成同步状态的管理：</p>
<ul>
<li><p>当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</p>
</li>
<li><p>当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p>
</li>
<li><p>通过signal或signalAll将条件队列中的节点转移到同步队列。（由条件队列转化为同步队列）</p>
<p> <img src="/2022/05/04/01-00-07-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8B%E7%8B%AC%E5%8D%A0%E9%94%81ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220504225050838.png" alt="image-20220504225050838"></p>
</li>
</ul>
<p><strong>条件等待队列（单向链表）</strong></p>
<p>AQS中条件队列是使用单向列表保存的，用nextWaiter来连接:</p>
<ul>
<li>调用await方法阻塞线程  -&gt;从同步队列转条件队列；</li>
<li>唤醒singnal/singalAll方法 -&gt;从条件队列转同步队列</li>
<li>当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转化到条件队列）</li>
</ul>
<p><strong>Condition接口详解</strong></p>
<p>   <img src="/2022/05/04/01-00-07-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8B%E7%8B%AC%E5%8D%A0%E9%94%81ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220504225058594.png" alt="image-20220504225058594"></p>
<ol>
<li>调用Condition#await方法会释放当前持有的锁，然后阻塞当前线程，同时向Condition队列尾部添加一个节点，所以调用Condition#await方法的时候必须持有锁。</li>
<li>调用Condition#signal方法会将Condition队列的首节点移动到阻塞队列尾部，然后唤醒因调用Condition#await方法而阻塞的线程(唤醒之后这个线程就可以去竞争锁了)，所以调用Condition#signal方法的时候必须持有锁，持有锁的线程唤醒被因调用Condition#await方法而阻塞的线程。</li>
</ol>
<p><strong>等待唤醒机制之await/signal测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(Thread.currentThread().getName() + <span class="string">&quot; 开始处理任务&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                log.debug(Thread.currentThread().getName() + <span class="string">&quot; 结束处理任务&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(Thread.currentThread().getName() + <span class="string">&quot; 开始处理任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                log.debug(Thread.currentThread().getName() + <span class="string">&quot; 结束处理任务&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、ReentrantLock详解"><a href="#3、ReentrantLock详解" class="headerlink" title="3、ReentrantLock详解"></a>3、ReentrantLock详解</h3><p>ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized是一种互斥锁，可以保证线程安全。</p>
<p>相对于 synchronized， ReentrantLock具备如下特点：</p>
<ul>
<li>可中断 </li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁 </li>
<li>支持多个条件变量</li>
<li>与 synchronized 一样，都支持可重入</li>
</ul>
<p><strong>synchronized和ReentrantLock的区别：</strong></p>
<ul>
<li>synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；</li>
<li>synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；</li>
<li>在发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li>
<li>synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（回顾一下sychronized的唤醒策略），而ReentrantLock对于已经在等待的线程是先来的线程先获得锁；</li>
</ul>
<h3 id="4、ReentrantLock源码分析"><a href="#4、ReentrantLock源码分析" class="headerlink" title="4、ReentrantLock源码分析"></a>4、ReentrantLock源码分析</h3><p>跟了下ReentrantLock源码，画了对应的流程图：</p>
<p><a href="https://www.processon.com/view/link/62727a0ef346fb6712b89be4">https://www.processon.com/view/link/62727a0ef346fb6712b89be4</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ReentrantLock</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS之Semaphorer&amp;CountDownLatch&amp;CyclicBarrie</title>
    <url>/2022/05/05/01-00-08-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer-CountDownLatch-CyclicBarrie%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="深入理解AQS之Semaphorer-amp-CountDownLatch-amp-CyclicBarrie详解"><a href="#深入理解AQS之Semaphorer-amp-CountDownLatch-amp-CyclicBarrie详解" class="headerlink" title="深入理解AQS之Semaphorer&amp;CountDownLatch&amp;CyclicBarrie详解"></a>深入理解AQS之Semaphorer&amp;CountDownLatch&amp;CyclicBarrie详解</h2><h3 id="1、Semaphore"><a href="#1、Semaphore" class="headerlink" title="1、Semaphore"></a>1、Semaphore</h3><p><strong>概念</strong></p>
<p>Semaphore，俗称信号量，它是操作系统中PV操作的原语在java的实现，它也是基于AbstractQueuedSynchronizer实现的。</p>
<p>Semaphore的功能非常强大，大小为1的信号量就类似于互斥锁，通过同时只能有一个线程获取信号量实现。大小为n（n&gt;0）的信号量可以实现限流的功能，它可以实现只能有n个线程同时获取信号量。</p>
<p><img src="/2022/05/05/01-00-08-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer-CountDownLatch-CyclicBarrie%E8%AF%A6%E8%A7%A3/image-20220505225529143.png" alt="image-20220505225529143"></p>
<blockquote>
<p>PV操作是操作系统一种实现进程互斥与同步的有效方法。PV操作与信号量（S）的处理相关，P表示通过的意思，V表示释放的意思。用PV操作来管理共享资源时，首先要确保PV操作自身执行的正确性。</p>
<p>P操作的主要动作是：</p>
<p>①S减1；</p>
<p>②若S减1后仍大于或等于0，则进程继续执行；</p>
<p>③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。</p>
<p>V操作的主要动作是：</p>
<p>①S加1； </p>
<p>②若相加后结果大于0，则进程继续执行；</p>
<p>③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。</p>
</blockquote>
<p><strong>Semaphore 常用方法</strong></p>
<p><strong>构造器</strong></p>
<p><img src="/2022/05/05/01-00-08-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer-CountDownLatch-CyclicBarrie%E8%AF%A6%E8%A7%A3/image-20220505225700685.png" alt="image-20220505225700685"></p>
<ul>
<li>permits 表示许可证的数量（资源数）</li>
<li>fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程</li>
</ul>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>acquire() 表示阻塞并获取许可</li>
<li>tryAcquire() 方法在没有许可的情况下会立即返回 false，要获取许可的线程不会阻塞</li>
<li>release() 表示释放许可</li>
<li>int availablePermits()：返回此信号量中当前可用的许可证数。</li>
<li>int getQueueLength()：返回正在等待获取许可证的线程数。</li>
<li>boolean hasQueuedThreads()：是否有线程正在等待获取许可证。</li>
<li>void reducePermit（int reduction）：减少 reduction 个许可证</li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合</li>
</ul>
<p><strong>应用场景</strong></p>
<p>可以用于做流量控制，特别是公用资源有限的应用场景</p>
<p><strong>1、限流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoneTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现一个同时只能处理5个请求的限流器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">50</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 模拟真实方法执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行exec方法&quot;</span> );</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// 模拟请求以10个/s的速度</span></span><br><span class="line">                executor.execute(() -&gt; exec());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2、CountDownLatch"><a href="#2、CountDownLatch" class="headerlink" title="2、CountDownLatch"></a>2、CountDownLatch</h3><p>CountDownLatch（闭锁）是一个同步协助类，允许一个或多个线程等待，直到其他线程完成操作集。</p>
<p>CountDownLatch使用给定的计数值（count）初始化。await方法会阻塞直到当前的计数值（count）由于countDown方法的调用达到0，count为0之后所有等待的线程都会被释放，并且随后对await方法的调用都会立即返回。这是一个一次性现象 —— count不会被重置。如果你需要一个重置count的版本，那么请考虑使用CyclicBarrier。</p>
<p><img src="/2022/05/05/01-00-08-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer-CountDownLatch-CyclicBarrie%E8%AF%A6%E8%A7%A3/image-20220505225924474.png" alt="image-20220505225924474"></p>
<p><strong>CountDownLatch的使用</strong></p>
<p><strong>构造器</strong></p>
<p><img src="/2022/05/05/01-00-08-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer-CountDownLatch-CyclicBarrie%E8%AF%A6%E8%A7%A3/image-20220505225941034.png" alt="image-20220505225941034"></p>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 调用 await() 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">// 和 await() 类似，若等待 timeout 时长后，count 值还是没有变为 0，不再等待，继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">// 会将 count 减 1，直至为 0</span></span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch应用场景</strong></p>
<p>CountDownLatch一般用作多线程倒计时计数器，强制它们等待其他一组（CountDownLatch的初始化决定）任务执行完成。</p>
<p>CountDownLatch的两种使用场景：</p>
<ul>
<li>场景1：让多个线程等待</li>
<li>场景2：让单个线程等待。</li>
</ul>
<p><strong>场景1 让多个线程等待：模拟并发，让并发线程一起执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//准备完毕……运动员都阻塞在这，等待号令</span></span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    String parter = <span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】&quot;</span>;</span><br><span class="line">                    System.out.println(parter + <span class="string">&quot;开始执行……&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);<span class="comment">// 裁判准备发令</span></span><br><span class="line">        countDownLatch.countDown();<span class="comment">// 发令枪：执行发令</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景2 让单个线程等待：多个线程(任务)完成后，进行汇总合并</strong></p>
<p>很多时候，我们的并发任务，存在前后依赖关系；比如数据详情页需要同时调用多个接口获取数据，并发请求获取到数据后、需要进行结果合并；或者多个数据操作完成后，需要数据check；这其实都是：在多个线程(任务)完成后，进行汇总合并的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + ThreadLocalRandom.current().nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; finish task&quot;</span> + index );</span><br><span class="line"></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在阻塞，当计数器==0，就唤醒主线程往下执行。</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程:在所有任务运行完成后，进行结果汇总&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch实现原理</strong></p>
<p>底层基于 AbstractQueuedSynchronizer 实现，CountDownLatch 构造函数中指定的count直接赋给AQS的state；每次countDown()则都是release(1)减1，最后减到0时unpark阻塞线程；这一步是由最后一个执行countdown方法的线程执行的。</p>
<p>而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。</p>
<p><strong>CountDownLatch与Thread.join的区别</strong></p>
<ul>
<li>CountDownLatch的作用就是允许一个或多个线程等待其他线程完成操作，看起来有点类似join() 方法，但其提供了比 join() 更加灵活的API。</li>
<li>CountDownLatch可以手动控制在n个线程里调用n次countDown()方法使计数器进行减一操作，也可以在一个线程里调用n次执行减一操作。</li>
<li>而 join() 的实现原理是不停检查join线程是否存活，如果 join 线程存活则让当前线程永远等待。所以两者之间相对来说还是CountDownLatch使用起来较为灵活。</li>
</ul>
<p><strong>CountDownLatch与CyclicBarrier的区别</strong></p>
<p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p>
<ol>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li>
<li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li>
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再执行。CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</li>
<li>CyclicBarrier 还可以提供一个 barrierAction，合并多线程计算结果。</li>
<li>CyclicBarrier是通过ReentrantLock的”独占锁”和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现</li>
</ol>
<h3 id="3、CyclicBarrier"><a href="#3、CyclicBarrier" class="headerlink" title="3、CyclicBarrier"></a>3、CyclicBarrier</h3><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p>
<p><img src="/2022/05/05/01-00-08-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BSemaphorer-CountDownLatch-CyclicBarrie%E8%AF%A6%E8%A7%A3/image-20220505230110170.png" alt="image-20220505230110170"></p>
<p><strong>CyclicBarrier的使用</strong></p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// parties表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景(该线程的执行时机是在到达屏障之后再执行)</span></span></span><br></pre></td></tr></table></figure>

<p>重要方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//屏障 指定数量的线程全部调用await()方法时，这些线程不再阻塞</span></span><br><span class="line"><span class="comment">// BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//循环  通过reset()方法可以进行重置</span></span></span><br></pre></td></tr></table></figure>

<p><strong>CyclicBarrier应用场景</strong></p>
<ul>
<li><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的场景。</p>
</li>
<li><p>利用CyclicBarrier的计数器能够重置，屏障可以重复使用的特性，可以支持类似“人满发车”的场景</p>
</li>
</ul>
<p><strong>CyclicBarrier与CountDownLatch的区别</strong></p>
<ol>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li>
<li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li>
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再执行。CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</li>
<li>CyclicBarrier 还可以提供一个 barrierAction，合并多线程计算结果。</li>
<li>CyclicBarrier是通过ReentrantLock的”独占锁”和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现</li>
</ol>
<h3 id="4、源码分析"><a href="#4、源码分析" class="headerlink" title="4、源码分析"></a>4、源码分析</h3><p><a href="https://www.processon.com/view/link/6273e75a0791290711f7b81b">CountDownLatch源码分析</a></p>
<p><a href="https://www.processon.com/view/link/627529c21efad40df024ea99">Semaphorer源码分析</a></p>
<p>【待补充】</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS之CyclicBarrier&amp;ReentrantReadWriteLock</title>
    <url>/2022/05/06/01-00-09-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E4%B9%8BCyclicBarrier-ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="CyclicBarrier使用及源码分析"><a href="#CyclicBarrier使用及源码分析" class="headerlink" title="CyclicBarrier使用及源码分析"></a>CyclicBarrier使用及源码分析</h2><h3 id="1、CyclicBarrier的使用"><a href="#1、CyclicBarrier的使用" class="headerlink" title="1、CyclicBarrier的使用"></a>1、CyclicBarrier的使用</h3><p>1)先看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">&quot;开始等待其他线程&quot;</span>);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                        <span class="comment">//TODO 模拟业务处理</span></span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Thread-<span class="number">0</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">4</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">3</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">1</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">2</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">4</span>开始执行</span><br><span class="line">Thread-<span class="number">3</span>开始执行</span><br><span class="line">Thread-<span class="number">0</span>开始执行</span><br><span class="line">Thread-<span class="number">0</span>执行完毕</span><br><span class="line">Thread-<span class="number">4</span>执行完毕</span><br><span class="line">Thread-<span class="number">3</span>执行完毕</span><br></pre></td></tr></table></figure>

<p>由例子可见 CyclicBarrier 可以让一组线程全部同时执行</p>
<blockquote>
<p>字面意思回环栅栏（循环屏障），通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p>
</blockquote>
<p>2)在看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存每个学生的平均成绩</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool= Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cb=<span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>,()-&gt;&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String s:set)&#123;</span><br><span class="line">            result+=map.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;三人平均成绩为:&quot;</span>+(result/<span class="number">3</span>)+<span class="string">&quot;分&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取学生平均成绩</span></span><br><span class="line">                    <span class="keyword">int</span> score=(<span class="keyword">int</span>)(Math.random()*<span class="number">40</span>+<span class="number">60</span>);</span><br><span class="line">                    map.put(Thread.currentThread().getName(), score);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +<span class="string">&quot;同学的平均成绩为：&quot;</span>+score);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//执行完运行await(),等待所有学生平均成绩都计算完毕</span></span><br><span class="line">                        cb.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest2 cb=<span class="keyword">new</span> CyclicBarrierTest2();</span><br><span class="line">        cb.count();</span><br><span class="line">    &#125;</span><br><span class="line">执行结果：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>同学的平均成绩为：<span class="number">93</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>同学的平均成绩为：<span class="number">68</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>同学的平均成绩为：<span class="number">95</span></span><br><span class="line">三人平均成绩为:<span class="number">85</span>分</span><br></pre></td></tr></table></figure>

<p>从结果可以看到，CyclicBarrier可以实现和countDownLatch一样的功能，即等待一组线程执行完之后在执行某个汇总任务。</p>
<p>3)第三个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">5</span>, <span class="number">5</span>, <span class="number">1000</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">                (r) -&gt; <span class="keyword">new</span> Thread(r, counter.addAndGet(<span class="number">1</span>) + <span class="string">&quot; 号 &quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,</span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;裁判：比赛开始~~&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(<span class="keyword">new</span> Runner(cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Runner</span> <span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sleepMills = ThreadLocalRandom.current().nextInt(<span class="number">1000</span>);</span><br><span class="line">                Thread.sleep(sleepMills);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 选手已就位, 准备共用时： &quot;</span> + sleepMills + <span class="string">&quot;ms&quot;</span> + cyclicBarrier.getNumberWaiting());</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">5</span> 号  选手已就位, 准备共用时： 152ms0</span><br><span class="line"><span class="number">3</span> 号  选手已就位, 准备共用时： 542ms1</span><br><span class="line"><span class="number">4</span> 号  选手已就位, 准备共用时： 622ms2</span><br><span class="line"><span class="number">1</span> 号  选手已就位, 准备共用时： 783ms3</span><br><span class="line"><span class="number">2</span> 号  选手已就位, 准备共用时： 798ms4</span><br><span class="line">裁判：比赛开始~~</span><br><span class="line"><span class="number">1</span> 号  选手已就位, 准备共用时： 129ms0</span><br><span class="line"><span class="number">4</span> 号  选手已就位, 准备共用时： 149ms1</span><br><span class="line"><span class="number">5</span> 号  选手已就位, 准备共用时： 152ms2</span><br><span class="line"><span class="number">2</span> 号  选手已就位, 准备共用时： 293ms3</span><br><span class="line"><span class="number">3</span> 号  选手已就位, 准备共用时： 768ms4</span><br><span class="line">裁判：比赛开始~~</span><br></pre></td></tr></table></figure>

<p>从例子看出CyclicBarrier实现了 “人满发车”的场景</p>
<h3 id="3、CyclicBarrier应用场景"><a href="#3、CyclicBarrier应用场景" class="headerlink" title="3、CyclicBarrier应用场景"></a>3、CyclicBarrier应用场景</h3><p>从上面三个例子可以总结出 CyclicBarrier适用的场景</p>
<ul>
<li>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的场景 如例子2所示</li>
<li>利用CyclicBarrier的计数器能够重置，屏障可以重复使用的特性，可以支持类似“人满发车”的场景 如例子3所示</li>
</ul>
<h3 id="4、CyclicBarrier与countDownLatch区别总结"><a href="#4、CyclicBarrier与countDownLatch区别总结" class="headerlink" title="4、CyclicBarrier与countDownLatch区别总结"></a>4、CyclicBarrier与countDownLatch区别总结</h3><ol>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li>
<li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li>
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再执行。CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</li>
<li>CyclicBarrier 还可以提供一个 barrierAction，合并多线程计算结果。</li>
<li>CyclicBarrier是通过ReentrantLock的”独占锁”和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现</li>
</ol>
<h3 id="5、CyclicBarrier源码跟踪"><a href="#5、CyclicBarrier源码跟踪" class="headerlink" title="5、CyclicBarrier源码跟踪"></a>5、CyclicBarrier源码跟踪</h3><p>跟了三个工具类的源码，自己画了流程图，其中CyclicBarrier只跟源码跟了一遍，还需再看几遍</p>
<p><a href="https://www.processon.com/view/link/6273e75a0791290711f7b81b">CountDownLatch源码分析</a></p>
<p><a href="https://www.processon.com/view/link/627529c21efad40df024ea99">Semaphorer源码分析</a></p>
<p><a href="https://www.processon.com/view/link/62755ac61efad40df0253a9f">CyclicBarrier源码分析</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>CyclicBarrier</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS之ReentrantReadWriteLock</title>
    <url>/2022/05/07/01-00-10-AQS%E4%B9%8BReentrantReadWriteLock/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="AQS之ReentrantReadWriteLock"><a href="#AQS之ReentrantReadWriteLock" class="headerlink" title="AQS之ReentrantReadWriteLock"></a>AQS之ReentrantReadWriteLock</h2><h3 id="1、ReentrantReadWriteLock的基本使用"><a href="#1、ReentrantReadWriteLock的基本使用" class="headerlink" title="1、ReentrantReadWriteLock的基本使用"></a>1、ReentrantReadWriteLock的基本使用</h3><p>先看下下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> Lock r = readWriteLock.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock w = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作上读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  r.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="comment">// TODO 业务逻辑</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123; </span><br><span class="line">       r.unlock(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作上写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">  w.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="comment">// TODO 业务逻辑</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123; </span><br><span class="line">       w.unlock(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子演示了读写锁 ReentrantReadWriteLock的使用方式。总结如下：</p>
<p>ReentrantReadWriteLock是可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 Writer 线程，读锁可以由多个 Reader 线程同时持有。也就是说，写锁是独占的，读锁是共享的。</p>
<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：持有读锁的情况下去获取写锁，会导致获取永久等待</li>
<li>重入时支持降级： 持有写锁的情况下可以去获取读锁</li>
</ul>
<h3 id="2、什么是读写锁"><a href="#2、什么是读写锁" class="headerlink" title="2、什么是读写锁"></a>2、什么是读写锁</h3><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁（读多写少）。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源（读读可以并发）；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写操作了（读写，写读，写写互斥）。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p>
<p>针对这种场景，JAVA的并发包提供了读写锁ReentrantReadWriteLock，它内部，维护了一对相关的锁，一个用于只读操作，称为读锁；一个用于写入操作，称为写锁，描述如下：</p>
<p>线程进入读锁的前提条件：</p>
<ul>
<li>没有其他线程的写锁</li>
<li>没有写请求或者有写请求，但调用线程和持有锁的线程是同一个。</li>
</ul>
<p>线程进入写锁的前提条件：</p>
<ul>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
</ul>
<p>而读写锁有以下三个重要的特性：</p>
<ul>
<li>公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>
<li>可重入：读锁和写锁都支持线程重入。以读写线程为例：读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁。</li>
<li>锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁。</li>
</ul>
<h3 id="3、读写锁的使用场景"><a href="#3、读写锁的使用场景" class="headerlink" title="3、读写锁的使用场景"></a>3、读写锁的使用场景</h3><p>看下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个key对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置key对应的value，并返回旧的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注：</span><br><span class="line">上述示例中，Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新 HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而 只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式</span><br></pre></td></tr></table></figure>

<h3 id="4、锁降级"><a href="#4、锁降级" class="headerlink" title="4、锁降级"></a>4、锁降级</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> update = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// TODO 准备数据的流程（略）  </span></span><br><span class="line">                <span class="comment">// 更新业务数据 【0】</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//TODO  使用数据的流程（略）</span></span><br><span class="line">        <span class="comment">// 使用业务数据 【0】</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">分析：</span><br><span class="line">为什么要在写锁释放前加读锁？</span><br><span class="line">原因：</span><br><span class="line">是为了保证可见性业务数据【<span class="number">0</span>】的可见性</span><br><span class="line">如果写锁释放了在加读锁，那么在写锁释放和读锁加锁期间  可能会有很多线程执行，使用业务数据【<span class="number">0</span>】，此时写锁期间对业务数据【<span class="number">0</span>】的很可能还没有生效，其它线程本地存储的还是旧值或者新值还没有刷回主存（业务数据很可能不是valatile修饰的），这样的话就会有可见性问题，从而造成最终结果的不确定性</span><br></pre></td></tr></table></figure>

<p>在来看一个源码注释中的一个锁降级的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>



<p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。锁降级可以帮助我们拿到当前线程修改后的结果而不被其他线程所破坏，防止更新丢失。</p>
<p>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>
<p>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<h3 id="5、RentrantReadWriteLock源码分析"><a href="#5、RentrantReadWriteLock源码分析" class="headerlink" title="5、RentrantReadWriteLock源码分析"></a>5、RentrantReadWriteLock源码分析</h3><p>图没画完，链接后面再补</p>
<h3 id="6、读写锁设计的核心原理"><a href="#6、读写锁设计的核心原理" class="headerlink" title="6、读写锁设计的核心原理"></a>6、读写锁设计的核心原理</h3><ul>
<li><strong>设计的精髓：用一个变量如何维护多种状态</strong></li>
</ul>
<p>在 ReentrantLock 中，使用 Sync ( 实际是 AQS )的 int 类型的 state 来表示同步状态，表示锁被一个线程重复获取的次数。但是，读写锁 ReentrantReadWriteLock 内部维护着一对读写锁，如果要用一个变量维护多种状态，需要采用“按位切割使用”的方式来维护这个变量，将其切分为两部分：高16为表示读，低16为表示写。</p>
<p>分割之后，读写锁是如何迅速确定读锁和写锁的状态呢？通过位运算。假如当前同步状态为S，那么：</p>
<ul>
<li>写状态，等于 S &amp; 0x0000FFFF（将高 16 位全部抹去）。 当写状态加1，等于S+1.</li>
<li>读状态，等于 S &gt;&gt;&gt; 16 (无符号补 0 右移 16 位)。当读状态加1，等于S+（1&lt;&lt;16）,也就是S+0x00010000</li>
</ul>
<p>根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p>
<p><img src="/2022/05/07/01-00-10-AQS%E4%B9%8BReentrantReadWriteLock/image-20220508020238060.png" alt="image-20220508020238060"></p>
<ul>
<li><strong>HoldCounter 计数器</strong></li>
</ul>
<p>锁的内在机制其实就是一个共享锁。一次共享锁的操作就相当于对HoldCounter 计数器的操作。获取共享锁，则该计数器 + 1，释放共享锁，该计数器 - 1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。</p>
<p>通过 ThreadLocalHoldCounter 类，HoldCounter 与线程进行绑定。HoldCounter 是绑定线程的一个计数器，而 ThreadLocalHoldCounter 则是线程绑定的 ThreadLocal。</p>
<p>(1) HoldCounter是用来记录读锁重入数的对象</p>
<p>(2) ThreadLocalHoldCounter是ThreadLocal变量，用来存放不是第一个获取读锁的线程的其他线程的读锁重入数对象</p>
<ul>
<li><strong>写锁的获取</strong></li>
</ul>
<p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</p>
<p>写锁的获取是通过重写AQS中的tryAcquire方法实现的。</p>
<ul>
<li><p><strong>写锁的释放</strong></p>
<p>写锁释放通过重写AQS的tryRelease方法实现</p>
</li>
<li><p><strong>读锁的获取</strong></p>
</li>
</ul>
<p>实现共享式同步组件的同步语义需要通过重写AQS的tryAcquireShared方法和tryReleaseShared方法</p>
<ul>
<li><strong>读锁的释放</strong></li>
</ul>
<p>获取到读锁，执行完临界区后，要记得释放读锁（如果重入多次要释放对应的次数），不然会阻塞其他线程的写操作。      </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>CyclicBarrier</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列之SynchronousQueue</title>
    <url>/2022/05/09/01-00-12-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B9%8BSynchronousQueue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、SynchronousQueue使用"><a href="#一、SynchronousQueue使用" class="headerlink" title="一、SynchronousQueue使用"></a>一、SynchronousQueue使用</h2><p>SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO  模拟消费者取数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;take();&#125;,<span class="string">&quot;consumer1&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 控制第一个消费者先调用</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;take();&#125;,<span class="string">&quot;consumer2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO  模拟生产者写数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;put(<span class="number">1</span>);&#125;,<span class="string">&quot;producer1&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 控制第一个生产者先调用</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;put(<span class="number">5</span>);&#125;,<span class="string">&quot;producer2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer item = blockingQueue.take();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take: &quot;</span> + item);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Integer item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(item);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put: &quot;</span> + item);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SynchronousQueue特点</strong></p>
<p>SynchronousQueue 最大的不同之处在于，它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。</p>
<p>需要注意的是，SynchronousQueue 的容量不是 1 而是 0，因为 SynchronousQueue 不需要去持有元素，它所做的就是直接传递（direct handoff）。由于每当需要传递的时候，SynchronousQueue 会把元素直接从生产者传给消费者，在此期间并不需要做存储，所以如果运用得当，它的效率是很高的。</p>
<p><strong>应用场景</strong></p>
<p>SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务。</p>
<p>SynchronousQueue的一个使用场景是在线程池里。如果我们不确定来自生产者请求数量，但是这些请求需要很快的处理掉，那么配合SynchronousQueue为每个生产者请求分配一个消费线程是处理效率最高的办法。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>
<h2 id="二、PriorityBlockingQueue使用"><a href="#二、PriorityBlockingQueue使用" class="headerlink" title="二、PriorityBlockingQueue使用"></a>二、PriorityBlockingQueue使用</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建优先级阻塞队列  Comparator为null,自然排序</span></span><br><span class="line">        PriorityBlockingQueue&lt;Integer&gt; queue=<span class="keyword">new</span> PriorityBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//         自定义Comparator</span></span><br><span class="line"><span class="comment">//        PriorityBlockingQueue queue=new PriorityBlockingQueue&lt;Integer&gt;(</span></span><br><span class="line"><span class="comment">//                5, new Comparator&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Integer o1, Integer o2) &#123;</span></span><br><span class="line"><span class="comment">//                return o2-o1;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(<span class="string">&quot;put:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = random.nextInt(<span class="number">100</span>);</span><br><span class="line">            System.out.print(j+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            queue.put(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\ntake:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(queue.take()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PriorityBlockingQueue特点</strong></p>
<p>PriorityBlockingQueue是一个无界的基于数组的优先级阻塞队列，数组的默认长度是11，虽然指定了数组的长度，但是可以无限的扩充，直到资源消耗尽为止，每次出队都返回优先级别最高的或者最低的元素。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。</p>
<p>优先级队列PriorityQueue： 队列中每个元素都有一个优先级，出队的时候，优先级最高的先出。</p>
<p><strong>应用场景</strong></p>
<p>电商抢购活动，会员级别高的用户优先抢购到商品</p>
<p>银行办理业务，vip客户插队</p>
<p><strong>PriorityBlockingQueue核心</strong></p>
<p><strong>如何构造优先级队列</strong></p>
<ul>
<li><p>使用普通线性数组(无序)来表示优先级队列</p>
<ul>
<li>执行插入操作时，直接将元素插入到数组末端，需要的成本为O(1),</li>
<li>获取优先级最高元素，我们需要遍历整个线性队列，匹配出优先级最高元素，需要的成本为o(n)</li>
<li>删除优先级最高元素，我们需要两个步骤，第一找出优先级最高元素，第二步删除优先级最高元素，然后将后面的元素依次迁移，填补空缺，需要的成本为O(n)+O(n)=O(n)</li>
</ul>
</li>
<li><p>使用一个按顺序排列的有序向量实现优先级队列</p>
<ul>
<li>获取优先级最高元素，O(1)</li>
<li>删除优先级最高元素，O(1)</li>
<li>插入一个元素，需要两个步骤，第一步我们需要找出要插的位置，这里我们可以使用二分查找，成本为O(logn)，第二步是插入元素之后，将其所有后继进行后移操作，成本为O(n)，所有总成本为O(logn)+O(n)=O(n)</li>
</ul>
<p><strong>二叉堆</strong></p>
<p>完全二叉树：除了最后一行，其他行都满的二叉树，而且最后一行所有叶子节点都从左向右开始排序。</p>
<p>二叉堆：完全二叉树的基础上，加以一定的条件约束的一种特殊的二叉树。根据约束条件的不同，二叉堆又可以分为两个类型：</p>
<p>大顶堆和小顶堆。</p>
<ul>
<li>大顶堆（最大堆）：父结点的键值总是大于或等于任何一个子节点的键值；</li>
<li>小顶堆（最小堆）：父结点的键值总是小于或等于任何一个子节点的键值。</li>
</ul>
</li>
</ul>
<h2 id="三、DelayQueue使用"><a href="#三、DelayQueue使用" class="headerlink" title="三、DelayQueue使用"></a>三、DelayQueue使用</h2><p><strong>DelayQueue的数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于保证队列操作的线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 优先级队列,存储元素，用于保证延迟低的优先执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"><span class="comment">// 用于标记当前是否有线程在排队（仅用于取元素时） leader 指向的是第一个从队列获取元素阻塞的线程</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 条件，用于表示现在是否有可取的元素   当新元素到达，或新线程可能需要成为leader时被通知</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队put方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            <span class="comment">// 若入队的元素位于队列头部，说明当前元素延迟最小</span></span><br><span class="line">            <span class="comment">// 将 leader 置空</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// available条件队列转同步队列,准备唤醒阻塞在available上的线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁，真正唤醒阻塞的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队take方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();<span class="comment">// 取出堆顶元素( 最早过期的元素，但是不弹出对象)   </span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)<span class="comment">// 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待</span></span><br><span class="line">                available.await();<span class="comment">//当前线程无限期等待，直到被唤醒，并且释放锁。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);<span class="comment">// 堆顶元素的到期时间             </span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)<span class="comment">// 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果delay大于0 ，则下面要阻塞了</span></span><br><span class="line">                <span class="comment">// 将first置为空方便gc</span></span><br><span class="line">                first = <span class="keyword">null</span>; </span><br><span class="line">                <span class="comment">// 如果有线程争抢的Leader线程，则进行无限期等待。 判断是有限期等待还是无限期等待</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果leader为null，把当前线程赋值给它</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待剩余等待时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// available条件队列转同步队列,准备唤醒阻塞在available上的线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        <span class="comment">// 解锁，真正唤醒阻塞的线程</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li>当获取元素时，先获取到锁对象。</li>
<li>获取最早过期的元素，但是并不从队列中弹出元素。</li>
<li>最早过期元素是否为空，如果为空则直接让当前线程无限期等待状态，并且让出当前锁对象。</li>
<li>如果最早过期的元素不为空</li>
<li>获取最早过期元素的剩余过期时间，如果已经过期则直接返回当前元素</li>
<li>如果没有过期，也就是说剩余时间还存在，则先获取Leader对象，如果Leader已经有线程在处理，则当前线程进行无限期等待，如果Leader为空，则首先将Leader设置为当前线程，并且让当前线程等待剩余时间。</li>
<li>最后将Leader线程设置为空</li>
<li>如果Leader已经为空，并且队列有内容则唤醒一个等待的队列。</li>
</ol>
<h2 id="四、如何选择适合的阻塞队列"><a href="#四、如何选择适合的阻塞队列" class="headerlink" title="四、如何选择适合的阻塞队列"></a>四、如何选择适合的阻塞队列</h2><p><strong>线程池对于阻塞队列的选择</strong></p>
<p>线程池有很多种，不同种类的线程池会根据自己的特点，来选择适合自己的阻塞队列。</p>
<ul>
<li>FixedThreadPool（SingleThreadExecutor 同理）选取的是 LinkedBlockingQueue</li>
<li>CachedThreadPool 选取的是 SynchronousQueue</li>
<li>ScheduledThreadPool（SingleThreadScheduledExecutor同理）选取的是延迟队列</li>
</ul>
<p><strong>选择策略</strong></p>
<p>通常我们可以从以下 5 个角度考虑，来选择合适的阻塞队列：</p>
<p><strong>功能</strong></p>
<p>第 1 个需要考虑的就是功能层面，比如是否需要阻塞队列帮我们排序，如优先级排序、延迟执行等。如果有这个需要，我们就必须选择类似于 PriorityBlockingQueue 之类的有排序能力的阻塞队列。</p>
<p><strong>容量</strong></p>
<p>第 2 个需要考虑的是容量，或者说是否有存储的要求，还是只需要“直接传递”。在考虑这一点的时候，我们知道前面介绍的那几种阻塞队列，有的是容量固定的，如 ArrayBlockingQueue；有的默认是容量无限的，如 LinkedBlockingQueue；而有的里面没有任何容量，如 SynchronousQueue；而对于 DelayQueue 而言，它的容量固定就是 Integer.MAX_VALUE。所以不同阻塞队列的容量是千差万别的，我们需要根据任务数量来推算出合适的容量，从而去选取合适的 BlockingQueue。</p>
<p><strong>能否扩容</strong></p>
<p>第 3 个需要考虑的是能否扩容。因为有时我们并不能在初始的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择 ArrayBlockingQueue ，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue 即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。所以我们可以根据是否需要扩容来选取合适的队列。</p>
<p><strong>内存结构</strong></p>
<p>第 4 个需要考虑的点就是内存结构。我们分析过 ArrayBlockingQueue 的源码，看到了它的内部结构是“数组”的形式。和它不同的是，LinkedBlockingQueue 的内部是用链表实现的，所以这里就需要我们考虑到，ArrayBlockingQueue 没有链表所需要的“节点”，空间利用率更高。所以如果我们对性能有要求可以从内存的结构角度去考虑这个问题。</p>
<p><strong>性能</strong></p>
<p>第 5 点就是从性能的角度去考虑。比如 LinkedBlockingQueue 由于拥有两把锁，它的操作粒度更细，在并发程度高的时候，相对于只有一把锁的 ArrayBlockingQueue 性能会更好。另外，SynchronousQueue 性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储的过程。如果我们的场景需要直接传递的话，可以优先考虑 SynchronousQueue。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>BlockingQueue</tag>
        <tag>阻塞队列</tag>
        <tag>SynchronousQueue</tag>
        <tag>PriorityBlockingQueue</tag>
        <tag>DelayQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS总结</title>
    <url>/2022/05/10/01-00-13-AQS%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="AQS使用总结"><a href="#AQS使用总结" class="headerlink" title="AQS使用总结"></a>AQS使用总结</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之ForkJoin</title>
    <url>/2022/05/10/01-00-14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BForkJoin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="并发编程之ForkJoin"><a href="#并发编程之ForkJoin" class="headerlink" title="并发编程之ForkJoin"></a>并发编程之ForkJoin</h2><h3 id="1、任务类型"><a href="#1、任务类型" class="headerlink" title="1、任务类型"></a>1、任务类型</h3><p>CPU只做两件事：取指令和执行指令。</p>
<ul>
<li><p><strong>CPU密集型任务</strong></p>
<ul>
<li>CPU密集型任务也叫计算密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。对于这样的任务最佳的线程数为 CPU 核心数的 1~2 倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍【即逻辑处理器的个数】以上，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</li>
</ul>
</li>
<li><p><strong>IO密集型任务</strong></p>
<ul>
<li><p>很少用到CPU</p>
<p>IO密集型任务，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在工作队列中等待的任务就会减少，可以更好地利用资源。</p>
</li>
<li><p>线程数计算方法</p>
<p>《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法，适用于io密集型：</p>
<p>比如CPU 8核 ，模拟出超线程 16逻辑核 ，执行一个任务（比如从数据库查询数据需要1.5s：查数据 io操作用时1s；cpu执行指令用了0.5s ） 则计算如下：</p>
<p>16 * （1+ 1/0.5） = 48</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程数 = CPU 核心数 *（<span class="number">1</span>+平均等待时间/平均工作时间）               【仅作参考，作为初期预估方案，具体还要以压测为准】</span><br></pre></td></tr></table></figure>

<p>通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。</p>
<p>太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2、分治算法"><a href="#2、分治算法" class="headerlink" title="2、分治算法"></a>2、分治算法</h3><p>如何充分利用多核CPU的性能，计算一个很大数组中所有整数的和？</p>
<ul>
<li><p>单线程相加，一个for循环搞定</p>
</li>
<li><p>利用多线程进行任务拆分，比如借助线程池进行分段相加，最后再把每个段的结果相加。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 多线程计算1亿个整数的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumMultiThreads</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拆分的粒度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr, ExecutorService executor)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numThreads = arr.length / NUM &gt; <span class="number">0</span> ? arr.length / NUM : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = arr.length / numThreads;</span><br><span class="line">        <span class="comment">//任务分解</span></span><br><span class="line">        SumTask[] tasks = <span class="keyword">new</span> SumTask[numThreads];</span><br><span class="line">        Future&lt;Long&gt;[] sums = <span class="keyword">new</span> Future[numThreads];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">            tasks[i] = <span class="keyword">new</span> SumTask(arr, (i * NUM),</span><br><span class="line">                    ((i + <span class="number">1</span>) * NUM));</span><br><span class="line">            sums[i] = executor.submit(tasks[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">            result += sums[i].get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 准备数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="number">100000000</span>);</span><br><span class="line">        <span class="comment">//获取线程数</span></span><br><span class="line">        <span class="keyword">int</span> numThreads = arr.length / NUM &gt; <span class="number">0</span> ? arr.length / NUM : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The array length is: %d\n&quot;</span>, arr.length);</span><br><span class="line">        <span class="comment">// 构建线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(numThreads);</span><br><span class="line">        <span class="comment">// 线程池 预热</span></span><br><span class="line">        <span class="comment">//((ThreadPoolExecutor)executor).prestartAllCoreThreads();</span></span><br><span class="line"></span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        <span class="comment">// 数组求和</span></span><br><span class="line">        <span class="keyword">long</span> result = sum(arr, executor);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间：&quot;</span>+Duration.between(now,Instant.now()).toMillis());</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The result is: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归实现分治算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumRecursiveMT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveSumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//拆分的粒度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQUENTIAL_CUTOFF = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> lo;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">int</span>[] arr; <span class="comment">// arguments</span></span><br><span class="line">        ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">        RecursiveSumTask(ExecutorService executorService, <span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">            <span class="keyword">this</span>.arr = a;</span><br><span class="line">            <span class="keyword">this</span>.lo = l;</span><br><span class="line">            <span class="keyword">this</span>.hi = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;%s range [%d-%d] begin to compute %n&quot;</span>,</span><br><span class="line">                    Thread.currentThread().getName(), lo, hi);</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//最小拆分的阈值</span></span><br><span class="line">            <span class="keyword">if</span> (hi - lo &lt;= SEQUENTIAL_CUTOFF) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++) &#123;</span><br><span class="line">                    result += arr[i];</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                System.out.format(&quot;%s range [%d-%d] begin to finished %n&quot;,</span></span><br><span class="line"><span class="comment">//                        Thread.currentThread().getName(), lo, hi);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RecursiveSumTask left = <span class="keyword">new</span> RecursiveSumTask(</span><br><span class="line">                        executorService, arr, lo, (hi + lo) / <span class="number">2</span>);</span><br><span class="line">                RecursiveSumTask right = <span class="keyword">new</span> RecursiveSumTask(</span><br><span class="line">                        executorService, arr, (hi + lo) / <span class="number">2</span>, hi);</span><br><span class="line">                Future&lt;Long&gt; lr = executorService.submit(left);</span><br><span class="line">                Future&lt;Long&gt; rr = executorService.submit(right);</span><br><span class="line"></span><br><span class="line">                result = lr.get() + rr.get();</span><br><span class="line"><span class="comment">//                System.out.format(&quot;%s range [%d-%d] finished to compute %n&quot;,</span></span><br><span class="line"><span class="comment">//                        Thread.currentThread().getName(), lo, hi);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思考： 用 Executors.newFixedThreadPool可以吗？   定长线程的饥饿</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">12</span>);</span><br><span class="line">        <span class="comment">//ExecutorService executorService = Executors.newCachedThreadPool();</span></span><br><span class="line">         <span class="comment">//递归任务 求和</span></span><br><span class="line">        RecursiveSumTask task = <span class="keyword">new</span> RecursiveSumTask(executorService, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">long</span> result = executorService.submit(task).get();</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//准备数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="number">100000000</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;The array length is: %d\n&quot;</span>, arr.length);</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        <span class="comment">//数组求和</span></span><br><span class="line">        <span class="keyword">long</span> result = sum(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间：&quot;</span>+ Duration.between(now,Instant.now()).toMillis());</span><br><span class="line">        System.out.printf(<span class="string">&quot;The result is: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分治算法总结</strong></p>
<p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>
<p>分治算法的步骤如下：</p>
<ol>
<li>分解：将要解决的问题划分成若干规模较小的同类问题；</li>
<li>求解：当子问题划分得足够小时，用较简单的方法解决；</li>
<li>合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。</li>
</ol>
<h3 id="3、Fork-Join框架"><a href="#3、Fork-Join框架" class="headerlink" title="3、Fork/Join框架"></a>3、Fork/Join框架</h3><p><strong>介绍</strong></p>
<p>传统线程池ThreadPoolExecutor有两个明显的缺点：一是无法对大任务进行拆分，对于某个任务只能由单线程执行；二是工作线程从队列中获取任务时存在竞争情况。这两个缺点都会影响任务的执行效率。为了解决传统线程池的缺陷，Java7中引入Fork/Join框架，并在Java8中得到广泛应用。Fork/Join框架的核心是ForkJoinPool类，它是对AbstractExecutorService类的扩展。ForkJoinPool允许其他线程向它提交任务，并根据设定将这些任务拆分为粒度更细的子任务，这些子任务将由ForkJoinPool内部的工作线程来并行执行，并且工作线程之间可以窃取彼此之间的任务。</p>
<p>ForkJoinPool最适合计算密集型任务，而且最好是非阻塞任务。ForkJoinPool是ThreadPoolExecutor线程池的一种补充，是对计算密集型场景的加强。</p>
<p>根据经验和实验，任务总数、单任务执行耗时以及并行数都会影响到Fork/Join的性能。所以，当你使用Fork/Join框架时，你需要谨慎评估这三个指标，最好能通过模拟对比评估，不要凭感觉冒然在生产环境使用。</p>
<p><strong>Fork/Join的使用</strong></p>
<p>Fork/Join 计算框架主要包含两部分，一部分是分治任务的线程池 ForkJoinPool，另一部分是分治任务 ForkJoinTask</p>
<p><strong>ForkJoinPool</strong></p>
<p>ForkJoinPool 是用于执行 ForkJoinTask 任务的执行池，不再是传统执行池 Worker+Queue 的组合式，而是维护了一个队列数组 WorkQueue（WorkQueue[]），这样在提交任务和线程任务的时候大幅度减少碰撞。</p>
<p><strong>按类型提交不同任务</strong></p>
<p>任务提交是ForkJoinPool的核心能力之一，提交任务有三种方式：</p>
<table>
<thead>
<tr>
<th></th>
<th>返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>提交异步执行</td>
<td>void</td>
<td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">execute</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a> task)<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">execute</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">Runnable tas</a>k)</td>
</tr>
<tr>
<td>等待并获取结果</td>
<td>T</td>
<td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">invoke</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a> task)</td>
</tr>
<tr>
<td>提交执行获取Future结果</td>
<td>ForkJoinTask</td>
<td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">submit</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a> task)<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">submit</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">Callable </a>task)<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">submit</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">Runnable tas</a>k)<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">submit</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">Runnable tas</a>k, T resul<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">t)</a></td>
</tr>
</tbody></table>
<ul>
<li>execute类型的方法在提交任务后，不会返回结果。ForkJoinPool不仅允许提交ForkJoinTask类型任务，还允许提交Runnable任务</li>
</ul>
<p>执行Runnable类型任务时，将会转换为ForkJoinTask类型。由于任务是不可切分的，所以这类任务无法获得任务拆分这方面的效益，不过仍然可以获得任务窃取带来的好处和性能提升。</p>
<ul>
<li>invoke方法接受ForkJoinTask类型的任务，并在任务执行结束后，返回泛型结果。如果提交的任务是null，将抛出空指针异常。</li>
<li>submit方法支持三种类型的任务提交：ForkJoinTask类型、Callable类型和Runnable类型。在提交任务后，将返回ForkJoinTask类型的结果。如果提交的任务是null，将抛出空指针异常，并且当任务不能按计划执行的话，将抛出任务拒绝异常。</li>
</ul>
<p><strong>ForkJoinTask核心api</strong></p>
<p>ForkJoinTask是ForkJoinPool的核心之一，它是任务的实际载体，定义了任务执行时的具体逻辑和拆分逻辑。ForkJoinTask继承了Future接口，所以也可以将其看作是轻量级的Future。</p>
<p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，承载着主要的任务协调作用，一个用于任务提交，一个用于结果获取。</p>
<ul>
<li><strong>fork()——提交任务</strong></li>
</ul>
<p>fork()方法用于向当前任务所运行的线程池中提交任务。如果当前线程是ForkJoinWorkerThread类型，将会放入该线程的工作队列，否则放入common线程池的工作队列中。</p>
<ul>
<li><strong>join()——获取任务执行结果</strong></li>
</ul>
<p>join()方法用于获取任务的执行结果。调用join()时，将阻塞当前线程直到对应的子任务完成运行并返回结果。</p>
<p>通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下三个子类：</p>
<ul>
<li><strong>RecursiveAction</strong>：用于递归执行但不需要返回结果的任务。</li>
<li><strong>RecursiveTask</strong> ：用于递归执行需要返回结果的任务。</li>
<li>CountedCompleter ：在任务完成执行后会触发执行一个自定义的钩子函数</li>
</ul>
<p><strong>ForkJoinTask使用限制</strong></p>
<p>ForkJoinTask最适合用于纯粹的计算任务，也就是纯函数计算，计算过程中的对象都是独立的，对外部没有依赖。提交到ForkJoinPool中的任务应避免执行阻塞I/O。</p>
<p><strong>ForkJoinPool 的工作原理</strong></p>
<p><img src="/2022/05/10/01-00-14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BForkJoin/image-20220511002538588.png" alt="image-20220511002538588"></p>
<p><strong>ForkJoinPool 的核心</strong></p>
<ul>
<li><strong>工作窃取</strong></li>
<li><strong>工作队列WorkQueue</strong></li>
<li><strong>ForkJoinWorkThread</strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ForkJoin</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor使用及源码分析</title>
    <url>/2022/05/12/01-00-16-ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Executor线程池原理与源码解读"><a href="#Executor线程池原理与源码解读" class="headerlink" title="Executor线程池原理与源码解读"></a>Executor线程池原理与源码解读</h2><h3 id="1、线程池的使用"><a href="#1、线程池的使用" class="headerlink" title="1、线程池的使用"></a>1、线程池的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            threadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i m task ：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 通过submit()方法提交任务</span><br></pre></td></tr></table></figure>

<h3 id="2、线程的状态"><a href="#2、线程的状态" class="headerlink" title="2、线程的状态"></a>2、线程的状态</h3><blockquote>
<p><strong>NEW</strong>,新建</p>
<p><strong>RUNNABLE</strong>,运行</p>
<p><strong>BLOCKED</strong>,阻塞</p>
<p><strong>WAITING</strong>,等待</p>
<p><strong>TIMED_WAITING</strong>,超时等待</p>
<p><strong>TERMINATED</strong>，终结</p>
</blockquote>
<p>状态切换如下图所示：</p>
<p><img src="/2022/05/12/01-00-16-ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220512225300532.png" alt="image-20220512225300532"></p>
<p><code>两种线程内核态线程KLT VS 用户态线程ULT</code></p>
<p><img src="/2022/05/12/01-00-16-ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220512225401430.png" alt="image-20220512225401430"></p>
<p><code><strong>协程</strong></code></p>
<p>协程    (纤程，用户级线程)，目的是为了追求最大力度的发挥硬件性能和提升软件的速度，协程基本原理是:在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来的栈信息并继续执行(整个过程线程不需要上下文切换)。</p>
<p>只有一个线程，但是虚拟出来了很多线程栈空间，是在一个cpu的一个核上执行。不需要上下文切换，也不需要内核态和用户态的切换，不会去调用操作系统库函数创建操作系统线程</p>
<p>Java原生不支持协程，在纯java代码里需要使用协程的话需要引入第三方包,如：quasar</p>
<h3 id="3、线程池的状态"><a href="#3、线程池的状态" class="headerlink" title="3、线程池的状态"></a>3、线程池的状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为111</span></span><br><span class="line">SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为000</span></span><br><span class="line">STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为001</span></span><br><span class="line">TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为010</span></span><br><span class="line">TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为011</span></span><br></pre></td></tr></table></figure>

<p>1、RUNNING</p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 </p>
<p>(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！</p>
<p>2、 SHUTDOWN</p>
<p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </p>
<p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP</p>
<p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </p>
<p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING</p>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </p>
<p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED</p>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 </p>
<p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>workerCount为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
<h3 id="4、线程池的重要属性"><a href="#4、线程池的重要属性" class="headerlink" title="4、线程池的重要属性"></a>4、线程池的重要属性</h3><p><code>线程池的状态转换</code></p>
<p><img src="/2022/05/12/01-00-16-ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220512225538077.png" alt="image-20220512225538077"></p>
<p><code>线程池的重要方法</code></p>
<p>1，<strong>execute</strong>（Runnable command）：履行Ruannable类型的任务,</p>
<p>2，<strong>submit</strong>（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future对象</p>
<p>3，<strong>shutdown</strong>（）：在完成已提交的任务后封闭办事，不再接管新任务,</p>
<p>4，<strong>shutdownNow</strong>（）：停止所有正在履行的任务并封闭办事。</p>
<p>5，<strong>isTerminated</strong>（）：测试是否所有任务都履行完毕了。</p>
<p>6，<strong>isShutdown</strong>（）：测试是否该ExecutorService已被关闭。</p>
<p><code>线程池的重要属性</code></p>
<p><strong>参数解释</strong></p>
<p><strong>corePoolSize</strong></p>
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<p><strong>maximumPoolSize【核心线程数+非核心线程数】</strong></p>
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；</p>
<p><strong>keepAliveTime</strong></p>
<p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p>
<p><strong>unit</strong></p>
<p>keepAliveTime的单位；</p>
<p><strong>workQueue</strong></p>
<p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p>
<ul>
<li>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</li>
<li>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</li>
<li>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</li>
</ul>
<p><strong>threadFactory</strong></p>
<p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</p>
<p><strong>handler</strong></p>
<p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<ul>
<li>1、AbortPolicy：直接抛出异常，默认策略；</li>
<li>2、CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>4、DiscardPolicy：直接丢弃任务；</li>
</ul>
<p>上面的4种策略都是ThreadPoolExecutor的内部类。</p>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<p>拒绝策略也可以自己制定，比如说任务是不能丢弃的，那么可以将任务放到redis中间间，然后在拒绝策略里面实现监控线程池的队列中任务个数，比如少于50%就从redis中取任务放入队列中</p>
<p><img src="/2022/05/12/01-00-16-ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/thread_pool.jpg" alt="thread_pool"></p>
<h3 id="5、线程池的执行流程"><a href="#5、线程池的执行流程" class="headerlink" title="5、线程池的执行流程"></a>5、线程池的执行流程</h3><p><img src="/2022/05/12/01-00-16-ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220512225937829.png" alt="image-20220512225937829"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</span><br><span class="line">如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；</span><br><span class="line">如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</span><br><span class="line">如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</span><br><span class="line">如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</span><br><span class="line">这里要注意一下addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在workerCountOf(recheck) == <span class="number">0</span>时执行addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</span><br></pre></td></tr></table></figure>

<h3 id="6、线程池的源码跟踪"><a href="#6、线程池的源码跟踪" class="headerlink" title="6、线程池的源码跟踪"></a>6、线程池的源码跟踪</h3><p><a href="https://www.processon.com/view/link/627d2169e0b34d5ac4095b31">threadPool源码跟踪</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ThreadPoolExecutor</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发总结</title>
    <url>/2022/05/13/01-00-17-java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://www.processon.com/view/link/62721614f346fb6712b78ca7">并发篇-思维导图-持续补充中</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>线程池</tag>
        <tag>并发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码解析</title>
    <url>/2022/05/16/01-00-19-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h2><h3 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h3><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下：<br><img src="/2022/05/16/01-00-19-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/5d5fc7cc0001ec3211040928.png" alt="图片描述">图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树。</p>
<p><code>类注释</code></p>
<p>从 HashMap 的类注释中，我们可以得到如下信息：</p>
<ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li>
<li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li>
</ul>
<p><code>常见属性</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始容量为 16</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//最大容量</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//负载因子默认值</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//桶上的链表长度大于等于8时，链表转化成红黑树</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//桶上的红黑树大小小于等于6时，红黑树转化成链表</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当数组容量大于 64 时，链表才会转化成红黑树</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//存放数据的数组</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 扩容的门槛，有两种情况</span></span><br><span class="line"> <span class="comment">// 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。</span></span><br><span class="line"> <span class="comment">// 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//链表的节点</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//红黑树的节点</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、新增"><a href="#2、新增" class="headerlink" title="2、新增"></a>2、新增</h3><p>新增 key，value 大概的步骤如下：</p>
<ol>
<li>空数组有无初始化，没有的话初始化；</li>
<li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li>
<li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li>
<li>如果是链表，递归循环，把新元素追加到队尾；</li>
<li>如果是红黑树，调用红黑树新增的方法；</li>
<li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li>
<li>判断是否需要扩容，需要扩容进行扩容，结束。</li>
</ol>
<p>我们来画一张示意图来描述下：<br><img src="/2022/05/16/01-00-19-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/5d5fc7e200016af809121188.jpg" alt="图片描述"></p>
<p>代码细节如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入参 hash：通过 hash 算法计算出来的值。</span></span><br><span class="line"><span class="comment">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果数组为空，使用 resize 方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 当前节点的临时变量</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 是个链表，把新节点放到链表的尾端</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// e = p.next 表示从头开始，遍历链表</span></span><br><span class="line">                <span class="comment">// p.next == null 表明 p 是链表的尾节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把新节点放到链表的尾部 </span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 当链表的长度大于等于 8 时，链表转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明新节点的新增位置已经找到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 HashMap 的数据结构发生了变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>链表的新增</code></p>
<p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p>
<p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，转化成红黑树的过程也比较简单，</p>
<p>可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：</p>
<p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p>
<p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br></pre></td></tr></table></figure>

<p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p>
<p><code>红黑树新增节点过程</code></p>
<ol>
<li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p>
<p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p>
<p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p>
</li>
<li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p>
</li>
<li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p>
</li>
<li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p>
</li>
<li><p>进行着色和旋转，结束。</p>
</li>
</ol>
<p>具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入参 h：key 的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                  <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">//生成新的节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">            <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line">            <span class="comment">//旋转： 父亲是红色，叔叔是黑色时，进行旋转</span></span><br><span class="line">            <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">            <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红黑树的新增，要求大家对红黑树的数据结构有一定的了解。我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
<li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li>
</ol>
<h3 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h3><p>HashMap 的查找主要分为以下三步：</p>
<ul>
<li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li>
<li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li>
<li>分别走链表和红黑树不同类型的查找方法。</li>
</ul>
<p>链表查找的关键代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点</span></span><br><span class="line">    <span class="comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 否则，把当前节点的下一个节点拿出来继续寻找</span></span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>红黑树查找的代码很多，大概思路如下：</p>
<ol>
<li>从根节点递归查找；</li>
<li>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大的特性进行判断；</li>
<li>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</li>
<li>一直自旋到定位到节点位置为止。</li>
</ol>
<p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p>
<h3 id="4、JDK1-7HashMap和ConcurrentHashMap"><a href="#4、JDK1-7HashMap和ConcurrentHashMap" class="headerlink" title="4、JDK1.7HashMap和ConcurrentHashMap"></a>4、JDK1.7HashMap和ConcurrentHashMap</h3><p>HashMap:</p>
<p>1、hashmap是怎么出现并发安全问题的</p>
<p>2、hashmap快速失败，怎么迭代删除</p>
<p>ConcurrentHashMap：</p>
<p>1、初始大小、默认加载因子、数据结构</p>
<p>2、ConcurrentHashMap 的数据结构如下：    </p>
<p>3、ConcurrentHashMap构造方法逻辑：</p>
<p>​    （1）、确定Segment数组长度，2的幂次方</p>
<p>​    （2）、确定每个segmentHahsEntyp数组的长度，2的幂次方【？？？待确定】</p>
<p>​    （3）、ConcurrentHashMap扩容是局部扩容，Segment数组不会扩容（初始构造的时候就已经确定了），是每个Segment下的HashEntry[]数组扩容</p>
<p><img src="/2022/05/16/01-00-19-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220528170535373.png" alt="image-20220528170535373"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized锁升级总结</title>
    <url>/2022/05/17/01-00-20-synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="synchronized总结"><a href="#synchronized总结" class="headerlink" title="synchronized总结"></a>synchronized总结</h2><p>synchronized是面试高频考点，今天又重点回顾了下synchronized升级流程，特此记录下来</p>
<h3 id="1、synchronized锁升级过程"><a href="#1、synchronized锁升级过程" class="headerlink" title="1、synchronized锁升级过程"></a>1、synchronized锁升级过程</h3>

	<div class="row">
    <embed src="synchronized.png" width="100%" height="550" type="application/pdf">
	</div>




<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）、初始锁状态有两种，无锁：禁用偏向锁或不满足延迟偏向条件；偏向锁：开启了偏向锁</span><br><span class="line">（<span class="number">2</span>）、开启了偏向锁，jvm会延迟偏向（4s），之后创建的对象初始状态就是匿名偏向状态，即无偏向线程的偏向锁（threadId=<span class="number">0</span>）</span><br><span class="line">（<span class="number">3</span>）、当一个线程thread1访问同步代码块，会先通过cas修改mark word的ThreadId字段从<span class="number">0</span>改为当前线程地址，cas修改成功，锁状态就由匿名偏向状态改为偏向锁锁定  状态。后续这个线程再多次访问这个锁对象，就不在有加锁/解锁的开销了。注：偏向锁解锁还是偏向锁</span><br><span class="line">（<span class="number">4</span>）、此时如果有另一个线程thread2与thread1竞争锁。分几种情况：<span class="number">1</span>&gt;当前锁对象已被锁定，偏向锁撤销，升级为轻量级锁：当前对象已锁定（被thread1锁定），此时进行偏向锁撤销，当前锁对象升级为轻量级锁，轻量级锁解锁之后会变为无锁；<span class="number">2</span>&gt;当前锁对象未被锁定，偏向锁撤销，变为无锁：比如一个对象初始状态为匿名偏向锁状态，调用了对象的hashCode()方法，则会发生偏向锁撤销，变为无锁状态（原因偏向锁状态无法存储hashCode）。<span class="number">3</span>&gt;如果当前对象锁定，且在同步代码块中调用hashcode或者wait方法，偏向锁撤销，变为重量级锁：</span><br><span class="line">注：</span><br><span class="line">无锁/偏向锁可以升级为轻量级锁；轻量级锁也可以升级为重量级锁；无锁也可以升级为重量级锁（无锁状态的对象多个线程cas修改mark work竞争升级为轻量级锁，竞争失败的就会升级为重量级锁）。</span><br><span class="line">无锁-&gt;轻量级锁过程：修改mark word为轻量级锁结构，拷贝mark word 到线程栈的Lock Record中，mark word中的ptr_to_log_record指向线程栈的logrecord</span><br><span class="line">轻量级锁-&gt;重量级锁过程：轻量级锁膨胀（创建对象的objectmonitor对象）、修改mark word结构</span><br></pre></td></tr></table></figure>

<h3 id="2、synchronized轻量级锁升级过程"><a href="#2、synchronized轻量级锁升级过程" class="headerlink" title="2、synchronized轻量级锁升级过程"></a>2、synchronized轻量级锁升级过程</h3>

	<div class="row">
    <embed src="Synchronized轻量级锁源码分析.png" width="100%" height="550" type="application/pdf">
	</div>




<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">轻量级锁加锁过程：</span><br><span class="line"><span class="number">1</span>、无锁-&gt;轻量级锁过程</span><br><span class="line">-&gt;首先判断是不是无锁状态(锁标识是不是<span class="number">001</span>)</span><br><span class="line">-&gt;是<span class="number">001</span>，则将锁对象的mark word拷贝到线程栈的Log record（如图包含两部分obj和 displayed word ）中的displayed word【便于解锁时，将线程栈中logrecord中的mark word赋值回锁 对象的mark word】</span><br><span class="line">-&gt;cas尝试将mark word的指针ptr_to_lock_record指向Log Record，如果cas成功，那么就获取轻量级锁，失败继续后续步骤</span><br><span class="line">-&gt;如果失败，直接膨胀，即无锁状态经过一次cas失败，不进行自旋，直接升级膨胀为重量级锁</span><br><span class="line"><span class="number">2</span>、轻量级锁重入逻辑</span><br><span class="line">首先判断锁对象是不是处于轻量级锁状态（has_locker()方法），然后看线程栈是不是有这个锁记录，如果是则表示是重入操作，那么再次在线程栈（Log record保存在线程的一个栈结构中）压入一条锁记录（displaced word为空，即mark word 为空），只有再最后释放锁的时候才将栈底有效的mark word 复制回对象头</span><br><span class="line"><span class="number">3</span>、轻量级锁膨胀逻辑</span><br><span class="line">首先拿到monitor监视器对象，真正锁升级的方法实在ObjectMonitor::enter()方法</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">-&gt;（<span class="number">1</span>）、<span class="keyword">if</span>(mark-&gt;has_monitor()) 首先判断mark word是否是<span class="number">10</span>（是否有monitor对象，即是否是重量级锁）如果有则表示是重量级锁，直接返回</span><br><span class="line">-&gt;（<span class="number">2</span>）、如果没有，则<span class="keyword">if</span>(mark == markOopDesc::INFLATING()) 判断是否正在膨胀，如果正在膨胀，则执行ReadStableMark(object)进行自旋(实际通过调用yield释放时间片，避免活锁，即防止线程空跑不干真正的活)（自旋逻辑是：如果自旋次数大于<span class="number">16</span>则进行park()阻塞，否则调用yield释放时间片）</span><br><span class="line">-&gt;（<span class="number">3</span>）、不是正在膨胀，则执行  <span class="keyword">if</span>(mark-&gt;has_locker()) 判断当前锁标志位是不是<span class="number">00</span>（即轻量级锁），是的话 初始化ObjectMonitor，cas设置状态为膨胀中，然后通过cas操作，修改mark word 指针指向monitor指针，如果改成功则获取锁，设置ObjectMonitor的_header,_owner和_object，设置mark word锁状态为重量级锁，</span><br><span class="line">-&gt;（<span class="number">4</span>）、如果不是轻量级锁，则判断是不是无锁</span><br><span class="line">-&gt;是无锁，调用omAlloc分配一个ObjectMonitor对象</span><br><span class="line">-&gt;初始化objectMontor对象</span><br><span class="line">-&gt;设置monitor的header字段为mark word ,owner为<span class="keyword">null</span>，obj字段为锁对象</span><br><span class="line">-&gt;设置锁对象的mark word 为重量级锁状态，指向第一步分配的monitor对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、重量级锁加锁过程"><a href="#3、重量级锁加锁过程" class="headerlink" title="3、重量级锁加锁过程"></a>3、重量级锁加锁过程</h3>

	<div class="row">
    <embed src="Synchronized重量级锁加锁解锁执行逻辑.png" width="100%" height="550" type="application/pdf">
	</div>




<ol>
<li>重量级锁ObjectMonitor::enter() 加锁逻辑：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-&gt;通过cas尝试获取锁，就是将monitor对象的_owner指针指向当前线程，cas成功直接即返回获取锁</span><br><span class="line">-&gt;cas失败判断是否是当前线程获取锁，是当前线程，则表示是重入锁，重入次数加<span class="number">1</span>，直接获取锁</span><br><span class="line">-&gt;不是当前线程，则判断当前线程是否是之前持有轻量级锁的线程。由轻量级锁膨胀且则重入次数记为<span class="number">1</span></span><br><span class="line">-&gt;不是之前持有轻量级锁的线程，则先进行自适应自旋，自旋过程中会尝试获取锁，自旋终止条件：<span class="number">1</span>)成功获取锁<span class="number">2</span>)达到自旋次数（会自动调整自旋次数）<span class="number">3</span>)自旋的过程中会判断是否进入安全点，如果进入则终止自旋（每自旋<span class="number">256</span>次就会检查一次）</span><br><span class="line">-&gt;如果自旋结束，获取锁失败，会再尝试获取锁；如果获取锁失败，此时当前线程不甘心被挂起，再次尝试自旋，尝试获取锁</span><br><span class="line">-&gt;如果还获取锁失败，则准备在_cxq上排队</span><br><span class="line">-&gt;通过自旋保证当前线程一定能进入_cxq队列，进入循环，先还是通过自旋尝试获取锁，然后调用park()挂起当前线程，在park()之后在进行自旋尝试唤醒之后获取锁；最后在循环末尾增加内存屏障OrderAccess::fence()保证可见性</span><br><span class="line">-&gt;获取锁成功，跳出循环，_cxq出队</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>重量级锁ObjectMonitor::exit() 解锁唤醒逻辑：</li>
</ol>
<p><strong>1&gt;判断当前线程是不是持有锁的线程（即判断_owner是不是当前线程），如果是，如果重入计数器不为0，则重入计数器减1后返回，否则将对象头_ower设置为null，释放锁，然后加入一个内存屏障storeLoad，让修改生效（保证如果某个线程正在自旋抢占该锁，这种策略会优先保证通过自旋抢占锁的线程获取锁，而其它处于等待队列的线程则靠后）；根据QMODE的不同，执行不同的唤醒策略，策略如下</strong></p>
<p><img src="/2022/05/17/01-00-20-synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E6%80%BB%E7%BB%93/%E6%88%AA%E5%9B%BE.png" alt="截图"></p>
<p>最后执行unpark唤醒线程</p>
<p><strong>2&gt;如果_owner不是当前线程，判断当前线程是不是之前持有轻量级锁的线程，如果_owner位于当前线程调用栈帧，说明该锁是轻量级锁膨胀来的，修改_owner属性为当前线程；</strong></p>
<p><strong>如果不是当前线程，直接返回</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池调优总结</title>
    <url>/2022/07/10/01-00-22-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="线程池优化实战"><a href="#线程池优化实战" class="headerlink" title="线程池优化实战"></a>线程池优化实战</h1><h2 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h2><p><strong>QPS：</strong>Queries Per Second，顾名思义：“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。<strong>QPM*：</strong>每分查询率。</p>
<p><strong>TPS：</strong>是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
<p><strong>TP99：</strong>TP99指的是比如1000个请求进来，第990个大的请求时间，几称为TP99</p>
<p><strong>水位值：</strong>不是一个经验值，它类似于水库的水位线，需要监控巡检</p>
<p><strong>TPS处理流程：</strong></p>
<p>Tps即每秒处理事务数，包括了</p>
<p>1、用户请求服务器</p>
<p>2、服务器自己的内部查询等处理</p>
<p>3、服务器返回给用户</p>
<p>这三个过程，每秒能够完成N个这三个过程，Tps也就是N；</p>
<p>QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入QPS之中。每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p>
<p>一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
<p>如果是对一个接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么TPS等于QPS，否则，TPS不等于QPS</p>
<p> <strong>区别</strong></p>
<p>一次完成的请求可产生一个TPS，却可能对服务器请求多次，产生多个QPS。</p>
<h2 id="1-2线程池原理"><a href="#1-2线程池原理" class="headerlink" title="1.2线程池原理"></a>1.2线程池原理</h2><p><img src="/2022/07/10/01-00-22-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/image-20220711003530165.png" alt="image-20220711003530165"></p>
<blockquote>
<p>线程内部的代码一般是同步阻塞模型的。<br>同一个线程执行的多个任务是非抢占的。<br>调用方超时，被调用方仍然执行。<br>线程本身也要占用内存，可以通过-Xss设置。<br>被阻塞线程，不占用cpu。</p>
</blockquote>
<h2 id="1-3-线程池选择原则"><a href="#1-3-线程池选择原则" class="headerlink" title="1.3 线程池选择原则"></a>1.3 线程池选择原则</h2><p>具体要根据业务场景来，比如：</p>
<ul>
<li><p>C端请求</p>
<p>这种情况一般是响应时间敏感型，需要尽量快的把请求发出去</p>
<p>比如线程池可以这样调优：</p>
<p>corePoolSize：10</p>
<p>最大线程数：20</p>
<p>线程空闲时间：60</p>
<p>线程空闲时间单位：秒</p>
<p>阻塞队列大小：2000</p>
</li>
<li><p>MQ或Job（定时任务跑批等场景）</p>
<p>这种场景，无所谓响应时间，需要慢慢来，少占用资源</p>
<p>比如线程池可以这样调优：</p>
<p>corePoolSize：1</p>
<p>最大线程数：2</p>
<p>线程空闲时间：60</p>
<p>线程空闲时间单位：秒</p>
<p>阻塞队列大小：200000</p>
</li>
</ul>
<h2 id="1-4如何设置核心线程数"><a href="#1-4如何设置核心线程数" class="headerlink" title="1.4如何设置核心线程数"></a>1.4如何设置核心线程数</h2><p>1、首先要搞清楚是响应时间敏感还是吞吐量敏感</p>
<p>2、核心线程数应该是在监控的基础上，动态调整，压测不能完全解决问题</p>
<p>3、核心线程数：tp99*tps + buffer</p>
<h2 id="1-5线程池监控"><a href="#1-5线程池监控" class="headerlink" title="1.5线程池监控"></a>1.5线程池监控</h2><blockquote>
<p>监控指标：</p>
<p>1、等待时间的QPS和TP99</p>
<p>2、线程的执行时间</p>
<p>3、存活的线程数</p>
<p>4、队列的长度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.work.common.component.tpe.ext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程池，打曲线用</span></span><br><span class="line"><span class="comment"> * 现在还没接具体的监控曲线，先打出来</span></span><br><span class="line"><span class="comment"> * 1、阶段1，正在活着的线程</span></span><br><span class="line"><span class="comment"> * 2、阶段2，队列的长度</span></span><br><span class="line"><span class="comment"> * 3、阶段3，正在活着的线程</span></span><br><span class="line"><span class="comment"> * 4、阶段4，不是在这里写</span></span><br><span class="line"><span class="comment"> * 5、里面任务的QPS和TP99，before和after</span></span><br><span class="line"><span class="comment"> * 6、等待时间的QPS和TP99，提交和before</span></span><br><span class="line"><span class="comment"> * ----</span></span><br><span class="line"><span class="comment"> * 由于ThreadPoolExecutor的加强方法，通过protected方法漏出来的，在接口上没有</span></span><br><span class="line"><span class="comment"> * 所以，没法做wrapper，只能用继承；如果想要两个功能合起来的话，只能生编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String tpeName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tpeName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> corePoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maximumPoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> workQueue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MonitorThreadPoolExecutor</span><span class="params">(String tpeName,<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">			BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">		<span class="keyword">this</span>.tpeName = tpeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tpeName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> corePoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maximumPoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> workQueue</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MonitorThreadPoolExecutor</span><span class="params">(String tpeName,<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">			BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br><span class="line">		<span class="keyword">this</span>.tpeName = tpeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tpeName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> corePoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maximumPoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> workQueue</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> threadFactory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MonitorThreadPoolExecutor</span><span class="params">(String tpeName,<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">			BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">		<span class="keyword">this</span>.tpeName = tpeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tpeName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> corePoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maximumPoolSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> workQueue</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> threadFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MonitorThreadPoolExecutor</span><span class="params">(String tpeName,<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">			BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);</span><br><span class="line">		<span class="keyword">this</span>.tpeName = tpeName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Cache&lt;Runnable, Long&gt; runnableCacheBeforeExecute = CacheBuilder.newBuilder()</span><br><span class="line">			.expireAfterWrite(<span class="number">3</span>, TimeUnit.HOURS)	<span class="comment">//最多写进去3小时后</span></span><br><span class="line">			.maximumSize(<span class="number">100000</span>)					<span class="comment">//最多10w个对象，这两个是且的关系</span></span><br><span class="line">			.build();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Cache&lt;Runnable, Long&gt; runnableCacheBetweenExecute = CacheBuilder.newBuilder()</span><br><span class="line">			.expireAfterWrite(<span class="number">3</span>, TimeUnit.HOURS)	<span class="comment">//最多写进去3小时后</span></span><br><span class="line">			.maximumSize(<span class="number">100000</span>)					<span class="comment">//最多10w个对象，这两个是且的关系</span></span><br><span class="line">			.build();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//提交时间</span></span><br><span class="line">		<span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">		runnableCacheBeforeExecute.put(command, now);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.execute(command);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//执行前时间</span></span><br><span class="line">		<span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">		runnableCacheBetweenExecute.put(r, now);</span><br><span class="line">		</span><br><span class="line">		Long begin = runnableCacheBeforeExecute.getIfPresent(r);</span><br><span class="line">		<span class="keyword">if</span> (begin!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//6、等待时间的QPS和TP99，提交和before</span></span><br><span class="line">			log.debug(<span class="string">&quot;waitTime!tpe=&#123;&#125;,wait=&#123;&#125;&quot;</span>,tpeName,(now-begin));</span><br><span class="line">			runnableCacheBeforeExecute.invalidate(r);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//执行后时间</span></span><br><span class="line">		<span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">		Long begin = runnableCacheBetweenExecute.getIfPresent(r);</span><br><span class="line">		<span class="keyword">if</span> (begin!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//5、里面任务的QPS和TP99，before和after</span></span><br><span class="line">			<span class="comment">//CAT?grafana?openfalcon</span></span><br><span class="line">			log.debug(<span class="string">&quot;executeTime!tpe=&#123;&#125;,duration=&#123;&#125;&quot;</span>,tpeName,(now-begin));</span><br><span class="line">			runnableCacheBetweenExecute.invalidate(r);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1、阶段1，正在活着的线程</span></span><br><span class="line">		<span class="keyword">int</span> activeCount = <span class="keyword">this</span>.getActiveCount();</span><br><span class="line">		<span class="keyword">int</span> corePoolSize = <span class="keyword">this</span>.getCorePoolSize();</span><br><span class="line">		<span class="keyword">int</span> maxPoolSize = <span class="keyword">this</span>.getMaximumPoolSize();</span><br><span class="line">		log.debug(<span class="string">&quot;threadCount!activeCount=&#123;&#125;,corePoolSize=&#123;&#125;,maxPoolSize=&#123;&#125;&quot;</span>,activeCount,corePoolSize,maxPoolSize);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、阶段2，队列的长度</span></span><br><span class="line">		<span class="keyword">int</span> queueSize = <span class="keyword">this</span>.getQueue().size();</span><br><span class="line">		log.debug(<span class="string">&quot;queueSize!queueSize=&#123;&#125;&quot;</span>,queueSize);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6线程池监控报警"><a href="#1-6线程池监控报警" class="headerlink" title="1.6线程池监控报警"></a>1.6线程池监控报警</h2><blockquote>
<p>核心线程数的设置 = 里面任务的TP99 * 里面任务的QPS + buffer<br>监控报警，简配：定时任务打印活动线程数和队列里的任务数（缺了就加，但是无法在上线前估算）<br>监控报警，高配：增加打印任务等待时间和任务执行的QPS和TP99（可用于上线前估算）<br>由于QPS可能自然增长，下游的TP99也可能增长，每周值班人看看所有的线程池监控图，如果高于水位报警线75%，则适当增加核心线程数<br>可预估的流量增长（做活动、大促），可提前增加核心线程数</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ThreadPoolExecutor</tag>
        <tag>线程池调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring底层核心原理解析</title>
    <url>/2022/06/18/02-00-00-Spring%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Spring底层核心原理解析"><a href="#Spring底层核心原理解析" class="headerlink" title="Spring底层核心原理解析"></a>Spring底层核心原理解析</h2><h3 id="1、Spring概要"><a href="#1、Spring概要" class="headerlink" title="1、Spring概要"></a>1、Spring概要</h3><ol>
<li>Bean的生命周期底层原理</li>
<li>依赖注入底层原理</li>
<li>初始化底层原理</li>
<li>推断构造方法底层原理</li>
<li>AOP底层原理</li>
<li>Spring事务底层原理</li>
</ol>
<h3 id="2、Spring入门使用"><a href="#2、Spring入门使用" class="headerlink" title="2、Spring入门使用"></a>2、Spring入门使用</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">UserService userService = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.test();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于这三行代码应该，大部分同学应该都是比较熟悉，这是学习Spring的hello world。可是，这三行代码底层都做了什么，比如：</p>
<ol>
<li>第一行代码，会构造一个ClassPathXmlApplicationContext对象，ClassPathXmlApplicationContext该如何理解，调用该构造方法除开会实例化得到一个对象，还会做哪些事情？</li>
<li>第二行代码，会调用ClassPathXmlApplicationContext的getBean方法，会得到一个UserService对象，getBean()是如何实现的？返回的UserService对象和我们自己直接new的UserService对象有区别吗？</li>
<li>第三行代码，就是简单的调用UserService的test()方法，不难理解。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"><span class="comment">//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</span></span><br><span class="line">UserService userService = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.test();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到AnnotationConfigApplicationContext的用法和ClassPathXmlApplicationContext是非常类似的，只不过需要传入的是一个class，而不是一个xml文件。</p>
<p>而AppConfig.class和spring.xml一样，表示Spring的配置，比如可以指定扫描路径，可以直接定义Bean</p>
</blockquote>
<blockquote>
<p>所以spring.xml和AppConfig.class本质上是一样的。</p>
<p>目前，我们基本很少直接使用上面这种方式来用Spring，而是使用Spring MVC，或者Spring Boot，但是它们都是基于上面这种方式的，都需要在内部去创建一个ApplicationContext的，只不过：</p>
<ol>
<li>Spring MVC创建的是<strong>XmlWebApplicationContext</strong>，和<strong>ClassPathXmlApplicationContext</strong>类似，都是基于XML配置的</li>
<li>Spring Boot创建的是<strong>AnnotationConfigApplicationContext</strong></li>
</ol>
<p>因为AnnotationConfigApplicationContext是比较重要的，并且AnnotationConfigApplicationContext和ClassPathXmlApplicationContext大部分底层都是共同的，后续课程我们会着重将AnnotationConfigApplicationContext的底层实现，对于ClassPathXmlApplicationContext，同学们可以在课程结束后作为作业，业余时间看看相关源码即可。</p>
</blockquote>
</blockquote>
<h3 id="3、Spring中是如何创建一个对象？"><a href="#3、Spring中是如何创建一个对象？" class="headerlink" title="3、Spring中是如何创建一个对象？"></a>3、<strong>Spring中是如何创建一个对象？</strong></h3><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">UserService userService = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.test();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们调用context.getBean(“userService”)时，就会去创建一个对象，但是getBean方法内部怎么知道”userService”对应的是UserService类呢？</p>
<p>所以，我们就可以分析出来，在调用AnnotationConfigApplicationContext的构造方法时，也就是第一行代码，会去做一些事情：</p>
<ol>
<li>解析AppConfig.class，得到扫描路径</li>
<li>遍历扫描路径下的所有Java类，如果发现某个类上存在@Component、@Service等注解，那么Spring就把这个类记录下来，存在一个Map中，比如Map。（实际上，Spring源码中确实存在类似的这么一个Map，叫做BeanDefinitionMap）</li>
<li>Spring会根据某个规则生成当前类对应的beanName，作为key存入Map，当前类作为value</li>
</ol>
<p>这样，但调用context.getBean(“userService”)时，就可以根据”userService”找到UserService类，从而就可以去创建对象了。</p>
</blockquote>
<h3 id="4、Bean的创建过程"><a href="#4、Bean的创建过程" class="headerlink" title="4、Bean的创建过程"></a>4、Bean的创建过程</h3><p>那么Spring到底是如何来创建一个Bean的呢，这个就是Bean创建的生命周期，大致过程如下</p>
<ol>
<li>利用该类的构造方法来实例化得到一个对象（但是如何一个类中有多个构造方法，Spring则会进行选择，这个叫做<strong>推断构造方法</strong>）</li>
<li>得到一个对象后，Spring会判断该对象中是否存在被@Autowired注解了的属性，把这些属性找出来并由Spring进行赋值（<strong>依赖注入</strong>）</li>
<li>依赖注入后，Spring会判断该对象是否实现了BeanNameAware接口、BeanClassLoaderAware接口、BeanFactoryAware接口，如果实现了，就表示当前对象必须实现该接口中所定义的setBeanName()、setBeanClassLoader()、setBeanFactory()方法，那Spring就会调用这些方法并传入相应的参数（<strong>Aware回调</strong>）</li>
<li>Aware回调后，Spring会判断该对象中是否存在某个方法被@PostConstruct注解了，如果存在，Spring会调用当前对象的此方法（<strong>初始化前</strong>）</li>
<li>紧接着，Spring会判断该对象是否实现了InitializingBean接口，如果实现了，就表示当前对象必须实现该接口中的afterPropertiesSet()方法，那Spring就会调用当前对象中的afterPropertiesSet()方法（<strong>初始化</strong>）</li>
<li>最后，Spring会判断当前对象需不需要进行AOP，如果不需要那么Bean就创建完了，如果需要进行AOP，则会进行动态代理并生成一个代理对象做为Bean（<strong>初始化后</strong>）</li>
</ol>
<p>通过最后一步，我们可以发现，当Spring根据UserService类来创建一个Bean时：</p>
<ol>
<li>如果不用进行AOP，那么Bean就是UserService类的构造方法所得到的对象。</li>
<li>如果需要进行AOP，那么Bean就是UserService的代理类所实例化得到的对象，而不是UserService本身所得到的对象。</li>
</ol>
<p><strong>Bean对象创建出来后：</strong></p>
<ol>
<li>如果当前Bean是单例Bean，那么会把该Bean对象存入一个Map，Map的key为beanName，value为Bean对象。这样下次getBean时就可以直接从Map中拿到对应的Bean对象了。（实际上，在Spring源码中，这个Map就是<strong>单例池</strong>）</li>
<li>如果当前Bean是原型Bean，那么后续没有其他动作，不会存入一个Map，下次getBean时会再次执行上述创建过程，得到一个新的Bean对象。</li>
</ol>
<h3 id="5、推断构造方法"><a href="#5、推断构造方法" class="headerlink" title="5、推断构造方法"></a>5、<strong>推断构造方法</strong></h3><p>Spring在基于某个类生成Bean的过程中，需要利用该类的构造方法来实例化得到一个对象，但是<strong>如果一个类存在多个构造方法，Spring会使用哪个呢？</strong></p>
<p>Spring的判断逻辑如下：</p>
<ol>
<li><p>如果一个类只存在一个构造方法，不管该构造方法是无参构造方法，还是有参构造方法，Spring都会用这个构造方法</p>
</li>
<li><p>如果一个类存在多个构造方法</p>
</li>
<li><p>这些构造方法中，存在一个无参的构造方法，那么Spring就会用这个无参的构造方法</p>
<p>这些构造方法中，不存在一个无参的构造方法，那么Spring就会<strong>报错</strong></p>
</li>
</ol>
<p>Spring的设计思想是这样的：</p>
<ol>
<li>如果一个类只有一个构造方法，那么没得选择，只能用这个构造方法</li>
<li>如果一个类存在多个构造方法，Spring不知道如何选择，就会看是否有无参的构造方法，因为无参构造方法本身表示了一种默认的意义</li>
<li>不过如果某个构造方法上加了@Autowired注解，那就表示程序员告诉Spring就用这个加了注解的方法，那Spring就会用这个加了@Autowired注解构造方法了</li>
</ol>
<p>需要重视的是，如果Spring选择了一个有参的构造方法，Spring在调用这个有参构造方法时，需要传入参数，那这个参数是怎么来的呢？</p>
<p>Spring会根据入参的类型和入参的名字去Spring中找Bean对象（以单例Bean为例，Spring会从单例池那个Map中去找）：</p>
<ol>
<li>先根据入参类型找，如果只找到一个，那就直接用来作为入参</li>
<li>如果根据类型找到多个，则再根据入参名字来确定唯一一个</li>
<li>最终如果没有找到，则会报错，无法创建当前Bean对象</li>
</ol>
<p>确定用哪个构造方法，确定入参的Bean对象，这个过程就叫做<strong>推断构造方法</strong>。</p>
<h3 id="6、AOP大致流程"><a href="#6、AOP大致流程" class="headerlink" title="6、AOP大致流程"></a>6、<strong>AOP大致流程</strong></h3><p>AOP就是进行动态代理，在创建一个Bean的过程中，Spring在最后一步会去判断当前正在创建的这个Bean是不是需要进行AOP，如果需要则会进行动态代理。</p>
<p>如何判断当前Bean对象需不需要进行AOP:</p>
<ol>
<li>找出所有的切面Bean</li>
<li>遍历切面bean中的每个方法，看是否写了@Before、@After等注解</li>
<li>如果写了，则判断所对应的Pointcut是否和当前Bean对象的类是否匹配</li>
<li>如果匹配则表示当前Bean对象有匹配的的Pointcut，表示需要进行AOP</li>
<li>然后将匹配的切面bean方法和对应的当前bean通过map存储起来</li>
<li>map存储起来的bean方法和对应的当前bean，在代理执行对应的方法时调用，map结构举例为</li>
</ol>
<p>利用cglib进行AOP的大致流程：</p>
<ol>
<li><p>生成代理类UserServiceProxy，代理类继承UserService</p>
</li>
<li><p>代理类中重写了父类的方法，比如UserService中的test()方法</p>
</li>
<li><p>代理类中还会有一个target属性，该属性的值为被代理对象（也就是通过UserService类推断构造方法实例化出来的对象，进行了依赖注入、初始化等步骤的对象）</p>
</li>
<li><p>代理类中的test()方法被执行时的逻辑如下：</p>
</li>
<li><ol>
<li>执行切面逻辑（@Before）</li>
<li>调用target.test()</li>
</ol>
</li>
</ol>
<p>当我们从Spring容器得到UserService的Bean对象时，拿到的就是UserServiceProxy所生成的对象，也就是代理对象。</p>
<p>UserService代理对象.test()—&gt;执行切面逻辑—&gt;target.test()，注意target对象不是代理对象，而是被代理对象。</p>
<p>如下图：</p>
<p>![11](02-00-00-Spring底层核心原理解析/截图 (1).png)</p>
<p><strong>Aop  cglib代理过程如下：</strong></p>
<p>举例：</p>
<p>比如类UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 配置类</span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zhouyu&quot;)</span></span><br><span class="line"><span class="comment">//@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">      transactionManager.setDataSource(dataSource());</span><br><span class="line">      <span class="keyword">return</span> transactionManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">      dataSource.setUrl(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mysql_test?characterEncoding=utf-8&amp;useSSL=false&quot;</span>);</span><br><span class="line">      dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">      dataSource.setPassword(<span class="string">&quot;Zhouyu123456***&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      SqlSessionFactoryBean sessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">      sessionFactoryBean.setDataSource(dataSource());</span><br><span class="line">      <span class="keyword">return</span> sessionFactoryBean.getObject();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 有如下切面</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before(&quot;execution(public void com.zhouyu.service.UserService.test())&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zhouyuBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;zhouyuBefore&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cglib代理逻辑如下：</span><br><span class="line"><span class="number">1</span>&gt;cglib的本质是通过继承来实现，对于UserService，会生成如下代理类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    UserService target; <span class="comment">// 组合实现了userService，这个userService就是spring中注入了属性的userService对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行@Before 切面逻辑</span></span><br><span class="line">      target.test();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 具体的调用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">      UserService userService = (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">      userService.test(); <span class="comment">// 断点到这里的时候 这个userService是aop代理类 这个userService的orderService是null，而跟踪断点到UserService 类的test方法时，</span></span><br><span class="line">      <span class="comment">//orderService不为null，具体原因如上所述，调用userService的时候这个对象是spring中注入了属性的userService对象（@Component）</span></span><br><span class="line">      <span class="comment">// 对象具体内容如下图</span></span><br><span class="line">      <span class="comment">// 为什么aop代理对象的属性没有值？因为aop代理对象生成后不会再注入属性。为什么不再注入属性？没有必要，因为target可以通过其它方式注入，再切面中可以通过</span></span><br><span class="line">      <span class="comment">// joinPoint.getTarget()方法拿到userService，间接就拿到了orderService</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![](02-00-00-Spring底层核心原理解析/截图 (1)-1655523165409.png)</p>
<h3 id="7、Spring事务"><a href="#7、Spring事务" class="headerlink" title="7、Spring事务"></a>7、<strong>Spring事务</strong></h3><p>当我们在某个方法上加了@Transactional注解后，就表示该方法在调用时会开启Spring事务，而这个方法所在的类所对应的Bean对象会是该类的代理对象。</p>
<p>Spring事务的代理对象执行某个方法时的步骤：</p>
<ol>
<li>判断当前执行的方法是否存在@Transactional注解</li>
<li>如果存在，则利用事务管理器（TransactionMananger）新建一个数据库连接conn</li>
<li>修改数据库连接的autocommit为false（默认true，比如userService中test方法中有两个sql，sql1和sql2，为true的话就会sql1执行完自动提交，sql2执行完自动提交；分开提交，事务无法起到作用，并且sql执行完如果后面抛异常，没法回滚，起不到事务的作用，设置为fasle后，在test方法执行完后，手动进行提交，conn.commit()，异常就调用conn.rollback回滚）</li>
<li>执行target.test()，执行程序员所写的业务逻辑代码，也就是执行sql</li>
<li>执行完了之后如果没有出现异常，则提交，否则回滚</li>
</ol>
<p>Spring事务是否会失效的判断标准：<strong>某个加了@Transactional注解的方法被调用时，要判断到底是不是直接被代理对象调用的，如果是则事务会生效，如果不是则失效。</strong></p>
<p><strong>方法内调事务失效分析：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">public</span> OrderService orderService;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      jdbcTemplate.execute(<span class="string">&quot;INSERT INTO `mysql_test`.`product`(`id`, `product_name`, `stock`, `version`) VALUES (3, &#x27;元旦大礼包&#x27;, 5, 0);&quot;</span>);</span><br><span class="line">      a();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##分析事务失效原因：</span><br><span class="line"><span class="number">1</span>&gt;test()方法调用a()按照如下代理逻辑执行</span><br><span class="line">a&gt;cglib的本质是通过继承来实现，对于UserService，会生成如下代理类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    UserService target; <span class="comment">// 组合实现了userService，这个userService就是spring中注入了属性的userService对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行@Before 切面逻辑</span></span><br><span class="line">      target.test();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">b&gt;target是一个普通对象（注入了相应的属性），即没有经过事务切面处理的非代理增强的对象</span><br><span class="line">c&gt;调用test方法，然后内调a（）方法，实际是普通对象调用a（）方法，因此事务不会生效</span><br><span class="line">d&gt;想要生效，可以新建一个有事务方法a（）的类，在通过注入调用 或者 自我注入（注入的是增强后的代理对象）</span><br></pre></td></tr></table></figure>

<p><strong>为什么AppConfig类不加@Configuration注解，事务不会生效呢？</strong></p>
<p><strong>1&gt;AppConfig类不加@Configuration注解，则事务管理器</strong>transactionManager<strong>的datasource和jdbcTemplate的datasource不是同一个</strong></p>
<p><strong>2&gt;事务方法执行时，会生成事务管理器</strong>transactionManager<strong>，执行sql时会用到jdbcTemplate，这两个dataSource不是同一个，执行sql时会通过jdbcTemplate的dataSource建立数据库连接</strong></p>
<p><strong>3&gt;导致事务执行时，事务无法生效</strong></p>
<p><strong>4&gt;加了@Configuration，事务管理器</strong>transactionManager<strong>和jdbcTemplate的datasource就是同一个（跟代理模式有关）</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之Bean生命周期源码解析</title>
    <url>/2022/08/12/02-00-02-Spring%E4%B9%8BBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Bean生命周期"><a href="#一、Bean生命周期" class="headerlink" title="一、Bean生命周期"></a>一、Bean生命周期</h2><h3 id="1、生成BeanDefinition"><a href="#1、生成BeanDefinition" class="headerlink" title="1、生成BeanDefinition"></a>1、生成BeanDefinition</h3><p><a href="https://www.processon.com/view/link/62af491e5653bb5256e05be7">spring底层类扫描流程图</a></p>
<blockquote>
<ol>
<li>首先，通过ResourcePatternResolver获得指定包路径下的所有</li>
</ol>
<p>.class文件（Spring源码中将此文件包装成了Resource对象）</p>
<ol>
<li>遍历每个Resource对象</li>
<li>利用MetadataReaderFactory解析Resource对象得到MetadataReader（在Spring源码中MetadataReaderFactory具体的实现类为CachingMetadataReaderFactory，MetadataReader的具体实现类为SimpleMetadataReader）</li>
<li>利用MetadataReader进行excludeFilters和includeFilters，以及条件注解@Conditional的筛选（条件注解并不能理解：某个类上是否存在@Conditional注解，如果存在则调用注解中所指定的类的match方法进行匹配，匹配成功则通过筛选，匹配失败则pass掉。）</li>
<li>筛选通过后，基于metadataReader生成ScannedGenericBeanDefinition</li>
<li>再基于metadataReader判断是不是对应的类是不是接口或抽象类</li>
<li>如果筛选通过，那么就表示扫描到了一个Bean，将ScannedGenericBeanDefinition加入结果集</li>
</ol>
</blockquote>
<p>BeanDefinition最终扫面放入了beanDefinitionMap 和合并之后的mergedBeanDefinitions  map中。</p>
<h3 id="2、合并BeanDefinition"><a href="#2、合并BeanDefinition" class="headerlink" title="2、合并BeanDefinition"></a>2、合并BeanDefinition</h3><p>基于如下情况，需要对BeanDefinition做合并</p>
<blockquote>
<p>通过扫描得到所有BeanDefinition之后，就可以根据BeanDefinition创建Bean对象了，但是在Spring中支持父子BeanDefinition，和Java父子类类似，但是完全不是一回事。父子BeanDefinition实际用的比较少，使用是这样的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;parent&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.zhouyu.service.Parent&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;child&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.zhouyu.service.Child&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">##结果：这么定义的情况下，child是单例Bean。</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;parent&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.zhouyu.service.Parent&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;child&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.zhouyu.service.Child&quot;</span> parent=<span class="string">&quot;parent&quot;</span>/&gt;    </span><br><span class="line"></span><br><span class="line">以上有两个Beandefinition 合并之后会生成第三个beandefinition,这样可以不影响前两个beandefinition</span><br><span class="line">    </span><br><span class="line">##结果：</span><br><span class="line">但是这么定义的情况下，child就是原型Bean了。（继承了父类）</span><br><span class="line">因为child的父BeanDefinition是parent，所以会继承parent上所定义的scope属性。</span><br><span class="line">而在根据child来生成Bean对象之前，需要进行BeanDefinition的合并，得到完整的child的BeanDefinition。</span><br></pre></td></tr></table></figure>

<h3 id="3、加载类"><a href="#3、加载类" class="headerlink" title="3、加载类"></a>3、加载类</h3><p>Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); 方法进行类的加载。</p>
<p><strong>ClassUtils.getDefaultClassLoader()</strong></p>
<ol>
<li>优先返回当前线程中的ClassLoader</li>
<li>线程中类加载器为null的情况下，返回ClassUtils类的类加载器</li>
<li>如果ClassUtils类的类加载器为空，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回系统类加载器</li>
</ol>
<h3 id="4、实例化前"><a href="#4、实例化前" class="headerlink" title="4、实例化前"></a>4、实例化前</h3><p>**InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()**：完成实例化前的扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;userService&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;实例化前&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">## 结果</span><br><span class="line">userService这个Bean，在实例化前会直接返回一个由我们所定义的UserService对象。如果是这样，表示不需要Spring来实例化了，并且后续的Spring依赖注入也不会进行了，会跳过一些步骤，直接执行初始化后这一步。</span><br></pre></td></tr></table></figure>

<h3 id="5、实例化"><a href="#5、实例化" class="headerlink" title="5、实例化"></a>5、实例化</h3><p><strong>5.1 Supplier创建对象</strong></p>
<blockquote>
<p>首先判断BeanDefinition中是否设置了Supplier，如果设置了则调用Supplier的get()得到对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">beanDefinition.setInstanceSupplier(<span class="keyword">new</span> Supplier&lt;Object&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">context.registerBeanDefinition(<span class="string">&quot;userService&quot;</span>, beanDefinition);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>5.2 工厂方法创建对象</strong></p>
<blockquote>
<p>如果没有设置Supplier，则检查BeanDefinition中是否设置了factoryMethod，也就是工厂方法，有两种方式可以设置factoryMethod。</p>
<p>Spring发现当前BeanDefinition方法设置了工厂方法后，就会区分这两种方式，然后调用工厂方法得到对象。</p>
<p>值得注意的是，我们通过@Bean所定义的BeanDefinition，是存在factoryMethod和factoryBean的，也就是和上面的方式二非常类似，@Bean所注解的方法就是factoryMethod，AppConfig对象就是factoryBean。如果@Bean所注解的方法是static的，那么对应的就是方式一。</p>
</blockquote>
<p><strong>5.3 推断构造方法</strong></p>
<h3 id="6、BeanDefinition的后置处理"><a href="#6、BeanDefinition的后置处理" class="headerlink" title="6、BeanDefinition的后置处理"></a>6、BeanDefinition的后置处理</h3><p>**MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()**：在真正给属性赋值之前，可以对此时的BeanDefinition进行加工。</p>
<p>指定bean得初始化方法</p>
<p>填充属性</p>
<p><strong>实例化之后，属性赋值之前</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( <span class="string">&quot;userService&quot;</span>.equals(beanName) )&#123;</span><br><span class="line">			<span class="comment">// 设置初始化方法</span></span><br><span class="line">			beanDefinition.setInitMethodName(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">			<span class="comment">// 属性填充</span></span><br><span class="line">			beanDefinition.getPropertyValues().add(<span class="string">&quot;orderService&quot;</span>,<span class="keyword">new</span> OrderService());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7、实例化后"><a href="#7、实例化后" class="headerlink" title="7、实例化后"></a>7、实例化后</h3><p>**InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()**：实例化后调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;userService&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">			UserService userService = (UserService) bean;</span><br><span class="line">			userService.test();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、自动注入"><a href="#8、自动注入" class="headerlink" title="8、自动注入"></a>8、自动注入</h3><h3 id="9、-处理属性"><a href="#9、-处理属性" class="headerlink" title="9、 处理属性"></a>9、 处理属性</h3><blockquote>
<p>populateBean方法中调用</p>
<p>这个步骤中，就会处理@Autowired、@Resource、@Value等注解，也是通过**InstantiationAwareBeanPostProcessor.postProcessProperties()**扩展点来实现的，比如我们甚至可以实现一个自己的自动注入功能，</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;userService&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Field field : bean.getClass().getFields()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (field.isAnnotationPresent(ZhouyuInject.class)) &#123;</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						field.set(bean, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10、执行Aware"><a href="#10、执行Aware" class="headerlink" title="10、执行Aware"></a>10、执行Aware</h3><blockquote>
<p>initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) 方法中进行调用</p>
<p>完成了属性赋值之后，Spring会执行一些回调，包括：</p>
<ol>
<li>BeanNameAware：回传beanName给bean对象。</li>
<li>BeanClassLoaderAware：回传classLoader给bean对象。</li>
<li>BeanFactoryAware：回传beanFactory给对象。</li>
</ol>
</blockquote>
<h3 id="11、初始化前"><a href="#11、初始化前" class="headerlink" title="11、初始化前"></a>11、初始化前</h3><blockquote>
<p>在initializeBean方法里调用</p>
</blockquote>
<h3 id="12、初始化"><a href="#12、初始化" class="headerlink" title="12、初始化"></a>12、初始化</h3><h3 id="13、初始化后"><a href="#13、初始化后" class="headerlink" title="13、初始化后"></a>13、初始化后</h3><p><a href="https://www.processon.com/view/link/62f51fe4637689072eaf1851">Spring 生命周期</a></p>
<p><a href="https://www.processon.com/view/link/62f69b2d0e3e740754f8bb69">Spring思维导图_持续补充</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring生命周期总结</title>
    <url>/2022/06/22/02-00-03-Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://www.processon.com/view/link/62b34904637689074ac6d48a">Spring整体流程图</a></p>
<p><a href="https://www.processon.com/view/link/62af491e5653bb5256e05be7">Spring启动扫描逻辑</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之循环依赖底层源码解析</title>
    <url>/2022/06/26/02-00-05-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="一、Spring之循环依赖底层源码解析"><a href="#一、Spring之循环依赖底层源码解析" class="headerlink" title="一、Spring之循环依赖底层源码解析"></a>一、Spring之循环依赖底层源码解析</h1><h2 id="1-1-什么是循环依赖？"><a href="#1-1-什么是循环依赖？" class="headerlink" title="1.1 什么是循环依赖？"></a>1.1 <strong>什么是循环依赖？</strong></h2><blockquote>
<p>就是A对象依赖了B对象，B对象依赖了A对象</p>
<p>如下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// A依赖了B</span><br><span class="line">class A&#123;</span><br><span class="line">	public B b;</span><br><span class="line">&#125;</span><br><span class="line">// B依赖了A</span><br><span class="line">class B&#123;</span><br><span class="line">	public A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="1-2-Bean的生命周期"><a href="#1-2-Bean的生命周期" class="headerlink" title="1.2 Bean的生命周期"></a>1.2 Bean的生命周期</h2><blockquote>
<p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p>
<p>被Spring管理的对象叫做Bean。Bean的生成步骤如下：</p>
<ol>
<li>Spring扫描class得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean</li>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li>
<li>填充原始对象中的属性（依赖注入）</li>
<li>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</li>
<li>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</li>
</ol>
</blockquote>
<h2 id="1-3-如何解决循环依赖的问题"><a href="#1-3-如何解决循环依赖的问题" class="headerlink" title="1.3 如何解决循环依赖的问题"></a>1.3 如何解决循环依赖的问题</h2><p><strong>三级缓存</strong></p>
<blockquote>
<p>三级缓存是通用的叫法。</p>
<p>一级缓存为：<strong>singletonObjects===&gt;完成执行完完整生命周期的bean（完整的）</strong></p>
<p>二级缓存为：<strong>earlySingletonObjects===&gt;存放还没去填充完属性的bean，早期暴露对象（半成品）</strong></p>
<p>三级缓存为：<strong>singletonFactories===&gt;存放用来创建bean对象的工厂</strong></p>
<p><strong>先稍微解释一下这三个缓存的作用，后面详细分析：</strong></p>
<ul>
<li>singletonObjects中缓存的是已经经历了完整生命周期的bean对象。</li>
<li>earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入了earlySingletonObjects。</li>
<li>singletonFactories中缓存的是ObjectFactory，表示对象工厂，表示用来创建早期bean对象的工厂。</li>
</ul>
</blockquote>
<h2 id="1-4解决循环依赖流程"><a href="#1-4解决循环依赖流程" class="headerlink" title="1.4解决循环依赖流程"></a>1.4解决循环依赖流程</h2><p><img src="/2022/06/26/02-00-05-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/stickPicture.png" alt="stickPicture"></p>
<blockquote>
<ul>
<li><p>这个ObjectFactory就是上文说的labmda表达式，中间有getEarlyBeanReference方法，注意存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法</p>
</li>
<li><p>从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中，那什么时候放入到singletonObjects中呢？我们这个时候得来理解一下earlySingletonObjects的作用，此时，我们只得到了A原始对象的代理对象，这个对象还不完整，因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的earlyProxyReferences，在AbstractAutoProxyCreator的postProcessAfterInitialization方法中，会去判断当前beanName是否在earlyProxyReferences，如果在则表示已经提前进行过AOP了，无需再次进行AOP。对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要把A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后放入singletonObjects中。</p>
</li>
</ul>
</blockquote>
<h2 id="1-5循环依赖总结"><a href="#1-5循环依赖总结" class="headerlink" title="1.5循环依赖总结"></a>1.5循环依赖总结</h2><blockquote>
<ol>
<li>【一级缓存】singletonObjects：缓存经过了<strong>完整生命周期</strong>的bean</li>
<li>【二级缓存】earlySingletonObjects：缓存<strong>未经过完整生命周期的bean</strong>，如果某个bean出现了循环依赖，就会<strong>提前</strong>把这个暂时未经过完整生命周期的bean放入earlySingletonObjects中，这个bean如果要经过AOP，那么就会把代理对象放入earlySingletonObjects中，否则就是把原始对象放入earlySingletonObjects，但是不管怎么样，就是是代理对象，代理对象所代理的原始对象也是没有经过完整生命周期的，所以放入earlySingletonObjects我们就可以统一认为是<strong>未经过完整生命周期的bean。</strong></li>
</ol>
<p><strong>还有一个作用是保证早期暴露的bean的单例：当出现多个循环依赖的时候，比如如下情况</strong></p>
<p><strong>通过将早期暴露的A的bean放入</strong>earlySingletonObjects，可以保证其它bean在注入a时的一致性</p>
<p>二级缓存存的就是三级缓存执行的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> C c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>【三级缓存】singletonFactories：缓存的是一个ObjectFactory，也就是一个Lambda表达式。在每个Bean的生成过程中，经过<strong>实例化</strong>得到一个原始对象后，都会提前基于原始对象暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式<strong>可能用到，也可能用不到</strong>，如果当前Bean没有出现循环依赖，那么这个Lambda表达式没用，当前bean按照自己的生命周期正常执行，执行完后直接把当前bean放入singletonObjects中，如果当前bean在依赖注入时发现出现了循环依赖（当前正在创建的bean被其他bean依赖了），则从三级缓存中拿到Lambda表达式，并执行Lambda表达式得到一个对象，并把得到的对象放入二级缓存（(如果当前Bean需要AOP，那么执行lambda表达式，得到就是对应的代理对象，如果无需AOP，则直接得到一个原始对象)）。</li>
</ol>
<p><strong>singletonFactories是真正打破循环依赖的核心。</strong></p>
<ol start="4">
<li>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过AOP了。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring循环依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之依赖注入源码解析</title>
    <url>/2022/08/13/02-00-04-Spring%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、-Spring中依赖注入的方式"><a href="#一、-Spring中依赖注入的方式" class="headerlink" title="一、 Spring中依赖注入的方式"></a>一、 Spring中依赖注入的方式</h2><blockquote>
<p>首先分两种：</p>
<ol>
<li>手动注入</li>
<li>自动注入</li>
</ol>
</blockquote>
<h3 id="1、手动注入"><a href="#1、手动注入" class="headerlink" title="1、手动注入"></a>1、手动注入</h3><p>在XML中定义Bean时，就是手动注入，因为是<strong>程序员手动给某个属性指定了值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.luban.service.UserService&quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;orderService&quot;</span> ref=<span class="string">&quot;orderService&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面这种底层是通过<strong>set方法</strong>进行注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.luban.service.UserService&quot;</span>&gt;</span><br><span class="line">	&lt;constructor-arg index=<span class="string">&quot;0&quot;</span> ref=<span class="string">&quot;orderService&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面这种底层是通过<strong>构造方法</strong>进行注入。</p>
<p>所以手动注入的底层也就是分为两种：</p>
<ol>
<li>set方法注入</li>
<li>构造方法注入</li>
</ol>
<h3 id="2、自动注入"><a href="#2、自动注入" class="headerlink" title="2、自动注入"></a>2、自动注入</h3><p>自动注入又分为两种：</p>
<ol>
<li>XML的autowire自动注入</li>
<li>@Autowired注解的自动注入</li>
</ol>
<h4 id="2-1-XML的autowire自动注入"><a href="#2-1-XML的autowire自动注入" class="headerlink" title="2.1 XML的autowire自动注入"></a>2.1 XML的autowire自动注入</h4><p>在XML中，我们可以在定义一个Bean时去指定这个Bean的自动注入模式：</p>
<ol>
<li>byType</li>
<li>byName</li>
<li>constructor</li>
<li>default</li>
<li>no</li>
</ol>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.luban.service.UserService&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>这么写，表示Spring会自动的给userService中所有的属性自动赋值（<strong>不需要</strong>这个属性上有@Autowired注解，但需要这个属性有对应的<strong>set方法</strong>）。</p>
<p>在创建Bean的过程中，在填充属性时，Spring会去解析当前类，把<strong>当前类的所有方法</strong>都解析出来，Spring会去解析每个方法得到对应的PropertyDescriptor对象，PropertyDescriptor中有几个属性：</p>
<ol>
<li><strong>name：这个name并不是方法的名字，而是拿方法名字进过处理后的名字</strong><ol>
<li><strong>如果方法名字以“get”开头，比如“getXXX”,那么name=XXX</strong></li>
<li><strong>如果方法名字以“is”开头，比如“isXXX”,那么name=XXX</strong></li>
<li><strong>如果方法名字以“set”开头，比如“setXXX”,那么name=XXX</strong></li>
</ol>
</li>
<li><strong>readMethodRef：表示get方法的Method对象的引用</strong></li>
<li><strong>readMethodName：表示get方法的名字</strong></li>
<li><strong>writeMethodRef：表示set方法的Method对象的引用</strong></li>
<li><strong>writeMethodName：表示set方法的名字</strong></li>
<li><strong>propertyTypeRef：如果有get方法那么对应的就是返回值的类型，如果是set方法那么对应的就是set方法中唯一参数的类型</strong></li>
</ol>
<blockquote>
<p><strong>get方法的定义是：</strong> 方法参数个数为0个，并且 （方法名字以”get”开头 或者 方法名字以”is”开头并且方法的返回类型为boolean）</p>
<p><strong>set方法的定义是：</strong>方法参数个数为1个，并且 （方法名字以”set”开头并且方法返回类型为void）</p>
<p>所以，Spring在通过byName的自动填充属性时流程是：</p>
<ol>
<li>找到所有set方法所对应的XXX部分的名字</li>
<li>根据XXX部分的名字去获取bean</li>
</ol>
<p>Spring在通过byType的自动填充属性时流程是：</p>
<ol>
<li>获取到set方法中的唯一参数的参数类型，并且根据该类型去容器中获取bean</li>
<li>如果找到多个，会报错。</li>
</ol>
</blockquote>
<p>以上，分析了autowire的byType和byName情况，那么接下来分析constructor，constructor表示通过构造方法注入，其实这种情况就比较简单了，没有byType和byName那么复杂。</p>
<p>如果是constructor，那么就可以不写set方法了，当某个bean是通过构造方法来注入时，spring利用构造方法的参数信息从Spring容器中去找bean，找到bean之后作为参数传给构造方法，从而实例化得到一个bean对象，并完成属性赋值（属性赋值的代码得程序员来写）。</p>
<p>我们这里先不考虑一个类有多个构造方法的情况，后面单独讲<strong>推断构造方法</strong>。我们这里只考虑只有一个有参构造方法。</p>
<p>其实构造方法注入相当于byType+byName，普通的byType是根据set方法中的参数类型去找bean，找到多个会报错，而constructor就是通过构造方法中的参数类型去找bean，如果找到多个会根据参数名确定。</p>
<p>另外两个：</p>
<ol>
<li>no，表示关闭autowire</li>
<li>default，表示默认值，我们一直演示的某个bean的autowire，而也可以直接在<beans>标签中设置autowire，如果设置了，那么<bean>标签中设置的autowire如果为default，那么则会用<beans>标签中设置的autowire。</beans></bean></beans></li>
</ol>
<p>可以发现XML中的自动注入是挺强大的，那么问题来了，<strong>为什么我们平时都是用的@Autowired注解呢？而没有用上文说的这种自动注入方式呢？</strong></p>
<p>@Autowired注解相当于XML中的autowire属性的<strong>注解方式的替代</strong>。这是在官网上有提到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Essentially, the <span class="meta">@Autowired</span> annotation provides the same capabilities as described in Autowiring Collaborators but with more fine-grained control and wider applicability</span><br></pre></td></tr></table></figure>


<p>翻译一下：<br>从本质上讲，@Autowired注解提供了与autowire相同的功能，但是拥有更细粒度的控制和更广泛的适用性。</p>
<p>注意：<strong>更细粒度的控制</strong>。</p>
<p>XML中的autowire控制的是整个bean的所有属性，而@Autowired注解是直接写在某个属性、某个set方法、某个构造方法上的。</p>
<p>再举个例子，如果一个类有多个构造方法，那么如果用XML的autowire=constructor，你无法控制到底用哪个构造方法，而你可以用@Autowired注解来直接指定你想用哪个构造方法。</p>
<p>同时，用@Autowired注解，还可以控制，哪些属性想被自动注入，哪些属性不想，这也是细粒度的控制。</p>
<p>但是@Autowired无法区分byType和byName，@Autowired是先byType，如果找到多个则byName。</p>
<p>那么XML的自动注入底层其实也就是:</p>
<ol>
<li>set方法注入</li>
<li>构造方法注入</li>
</ol>
<h4 id="2-2-Autowired注解的自动注入"><a href="#2-2-Autowired注解的自动注入" class="headerlink" title="2.2 @Autowired注解的自动注入"></a>2.2 @Autowired注解的自动注入</h4><blockquote>
<p>上文说了@Autowired注解，是byType和byName的结合。</p>
<p>@Autowired注解可以写在：</p>
<ol>
<li>属性上：先根据<strong>属性类型</strong>去找Bean，如果找到多个再根据<strong>属性名</strong>确定一个</li>
<li>构造方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li>
<li>set方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li>
</ol>
</blockquote>
<blockquote>
<p>而这种底层到了：</p>
<ol>
<li>属性注入</li>
<li>set方法注入</li>
<li>构造方法注入</li>
</ol>
</blockquote>
<ul>
<li><strong>寻找注入点</strong></li>
</ul>
<p>在创建一个Bean的过程中，Spring会利用AutowiredAnnotationBeanPostProcessor的**postProcessMergedBeanDefinition()**找出注入点并缓存，找注入点的流程为：</p>
<ol>
<li>遍历当前类的所有的属性字段Field</li>
<li>查看字段上是否存在@Autowired、@Value、@Inject中的其中任意一个，存在则认为该字段是一个注入点</li>
<li>如果字段是static的，则不进行注入</li>
<li>获取@Autowired中的required属性的值</li>
<li>将字段信息构造成一个<strong>AutowiredFieldElement对象</strong>，作为一个<strong>注入点对象</strong>添加到currElements集合中。</li>
<li>遍历当前类的所有方法Method</li>
<li>判断当前Method是否是<strong>桥接方法</strong>，如果是找到原方法</li>
<li>查看方法上是否存在@Autowired、@Value、@Inject中的其中任意一个，存在则认为该方法是一个注入点</li>
<li>如果方法是static的，则不进行注入</li>
<li>获取@Autowired中的required属性的值</li>
<li>将方法信息构造成一个<strong>AutowiredMethodElement对象</strong>，作为一个<strong>注入点对象</strong>添加到currElements集合中。</li>
<li>遍历完当前类的字段和方法后，将<strong>遍历父类</strong>的，直到没有父类。</li>
<li>最后将currElements集合封装成一个InjectionMetadata对象，作为当前Bean对于的注入点集合对象，并缓存。</li>
</ol>
<ul>
<li>static的字段或方法为什么不支持</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test123&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面代码，UserService和OrderService都是原型Bean，假设Spring支持static字段进行自动注入，那么现在调用两次</p>
<ol>
<li>UserService userService1 = context.getBean(“userService”)</li>
<li>UserService userService2 = context.getBean(“userService”)</li>
</ol>
<p>问此时，userService1的orderService值是什么？还是它自己注入的值吗？</p>
<p>答案是不是，一旦userService2 创建好了之后，static orderService字段的值就发生了修改了，从而出现bug。</p>
<ul>
<li><strong>桥接方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserInterface</span>&lt;<span class="title">OrderService</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test123&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>UserService对应的字节码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature Ljava/lang/Object;Lcom/zhouyu/service/UserInterface&lt;Lcom/zhouyu/service/OrderService;&gt;;</span></span><br><span class="line"><span class="comment">// declaration: com/zhouyu/service/UserService implements com.zhouyu.service.UserInterface&lt;com.zhouyu.service.OrderService&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>/<span class="title">zhouyu</span>/<span class="title">service</span>/<span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">com</span>/<span class="title">zhouyu</span>/<span class="title">service</span>/<span class="title">UserInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: UserService.java</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Lorg</span>/springframework/stereotype/Component;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="keyword">private</span> Lcom/zhouyu/service/OrderService; orderService</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">12</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/zhouyu/service/UserService; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setOrderService</span><span class="params">(Lcom/zhouyu/service/OrderService;)</span>V</span></span><br><span class="line"><span class="function">  @Lorg/springframework/beans/factory/annotation/Autowired</span>;()</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">19</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    PUTFIELD com/zhouyu/service/UserService.orderService : Lcom/zhouyu/service/OrderService;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">20</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/zhouyu/service/UserService; L0 L2 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE orderService Lcom/zhouyu/service/OrderService; L0 L2 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 23 L0</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    LDC <span class="string">&quot;test123&quot;</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">24</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/zhouyu/service/UserService; L0 L2 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1041</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synthetic bridge <span class="title">setOrderService</span><span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">  @Lorg/springframework/beans/factory/annotation/Autowired</span>;()</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">11</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    CHECKCAST com/zhouyu/service/OrderService</span><br><span class="line">    INVOKEVIRTUAL com/zhouyu/service/UserService.setOrderService (Lcom/zhouyu/service/OrderService;)V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> Lcom/zhouyu/service/UserService; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到在UserSerivce的字节码中有两个setOrderService方法：</p>
<ol>
<li> public setOrderService(Lcom/zhouyu/service/OrderService;)V</li>
<li> public synthetic bridge setOrderService(Ljava/lang/Object;)V</li>
</ol>
<p>并且都是存在@Autowired注解的。</p>
<p>所以在Spring中需要处理这种情况，当遍历到桥接方法时，得找到原方法。</p>
<ul>
<li><strong>注入点进行注入</strong></li>
</ul>
<blockquote>
<p>Spring在AutowiredAnnotationBeanPostProcessor的**postProcessProperties()**方法中，会遍历所找到的注入点依次进行注入。</p>
</blockquote>
<p><strong>字段注入</strong></p>
<blockquote>
<ol>
<li>遍历所有的<strong>AutowiredFieldElement对象。</strong></li>
<li>将对应的字段封装为<strong>DependencyDescriptor对象</strong>。</li>
<li>调用BeanFactory的resolveDependency()方法，传入<strong>DependencyDescriptor对象</strong>，进行依赖查找，找到当前字段所匹配的Bean对象。</li>
<li>将<strong>DependencyDescriptor对象</strong>和所找到的<strong>结果对象beanName</strong>封装成一个<strong>ShortcutDependencyDescriptor对象</strong>作为缓存，比如如果当前Bean是原型Bean，那么下次再来创建该Bean时，就可以直接拿缓存的结果对象beanName去BeanFactory中去那bean对象了，不用再次进行查找了</li>
<li>利用反射将结果对象赋值给字段。</li>
</ol>
</blockquote>
<p> <strong>Set方法注入</strong></p>
<blockquote>
<ol>
<li>遍历所有的<strong>AutowiredMethodElement对象</strong></li>
<li>遍历将对应的方法的参数，将每个参数封装成<strong>MethodParameter对象</strong></li>
<li>将<strong>MethodParameter对象</strong>封装为<strong>DependencyDescriptor对象</strong></li>
<li>调用BeanFactory的resolveDependency()方法，传入<strong>DependencyDescriptor对象</strong>，进行依赖查找，找到当前方法参数所匹配的Bean对象。</li>
<li>将<strong>DependencyDescriptor对象</strong>和所找到的<strong>结果对象beanName</strong>封装成一个<strong>ShortcutDependencyDescriptor对象</strong>作为缓存，比如如果当前Bean是原型Bean，那么下次再来创建该Bean时，就可以直接拿缓存的结果对象beanName去BeanFactory中去那bean对象了，不用再次进行查找了</li>
<li>利用反射将找到的所有结果对象传给当前方法，并执行。</li>
</ol>
</blockquote>
<p><a href="https://www.processon.com/view/link/62f51fe4637689072eaf1851">Spring 生命周期_持续补充</a></p>
<p><a href="https://www.processon.com/view/link/62f69b2d0e3e740754f8bb69">Spring思维导图_持续补充</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之配置类解析源码解析</title>
    <url>/2022/08/01/02-00-07-Spring%E4%B9%8B%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Spring之配置类解析源码解析过程"><a href="#Spring之配置类解析源码解析过程" class="headerlink" title="Spring之配置类解析源码解析过程"></a>Spring之配置类解析源码解析过程</h1><blockquote>
<ol>
<li>在启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装为一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。</li>
<li>ConfigurationClassPostProcessor中会把配置类BeanDefinition取出来</li>
<li>构造一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass</li>
<li>如果配置类上存在@Component注解，那么<strong>解析配置类中的内部类（这里有递归，如果内部类也是配置类的话）</strong></li>
<li>如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去</li>
<li>如果配置类上存在@ComponentScan注解，那么则解析该注解，进行扫描，扫描得到一系列的BeanDefinition对象，然后判断这些BeanDefinition是不是也是配置类BeanDefinition（只要存在@Component注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，<strong>（也有递归）</strong>，并且会生成对应的ConfigurationClass</li>
<li>如果配置类上存在@Import注解，那么则判断Import的类的类型：<ol>
<li>如果是ImportSelector，那么调用执行selectImports方法得到类名，然后在把这个类当做配置类进行解析<strong>（也是递归）</strong></li>
<li>如果是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的<strong>importBeanDefinitionRegistrars</strong>属性中。</li>
</ol>
</li>
<li>如果配置类上存在@ImportResource注解，那么则把导入进来的资源路径存在配置类对象中的<strong>importedResources</strong>属性中。</li>
<li>如果配置类中存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的<strong>beanMethods</strong>属性中。</li>
<li>如果配置类实现了某些接口，则看这些接口内是否定义了@Bean的默认方法</li>
<li>如果配置类有父类，则把父类当做配置类进行解析</li>
<li>AppConfig这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass<ol>
<li>如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition</li>
<li>如果ConfigurationClass中存在一些BeanMethod，也就是定义了一些@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册</li>
<li>如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition</li>
<li>如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ol>
<li>解析AppConfig类，生成对应的ConfigurationClass</li>
<li>再扫描，扫描到的类都会生成对应的BeanDefinition，并且同时这些类也是ConfigurationClass</li>
<li>再解析ConfigurationClass的其他信息，比如@ImportResource注解的处理，@Import注解的处理，@Bean注解的处理</li>
</ol>
</blockquote>
<h1 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h1><p><a href="https://www.processon.com/view/link/62b34904637689074ac6d48a">Spring整体流程图</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之AOP底层源码</title>
    <url>/2022/08/15/02-00-09-Spring%E4%B9%8BAOP%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Spring之AOP底层源码"><a href="#Spring之AOP底层源码" class="headerlink" title="Spring之AOP底层源码"></a>Spring之AOP底层源码</h1><h2 id="1-ProxyFactory选择cglib或jdk动态代理原理"><a href="#1-ProxyFactory选择cglib或jdk动态代理原理" class="headerlink" title="1.ProxyFactory选择cglib或jdk动态代理原理"></a>1.ProxyFactory选择cglib或jdk动态代理原理</h2><p>ProxyFactory在生成代理对象之前需要决定到底是使用JDK动态代理还是CGLIB技术：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config就是ProxyFactory对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// optimize为true,或proxyTargetClass为true,或用户没有给ProxyFactory对象添加interface</span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">	Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">	<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">				<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// targetClass是接口，直接使用Jdk动态代理</span></span><br><span class="line">	<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 使用Cglib</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Jdk动态代理</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、代理对象创建过程"><a href="#2、代理对象创建过程" class="headerlink" title="2、代理对象创建过程"></a>2、代理对象创建过程</h2><ul>
<li><strong>JdkDynamicAopProxy</strong></li>
</ul>
<ol>
<li>在构造JdkDynamicAopProxy对象时，会先拿到被代理对象自己所实现的接口，并且额外的增加SpringProxy、Advised、DecoratingProxy三个接口，组合成一个Class[]，并赋值给proxiedInterfaces属性</li>
<li>并且检查这些接口中是否定义了equals()、hashcode()方法</li>
<li>执行<code>Proxy.newProxyInstance(classLoader, this.proxiedInterfaces, this)</code>，得到代理对象，<strong>JdkDynamicAopProxy</strong>作为InvocationHandler，代理对象在执行某个方法时，会进入到JdkDynamicAopProxy的**invoke()**方法中</li>
</ol>
<ul>
<li><strong>ObjenesisCglibAopProxy</strong></li>
</ul>
<ol>
<li>创建Enhancer对象</li>
<li>设置Enhancer的superClass为通过ProxyFactory.setTarget()所设置的对象的类</li>
<li>设置Enhancer的interfaces为通过ProxyFactory.addInterface()所添加的接口，以及SpringProxy、Advised、DecoratingProxy接口</li>
<li>设置Enhancer的Callbacks为DynamicAdvisedInterceptor</li>
<li>最后创建一个代理对象，代理对象在执行某个方法时，会进入到DynamicAdvisedInterceptor的intercept()方法中</li>
</ol>
<h2 id="3、代理对象执行过程"><a href="#3、代理对象执行过程" class="headerlink" title="3、代理对象执行过程"></a>3、代理对象执行过程</h2><ol>
<li>在使用ProxyFactory创建代理对象之前，需要往ProxyFactory先添加Advisor</li>
<li>代理对象在执行某个方法时，会把ProxyFactory中的Advisor拿出来和当前正在执行的方法进行匹配筛选</li>
<li>把和方法所匹配的Advisor适配成MethodInterceptor</li>
<li>把和当前方法匹配的MethodInterceptor链，以及被代理对象、代理对象、代理类、当前Method对象、方法参数封装为MethodInvocation对象</li>
<li>调用MethodInvocation的proceed()方法，开始执行各个MethodInterceptor以及被代理对象的对应方法</li>
<li>按顺序调用每个MethodInterceptor的invoke()方法，并且会把MethodInvocation对象传入invoke()方法</li>
<li>直到执行完最后一个MethodInterceptor了，就会调用invokeJoinpoint()方法，从而执行被代理对象的当前方法</li>
</ol>
<h3 id="3-1各注解对应的MethodInterceptor"><a href="#3-1各注解对应的MethodInterceptor" class="headerlink" title="3.1各注解对应的MethodInterceptor"></a>3.1各注解对应的MethodInterceptor</h3><ul>
<li><strong>@Before</strong>对应的是AspectJMethodBeforeAdvice，在进行动态代理时会把AspectJMethodBeforeAdvice转成<strong>MethodBeforeAdviceInterceptor</strong><ul>
<li>先执行advice对应的方法</li>
<li>再执行MethodInvocation的proceed()，会执行下一个Interceptor，如果没有下一个Interceptor了，会执行target对应的方法</li>
</ul>
</li>
<li><strong>@After</strong>对应的是AspectJAfterAdvice，直接实现了<strong>MethodInterceptor</strong><ul>
<li>先执行MethodInvocation的proceed()，会执行下一个Interceptor，如果没有下一个Interceptor了，会执行target对应的方法</li>
<li>再执行advice对应的方法</li>
</ul>
</li>
<li><strong>@Around</strong>对应的是AspectJAroundAdvice，直接实现了<strong>MethodInterceptor</strong><ul>
<li>直接执行advice对应的方法，由@Around自己决定要不要继续往后面调用</li>
</ul>
</li>
<li><strong>@AfterThrowing</strong>对应的是AspectJAfterThrowingAdvice，直接实现了<strong>MethodInterceptor</strong><ul>
<li>先执行MethodInvocation的proceed()，会执行下一个Interceptor，如果没有下一个Interceptor了，会执行target对应的方法</li>
<li>如果上面抛了Throwable，那么则会执行advice对应的方法</li>
</ul>
</li>
<li><strong>@AfterReturning</strong>对应的是AspectJAfterReturningAdvice，在进行动态代理时会把AspectJAfterReturningAdvice转成<strong>AfterReturningAdviceInterceptor</strong><ul>
<li>先执行MethodInvocation的proceed()，会执行下一个Interceptor，如果没有下一个Interceptor了，会执行target对应的方法</li>
<li>执行上面的方法后得到最终的方法的返回值</li>
<li>再执行Advice对应的方法</li>
</ul>
</li>
</ul>
<h2 id="4、AbstractAdvisorAutoProxyCreator"><a href="#4、AbstractAdvisorAutoProxyCreator" class="headerlink" title="4、AbstractAdvisorAutoProxyCreator"></a>4、AbstractAdvisorAutoProxyCreator</h2><p>DefaultAdvisorAutoProxyCreator的父类是AbstractAdvisorAutoProxyCreator。</p>
<p><strong>AbstractAdvisorAutoProxyCreator</strong>非常强大以及重要，只要Spring容器中存在这个类型的Bean，就相当于开启了AOP，AbstractAdvisorAutoProxyCreator实际上就是一个BeanPostProcessor，所以在创建某个Bean时，就会进入到它对应的生命周期方法中，比如：在某个Bean<strong>初始化之后</strong>，会调用wrapIfNecessary()方法进行AOP，底层逻辑是，AbstractAdvisorAutoProxyCreator会找到所有的Advisor，然后判断当前这个Bean是否存在某个Advisor与之匹配（根据Pointcut），如果匹配就表示当前这个Bean有对应的切面逻辑，需要进行AOP，需要产生一个代理对象。</p>
<h3 id="4-1-EnableAspectJAutoProxy"><a href="#4-1-EnableAspectJAutoProxy" class="headerlink" title="4.1 @EnableAspectJAutoProxy"></a>4.1 @EnableAspectJAutoProxy</h3><p>这个注解主要就是往Spring容器中添加了一个AnnotationAwareAspectJAutoProxyCreator类型的Bean。<br><img src="/2022/08/15/02-00-09-Spring%E4%B9%8BAOP%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/1628753226288-643a0eb5-c2a9-4d8a-9d22-a5a47a6ffb0c.png" alt="AnnotationAwareAspectJAutoProxyCreator.png"><br><strong>AspectJAwareAdvisorAutoProxyCreator</strong>继承了<strong>AbstractAdvisorAutoProxyCreator</strong>，重写了findCandidateAdvisors()方法，<strong>AbstractAdvisorAutoProxyCreator</strong>只能找到所有Advisor类型的Bean对象，但是<strong>AspectJAwareAdvisorAutoProxyCreator</strong>除开可以找到所有Advisor类型的Bean对象，还能把@Aspect注解所标注的Bean中的@Before等注解及方法进行解析，并生成对应的Advisor对象。</p>
<p>所以，我们可以理解@EnableAspectJAutoProxy，其实就是像Spring容器中添加了一个AbstractAdvisorAutoProxyCreator类型的Bean，从而开启了AOP，并且还会解析@Before等注解生成Advisor。</p>
<p><a href="https://www.processon.com/view/link/62fa64a3f346fb3fe99bf318">Spring AOP之ProxyFactory原理</a></p>
<p><a href="https://www.processon.com/view/link/62f69b2d0e3e740754f8bb69">Spring AOP思维导图</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之事务底层源码解析</title>
    <url>/2022/08/17/02-00-10-Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Spring之事务底层源码解析"><a href="#Spring之事务底层源码解析" class="headerlink" title="Spring之事务底层源码解析"></a>Spring之事务底层源码解析</h1><h2 id="1、-EnableTransactionManagement工作原理"><a href="#1、-EnableTransactionManagement工作原理" class="headerlink" title="1、 @EnableTransactionManagement工作原理"></a>1、 @EnableTransactionManagement工作原理</h2><p>开启Spring事务本质上就是增加了一个Advisor，但我们使用@EnableTransactionManagement注解来开启Spring事务是，该注解代理的功能就是向Spring容器中添加了两个Bean：</p>
<ol>
<li>AutoProxyRegistrar</li>
<li>ProxyTransactionManagementConfiguration</li>
</ol>
<p>AutoProxyRegistrar主要的作用是向Spring容器中注册了一个<strong>InfrastructureAdvisorAutoProxyCreator</strong>的Bean。<br>而InfrastructureAdvisorAutoProxyCreator继承了<strong>AbstractAdvisorAutoProxyCreator</strong>，所以这个类的主要作用就是<strong>开启自动代理</strong>的作用，也就是一个BeanPostProcessor，会在初始化后步骤中去寻找Advisor类型的Bean，并判断当前某个Bean是否有匹配的Advisor，是否需要利用动态代理产生一个代理对象。</p>
<p>ProxyTransactionManagementConfiguration是一个配置类，它又定义了另外三个bean：</p>
<ol>
<li>BeanFactoryTransactionAttributeSourceAdvisor：一个Advisor</li>
<li>AnnotationTransactionAttributeSource：相当于BeanFactoryTransactionAttributeSourceAdvisor中的Pointcut</li>
<li>TransactionInterceptor：相当于BeanFactoryTransactionAttributeSourceAdvisor中的Advice</li>
</ol>
<p><strong>AnnotationTransactionAttributeSource</strong>就是用来判断某个类上是否存在@Transactional注解，或者判断某个方法上是否存在@Transactional注解的。</p>
<p><strong>TransactionInterceptor</strong>就是代理逻辑，当某个类中存在@Transactional注解时，到时就产生一个代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到TransactionInterceptor的invoke()方法。</p>
<h2 id="2、Spring事务基本执行原理"><a href="#2、Spring事务基本执行原理" class="headerlink" title="2、Spring事务基本执行原理"></a>2、Spring事务基本执行原理</h2><p>一个Bean在执行Bean的创建生命周期时，会经过InfrastructureAdvisorAutoProxyCreator的初始化后的方法，会判断当前当前Bean对象是否和BeanFactoryTransactionAttributeSourceAdvisor匹配，匹配逻辑为判断该Bean的类上是否存在@Transactional注解，或者类中的某个方法上是否存在@Transactional注解，如果存在则表示该Bean需要进行动态代理产生一个代理对象作为Bean对象。</p>
<p>该代理对象在执行某个方法时，会再次判断当前执行的方法是否和BeanFactoryTransactionAttributeSourceAdvisor匹配，如果匹配则执行该Advisor中的TransactionInterceptor的invoke()方法，执行基本流程为：</p>
<ol>
<li>利用所配置的PlatformTransactionManager事务管理器新建一个数据库连接</li>
<li>修改数据库连接的autocommit为false</li>
<li>执行MethodInvocation.proceed()方法，简单理解就是执行业务方法，其中就会执行sql</li>
<li>如果没有抛异常，则提交</li>
<li>如果抛了异常，则回滚</li>
</ol>
<h2 id="3、Spring事务传播机制"><a href="#3、Spring事务传播机制" class="headerlink" title="3、Spring事务传播机制"></a>3、Spring事务传播机制</h2><p>在开发过程中，经常会出现一个方法调用另外一个方法，那么这里就涉及到了多种场景，比如a()调用b()：</p>
<ol>
<li>a()和b()方法中的所有sql需要在同一个事务中吗？</li>
<li>a()和b()方法需要单独的事务吗？</li>
<li>a()需要在事务中执行，b()还需要在事务中执行吗？</li>
<li>等等情况…</li>
</ol>
<p>所以，这就要求Spring事务能支持上面各种场景，这就是Spring事务传播机制的由来。那Spring事务传播机制是如何实现的呢?</p>
<p>先来看上述几种场景中的一种情况，a()在一个事务中执行，调用b()方法时需要新开一个事务执行：</p>
<ol>
<li>首先，代理对象执行a()方法前，先利用事务管理器新建一个数据库连接a</li>
<li>将数据库连接a的autocommit改为false</li>
<li>把数据库连接a设置到ThreadLocal中</li>
<li>执行a()方法中的sql</li>
<li>执行a()方法过程中，调用了b()方法（注意用代理对象调用b()方法）<ol>
<li>代理对象执行b()方法前，判断出来了当前线程中已经存在一个数据库连接a了，表示当前线程其实已经拥有一个Spring事务了，则进行<strong>挂起</strong></li>
<li>挂起就是把ThreadLocal中的数据库连接a从ThreadLocal中移除，并放入一个<strong>挂起资源对象</strong>中</li>
<li>挂起完成后，再次利用事务管理器新建一个数据库连接b</li>
<li>将数据库连接b的autocommit改为false</li>
<li>把数据库连接b设置到ThreadLocal中</li>
<li>执行b()方法中的sql</li>
<li>b()方法正常执行完，则从ThreadLocal中拿到数据库连接b进行提交</li>
<li>提交之后会恢复所挂起的数据库连接a，这里的恢复，其实只是把在<strong>挂起资源对象</strong>中所保存的数据库连接a再次设置到ThreadLocal中</li>
</ol>
</li>
<li>a()方法正常执行完，则从ThreadLocal中拿到数据库连接a进行提交</li>
</ol>
<p>这个过程中最为核心的是：<strong>在执行某个方法时，判断当前是否已经存在一个事务，就是判断当前线程的ThreadLocal中是否存在一个数据库连接对象，如果存在则表示已经存在一个事务了。</strong></p>
<h2 id="4、Spring事务传播机制分类"><a href="#4、Spring事务传播机制分类" class="headerlink" title="4、Spring事务传播机制分类"></a>4、Spring事务传播机制分类</h2><p><strong>其中，以非事务方式运行，表示以非Spring事务运行，表示在执行这个方法时，Spring事务管理器不会去建立数据库连接，执行sql时，由Mybatis或JdbcTemplate自己来建立数据库连接来执行sql。</strong></p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// test方法中的sql</span></span><br><span class="line">		userService.a();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a方法中的sql</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下传播机制为<strong>REQUIRED，表示当前如果没有事务则新建一个事务，如果有事务则在当前事务中执行。</strong></p>
<hr>
<p>所以上面这种情况的执行流程如下：</p>
<ol>
<li>新建一个数据库连接conn</li>
<li>设置conn的autocommit为false</li>
<li>执行test方法中的sql</li>
<li>执行a方法中的sql</li>
<li>执行conn的commit()方法进行提交</li>
</ol>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><p>假如是这种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// test方法中的sql</span></span><br><span class="line">		userService.a();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a方法中的sql</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以上面这种情况的执行流程如下：</p>
<ol>
<li>新建一个数据库连接conn</li>
<li>设置conn的autocommit为false</li>
<li>执行test方法中的sql</li>
<li>执行a方法中的sql</li>
<li>抛出异常</li>
<li>执行conn的rollback()方法进行回滚，所以两个方法中的sql都会回滚掉</li>
</ol>
<h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><p>假如是这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// test方法中的sql</span></span><br><span class="line">		userService.a();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a方法中的sql</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以上面这种情况的执行流程如下：</p>
<ol>
<li>新建一个数据库连接conn</li>
<li>设置conn的autocommit为false</li>
<li>执行test方法中的sql</li>
<li>执行a方法中的sql</li>
<li>抛出异常</li>
<li>执行conn的rollback()方法进行回滚，所以两个方法中的sql都会回滚掉</li>
</ol>
<h3 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h3><p>如果是这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// test方法中的sql</span></span><br><span class="line">		userService.a();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a方法中的sql</span></span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以上面这种情况的执行流程如下：</p>
<ol>
<li>新建一个数据库连接conn</li>
<li>设置conn的autocommit为false</li>
<li>执行test方法中的sql</li>
<li>又新建一个数据库连接conn2</li>
<li>执行a方法中的sql</li>
<li>抛出异常</li>
<li>执行conn2的rollback()方法进行回滚</li>
<li><strong>继续抛异常，对于test()方法而言，它会接收到一个异常，然后抛出</strong></li>
<li>执行conn的rollback()方法进行回滚，最终还是两个方法中的sql都回滚了</li>
</ol>
<h2 id="Spring事务强制回滚"><a href="#Spring事务强制回滚" class="headerlink" title="Spring事务强制回滚"></a>Spring事务强制回滚</h2><p>正常情况下，a()调用b()方法时，如果b()方法抛了异常，但是在a()方法捕获了，那么a()的事务还是会正常提交的，但是有的时候，我们捕获异常可能仅仅只是不把异常信息返回给客户端，而是为了返回一些更友好的错误信息，而这个时候，我们还是希望事务能回滚的，那这个时候就得告诉Spring把当前事务回滚掉，做法就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		b();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="comment">// 构造友好的错误信息返回</span></span><br><span class="line">		TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TransactionSynchronization"><a href="#TransactionSynchronization" class="headerlink" title="TransactionSynchronization"></a>TransactionSynchronization</h2><p>Spring事务有可能会提交，回滚、挂起、恢复，所以Spring事务提供了一种机制，可以让程序员来监听当前Spring事务所处于的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronization() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test被挂起了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test被恢复了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test准备要提交了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test准备要提交或回滚了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test提交成功了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test提交或回滚成功了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		jdbcTemplate.execute(<span class="string">&quot;insert into t1 values(1,1,1,1,&#x27;1&#x27;)&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">		userService.a();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronization() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;a被挂起了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;a被恢复了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;a准备要提交了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;a准备要提交或回滚了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;a提交成功了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;a提交或回滚成功了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		jdbcTemplate.execute(<span class="string">&quot;insert into t1 values(2,2,2,2,&#x27;2&#x27;)&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人总结：</p>
<p><a href="https://www.processon.com/view/link/62f69b2d0e3e740754f8bb69">Spring事务思维导图</a></p>
<p><a href="https://www.processon.com/view/link/62fbcc536376892ade4bb9a9">Spring事务流程图</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring 事务</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 请求源码流程</title>
    <url>/2022/08/05/02-00-11-SpringMVC-%E8%AF%B7%E6%B1%82%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="一、SpringMVC-—请求源码流程"><a href="#一、SpringMVC-—请求源码流程" class="headerlink" title="一、SpringMVC —请求源码流程"></a>一、SpringMVC —请求源码流程</h1><h2 id="1-1传统Servlet："><a href="#1-1传统Servlet：" class="headerlink" title="1.1传统Servlet："></a>1.1<strong>传统Servlet：</strong></h2><p><img src="/2022/08/05/02-00-11-SpringMVC-%E8%AF%B7%E6%B1%82%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B/image-20220708003727958.png" alt="image-20220708003727958"></p>
<blockquote>
<p><strong>弊端：</strong></p>
<p>1.xml下配置servlet的映射非常麻烦 <strong>开发效率低</strong></p>
<p>2.必须要继承父类、重写方法  <strong>侵入性强</strong></p>
<p>2.如果想在一个Servlet中处理同一业务模块的的功能<strong>分发给不同方法进行处理非常麻烦</strong></p>
<p>3.<strong>参数解析麻烦</strong>:单个参数（转换类型）—&gt;pojo对象   Json文本—&gt;pojo对象</p>
<p>4.**数据响应麻烦:**pojo对象—&gt;json  … Content-type</p>
<p>5.跳转页面麻烦,  对path的控制、 如果使用其他模板也很麻烦 、设置编码麻烦…等等…</p>
</blockquote>
<h2 id="1-2-SpringMVC"><a href="#1-2-SpringMVC" class="headerlink" title="1.2 SpringMVC"></a>1.2 <strong>SpringMVC</strong></h2><ul>
<li><p><strong>基于xml的实现方式：</strong></p>
<blockquote>
<p>1.给Servlet容器配置一个DispatcherServlet（web.xml )</p>
<p>2.添加SpringMVC的配置信息</p>
<ul>
<li>继承类/实现接口 方式：</li>
</ul>
<p> implements HttpRequestHandler  implements Controller</p>
<p>  不同的<em>HandlerMapping</em></p>
<p>​       simpleController        </p>
</blockquote>
</li>
<li><p><strong>注解方式：</strong></p>
<p>配置控制器@Controller和处理方法的映射—@RequstMapping 即可</p>
<p>其实SpringMVC请求原理很简单：说白了就是用一个DispatcherServlet 封装了一个Servlet的调度中心， 由调度中心帮我们调用我们的处理方法：</p>
<p>在这个过程中调度中心委托给各个组件执行具体工作 ，比如帮我们映射方法请求、帮我解析参数、调用处理方法、响应数据和页面 等</p>
<p>这就相当于你在家自己做饭和去饭店吃饭的区别了， 在家你买菜、洗菜、蒸饭、炒菜、洗碗都得自己来.</p>
<p>饭店都给你做好了， 你只要分服务员说你吃什么、就能得到响应.   殊不知呢， 你只是说了吃什么（请求）， 后厨（DispatcherServlet）就有配菜员你给找到菜单-对应的食材（映射） 、切菜员切菜（解析参数）、  厨师给你炒菜（调用处理方法）、装盘（处理返回值)、 抄完给你端出来（响应）</p>
</li>
</ul>
<h2 id="1-3-SpringMVC的具体执行流程："><a href="#1-3-SpringMVC的具体执行流程：" class="headerlink" title="1.3 SpringMVC的具体执行流程："></a>1.3 <strong>SpringMVC的具体执行流程：</strong></h2><blockquote>
<p>Spring MVC 是围绕前端控制器模式设计的，其中：中央 Servlet DispatcherServlet 为请求处理流程提供统一调度，实际工作则交给可配置组件执行。这个模型是灵活的且开放的，我们可以通过自己去定制这些组件从而进行定制自己的工作流。</p>
</blockquote>
<p><img src="/2022/08/05/02-00-11-SpringMVC-%E8%AF%B7%E6%B1%82%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B/image-20220708003908626.png" alt="image-20220708003908626"></p>
<blockquote>
<p>DispatcherServlet： 前端调度器 ， 负责将请求拦截下来分发到各控制器方法中</p>
<p>HandlerMapping: 负责根据请求的URL和配置@RequestMapping映射去匹配， 匹配到会返回Handler（具体控制器的方法）</p>
<p>HandlerAdaper: 负责调用Handler-具体的方法- 返回视图的名字 Handler将它封装到ModelAndView(封装视图名，request域的数据）</p>
<p>ViewReslover: 根据ModelAndView里面的视图名地址去找到具体的jsp封装在View对象中</p>
<p>View：进行视图渲染（将jsp转换成html内容 –这是Servlet容器的事情了） 最终response到的客户端</p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li>
</ol>
<ul>
<li><ol>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li>
</ol>
</li>
</ul>
<ol>
<li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter,执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li>
<li>执行处理器Handler(Controller，也叫页面控制器)。</li>
</ol>
<ul>
<li><ol>
<li>Handler执行完成返回ModelAndView</li>
<li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li>
</ol>
</li>
</ul>
<ol>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
</ol>
<ul>
<li><ol>
<li>ViewReslover解析后返回具体View</li>
</ol>
</li>
</ul>
<ol>
<li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
</blockquote>
<h2 id="1-4-核心流程"><a href="#1-4-核心流程" class="headerlink" title="1.4 核心流程"></a>1.4 核心流程</h2><blockquote>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
</ol>
<ul>
<li>​    由于它是个Servlet会先进入service方法——&gt;doGet/doPost——&gt;processRequestdoService——&gt;doDispatch ↓</li>
<li>​    这个doDispatch非常重要–体现了整个请求流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 文件上传相关</span></span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         multipartRequestParsed = (processedRequest != request);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// DispatcherServlet收到请求调用处理器映射器HandlerMapping。</span></span><br><span class="line">        <span class="comment">// 处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="number">4.</span>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter,</span><br><span class="line">         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Process last-modified header, if supported by the handler.  HTTP缓存相关</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">         <span class="keyword">boolean</span> isGet = HttpMethod.GET.matches(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 前置拦截器</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="comment">// 返回false就不进行后续处理了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</span></span><br><span class="line">         <span class="comment">// 执行处理器Handler(Controller，也叫页面控制器)。</span></span><br><span class="line">         <span class="comment">// Handler执行完成返回ModelAndView</span></span><br><span class="line">         <span class="comment">// HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果没有视图，给你设置默认视图  json忽略</span></span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">         <span class="comment">//后置拦截器</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">         <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">         dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// DispatcherServlet将ModelAndView传给ViewReslover视图解析器</span></span><br><span class="line">      <span class="comment">// ViewReslover解析后返回具体View</span></span><br><span class="line">      <span class="comment">// DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</span></span><br><span class="line">      <span class="comment">// DispatcherServlet响应用户。</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">         <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>HandlerMapping</strong></p>
<p>在整个过程中，涉及到非常多的组件，每个组件解析各个环节，其中<strong>HandlerMapping最为重要它是用来映射请求的</strong>，我们就着重介绍下HandlerMapping的解析过程和请求映射过程：</p>
</blockquote>
<p><img src="/2022/08/05/02-00-11-SpringMVC-%E8%AF%B7%E6%B1%82%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B/image-20220804204214198.png" alt="image-20220804204214198"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis配置文件解析</title>
    <url>/2022/08/08/02-01-00-MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="一、使用示例"><a href="#一、使用示例" class="headerlink" title="一、使用示例"></a>一、使用示例</h1><ul>
<li><strong>JDBC</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pstmt=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建连接</span></span><br><span class="line">        conn= DriverManager.</span><br><span class="line">                getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_example&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SQL语句</span></span><br><span class="line">        String sql=<span class="string">&quot;select id,user_name,create_time from t_user where id=?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得sql执行者</span></span><br><span class="line">        pstmt=conn.prepareStatement(sql);</span><br><span class="line">        pstmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行查询 执行sql操作</span></span><br><span class="line">        <span class="comment">//ResultSet rs= pstmt.executeQuery();</span></span><br><span class="line">        pstmt.execute();</span><br><span class="line">        <span class="comment">// 得到数据库操作结果集</span></span><br><span class="line">        ResultSet rs= pstmt.getResultSet();</span><br><span class="line"></span><br><span class="line">        rs.next();</span><br><span class="line">        <span class="comment">// 结果封装成pojo对象</span></span><br><span class="line">        User user =<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setUserName(rs.getString(<span class="string">&quot;user_name&quot;</span>));</span><br><span class="line">        user.setCreateTime(rs.getDate(<span class="string">&quot;create_time&quot;</span>));</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pstmt!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pstmt.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么说MyBatis是半自动的ORM框架？</p>
<p>MyBatis是一个持久层的ORM框架，使用简单，学习成本较低。可以执行自己手写的SQL语句，比较灵活。但是MyBatis的自动化程度不高，移植性也不高，有时从一个数据库迁移到另外一个数据库的时候需要自己修改配置，所以称只为半自动ORM框架</p>
<p><strong>JDBC四大核心对象</strong></p>
<ul>
<li>DriverManager（创建连接）</li>
<li>Connection（连接）</li>
<li>PreparedStatement</li>
<li>ResultSet</li>
</ul>
</blockquote>
<ul>
<li><p>MyBatis</p>
<blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">//将XML配置文件构建为Configuration配置类</span></span><br><span class="line">        Reader reader = Resources.getResourceAsReader(resource);</span><br><span class="line">        <span class="comment">// 通过加载配置文件流构建一个SqlSessionFactory   解析xml文件  1</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源 执行器  DefaultSqlSession 2</span></span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行查询 底层执行jdbc 3</span></span><br><span class="line">            User user =  session.selectOne(<span class="string">&quot;com.tuling.mapper.UserMapper.selectById&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建动态代理</span></span><br><span class="line">           <span class="comment">/* UserMapper mapper = session.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">            System.out.println(mapper.getClass());</span></span><br><span class="line"><span class="comment">            User user = mapper.selectById(1);*/</span></span><br><span class="line">            System.out.println(user.getUserName());</span><br><span class="line"></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            session.rollback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h1 id="二、Jdbc-VS-MyBatis"><a href="#二、Jdbc-VS-MyBatis" class="headerlink" title="二、Jdbc VS MyBatis"></a>二、Jdbc VS MyBatis</h1><p><strong>JDBC弊端</strong></p>
<p><strong>传统JDBC的问题如下：</strong></p>
<p>1.数据库连接创建，释放频繁造成系统资源的浪费，从而影响系统性能，使用数据库连接池可以解决问题。</p>
<p>2.sql语句在代码中硬编码，造成代码的不易维护，实际应用中sql的变化可能较大，sql代码和java代码没有分离开来维护不方便。</p>
<p>3.使用preparedStatement向有占位符传递参数存在硬编码问题因为sql中的where子句的条件不确定，同样是修改不方便/</p>
<p>4.对结果集中解析存在硬编码问题，sql的变化导致解析代码的变化，系统维护不方便。</p>
<p>5.Jdbc没有提供缓存功能</p>
<p><strong>mybatis对传统的JDBC的解决方案</strong></p>
<p>1、数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p>
<p>解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。</p>
<p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p>
<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>
<p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。</p>
<p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>
<p>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</p>
<p>5、Jdbc提供了一二级缓存功能</p>
<h1 id="三、MyBatis解析配置文件源码"><a href="#三、MyBatis解析配置文件源码" class="headerlink" title="三、MyBatis解析配置文件源码"></a>三、MyBatis解析配置文件源码</h1><p><strong>MyBatis BaseBuilder结构</strong></p>
<p><img src="/2022/08/08/02-01-00-MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/image-20220808212020906.png" alt="image-20220808212020906"></p>
<blockquote>
<ul>
<li>XMLConfigBuilder：解析XML全局配置文件mybatis-config.xml</li>
<li>XMLStatementBuilder：解析mapper文件</li>
<li>SqlSourceBuilder：解析Sql语句</li>
<li>XMLStatementBuilder：解析mapper.xml映射文件中的节点，如select、insert、等节点</li>
</ul>
</blockquote>
<p>简述MyBatis动态sql的解析流程?</p>
<blockquote>
<p>动态Sql会通过组合者设计模式， 把每一行Sql解析成一个SqlNode的实现类（如 WhereSqlNode、IfSqlNode、TextSqlNode….）。  在执行数据库操作时通过参数再递归通过SqlNode.apply() 进行解析， 最终组合成一个sql语句</p>
</blockquote>
<p>mapper接口注解解析过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new SqlSessionFactoryBuilder().build(reader)</span><br><span class="line">&gt;parser.parse()</span><br><span class="line">&gt;parseConfiguration(parser.evalNode(&quot;/configuration&quot;))</span><br><span class="line">&gt;mapperElement(root.evalNode(&quot;mappers&quot;))</span><br><span class="line">&gt;configuration.addMappers(mapperPackage)</span><br><span class="line">&gt;mapperRegistry.addMappers(packageName)</span><br><span class="line">&gt;addMapper(mapperClass)</span><br><span class="line">&gt;MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type)</span><br><span class="line">&gt;parser.parse()</span><br><span class="line">&gt;Method[] methods = type.getMethods()</span><br><span class="line">&gt;for (Method method : methods)</span><br><span class="line">&gt;parseStatement(method)</span><br></pre></td></tr></table></figure>

<p>SQL语句解析之后对象是这样：</p>
<p><img src="/2022/08/08/02-01-00-MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/image-20220809003651081.png" alt="image-20220809003651081"></p>
<p>由SqlNode递归解析生成最后的SQL语句</p>
<p><img src="/2022/08/08/02-01-00-MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/image-20220809004905186.png" alt="image-20220809004905186"></p>
<p><strong>源码跟踪</strong></p>
<p><a href="https://www.processon.com/view/link/62f12c441e0853714d3e98ef">MyBatis配置文件解析源码</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis核心数据结构实战</title>
    <url>/2022/05/30/03-00-00-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Redis核心数据结构与高性能原理"><a href="#一、Redis核心数据结构与高性能原理" class="headerlink" title="一、Redis核心数据结构与高性能原理"></a>一、Redis核心数据结构与高性能原理</h2><h3 id="1、Redis五大数据结构"><a href="#1、Redis五大数据结构" class="headerlink" title="1、Redis五大数据结构"></a>1、Redis五大数据结构</h3><h4 id="1-1-string-字符串"><a href="#1-1-string-字符串" class="headerlink" title="1.1 string 字符串"></a>1.1 string 字符串</h4><ul>
<li><strong>字符串常用操作：</strong></li>
</ul>
<blockquote>
<p>set key value // 存入字符串键值对</p>
<p>get key // 获取一个字符串键值</p>
<p>mset key value [key value] // 批量存储字符串键值对</p>
<p>mget key [key…] // 批量获取字符串键值</p>
<p>setnx key value  // 存入一个不存在的字符串键值对</p>
<p>del  key  [key …]  // 删除一个键</p>
<p>EXPIRE  key  seconds // 设置一个键的过期时间(秒)</p>
</blockquote>
<ul>
<li><strong>原子加减</strong></li>
</ul>
<blockquote>
<p>incr key // 将key中储存的数字值加1</p>
<p>decr key // 将key中储存的数字值减1</p>
<p>incrby  key  increment // 将key所储存的值加上increment</p>
<p>decrby  key  decrement // 将key所储存的值减去decrement</p>
</blockquote>
<h4 id="1-2-字符串应用场景"><a href="#1-2-字符串应用场景" class="headerlink" title="1.2 字符串应用场景"></a>1.2 字符串应用场景</h4><ul>
<li><p>单值缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br></pre></td></tr></table></figure></li>
<li><p>对象缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) SET  user:1  value(json格式数据)</span><br><span class="line">2) MSET  user:1:name  zhangsan   user:1:balance  1888</span><br><span class="line">   MGET  user:1:name   user:1:balance </span><br></pre></td></tr></table></figure></li>
<li><p>分布式锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETNX  product:10001  true 		//返回1代表获取锁成功</span><br><span class="line">SETNX  product:10001  true 		//返回0代表获取锁失败</span><br><span class="line">。。。执行业务操作</span><br><span class="line">DEL  product:10001			//执行完业务释放锁</span><br><span class="line">SET product:10001 true  ex  10  nx	//防止程序意外终止导致死锁 ex:过期时间单位为秒  px:过期时间单位为毫秒  nx：不存在才设置</span><br></pre></td></tr></table></figure></li>
<li><p>计数器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCR article:readcount:&#123;文章id&#125;  	</span><br><span class="line">GET article:readcount:&#123;文章id&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Web集群session共享</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring session + redis实现session共享</span><br></pre></td></tr></table></figure></li>
<li><p>分布式系统全局序列号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCRBY  orderId  1000		//redis批量生成序列号提升性能</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-Hash数据结构"><a href="#1-3-Hash数据结构" class="headerlink" title="1.3 Hash数据结构"></a>1.3 Hash数据结构</h4><ul>
<li><p>hash常用操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSET  key  field  value 			<span class="comment">//存储一个哈希表key的键值</span></span><br><span class="line">HSETNX  key  field  value 		<span class="comment">//存储一个不存在的哈希表key的键值</span></span><br><span class="line">HMSET  key  field  value [field value ...] 	<span class="comment">//在一个哈希表key中存储多个键值对</span></span><br><span class="line">HGET  key  field 				<span class="comment">//获取哈希表key对应的field键值</span></span><br><span class="line">HMGET  key  field  [field ...] 		<span class="comment">//批量获取哈希表key中多个field键值</span></span><br><span class="line">HDEL  key  field  [field ...] 		<span class="comment">//删除哈希表key中的field键值</span></span><br><span class="line">HLEN  key				<span class="comment">//返回哈希表key中field的数量</span></span><br><span class="line">HGETALL  key				<span class="comment">//返回哈希表key中所有的键值</span></span><br><span class="line">HINCRBY  key  field  increment 		<span class="comment">//为哈希表key中field键的值加上增量increment</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-4-Hash数据结构"><a href="#1-4-Hash数据结构" class="headerlink" title="1.4 Hash数据结构"></a>1.4 Hash数据结构</h4><ul>
<li>hash数据结构的应用场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HMSET  user  &#123;userId&#125;:name  zhuge  &#123;userId&#125;:balance  <span class="number">1888</span></span><br><span class="line">HMSET  user  <span class="number">1</span>:name  zhuge  <span class="number">1</span>:balance  <span class="number">1888</span></span><br><span class="line">HMGET  user  <span class="number">1</span>:name  <span class="number">1</span>:balance  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>电商购物车</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）以用户id为key</span><br><span class="line"><span class="number">2</span>）商品id为field</span><br><span class="line"><span class="number">3</span>）商品数量为value</span><br><span class="line"></span><br><span class="line">购物车操作</span><br><span class="line">添加商品-&gt;hset cart:<span class="number">1001</span> <span class="number">10088</span> <span class="number">1</span></span><br><span class="line">增加数量-&gt;hincrby cart:<span class="number">1001</span> <span class="number">10088</span> <span class="number">1</span></span><br><span class="line">商品总数-&gt;hlen cart:<span class="number">1001</span></span><br><span class="line">删除商品-&gt;hdel cart:<span class="number">1001</span> <span class="number">10088</span></span><br><span class="line">获取购物车所有商品-&gt;hgetall cart:<span class="number">1001</span></span><br></pre></td></tr></table></figure></li>
<li><p>Hash结构优缺点</p>
<ul>
<li><p>优点</p>
<p>1）同类数据归类整合储存，方便数据管理<br>2）相比string操作消耗内存与cpu更小<br>3）相比string储存更节省空间</p>
</li>
<li><p>缺点</p>
<p>1）过期功能不能使用在field上，只能用在key上<br>2）Redis集群架构下不适合大规模使用</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-5-List数据结构"><a href="#1-5-List数据结构" class="headerlink" title="1.5 List数据结构"></a>1.5 List数据结构</h4><ul>
<li><p>List常用操作</p>
<blockquote>
<p>LPUSH  key  value [value …]         //将一个或多个值value插入到key列表的表头(最左边)<br>RPUSH  key  value [value …]         //将一个或多个值value插入到key列表的表尾(最右边)<br>LPOP  key            //移除并返回key列表的头元素<br>RPOP  key            //移除并返回key列表的尾元素<br>LRANGE  key  start  stop        //返回列表key中指定区间内的元素，区间以偏移量start和stop指定<br>BLPOP  key  [key …]  timeout    //从key列表表头弹出一个元素，若列表中没有元素，阻塞等待                    timeout秒,如果timeout=0,一直阻塞等待<br>BRPOP  key  [key …]  timeout     //从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待                    timeout秒,如果timeout=0,一直阻塞等待</p>
</blockquote>
</li>
<li><p>List应用场景</p>
<blockquote>
<p>Stack(栈) = LPUSH + LPOP<br>Queue(队列）= LPUSH + RPOP<br>Blocking MQ(阻塞队列）= LPUSH + BRPOP</p>
<p>微博和微信公众号引流</p>
</blockquote>
</li>
</ul>
<h4 id="1-5-Set数据结构"><a href="#1-5-Set数据结构" class="headerlink" title="1.5 Set数据结构"></a>1.5 Set数据结构</h4><ul>
<li><p>Set常用操作</p>
<blockquote>
<p>SADD  key  member  [member …]            //往集合key中存入元素，元素存在则忽略， 若key不存在则新建<br>SREM  key  member  [member …]            //从集合key中删除元素<br>SMEMBERS  key                    //获取集合key中所有元素<br>SCARD  key                    //获取集合key的元素个数<br>SISMEMBER  key  member            //判断member元素是否存在于集合key中<br>SRANDMEMBER  key  [count]            //从集合key中选出count个元素，元素不从key中删除<br>SPOP  key  [count]                //从集合key中选出count个元素，元素从key中删除</p>
</blockquote>
</li>
<li><p>Set运算操作</p>
<blockquote>
<p>SINTER  key  [key …]                 //交集运算<br>SINTERSTORE  destination  key  [key ..]        //将交集结果存入新集合destination中<br>SUNION  key  [key ..]                 //并集运算<br>SUNIONSTORE  destination  key  [key …]        //将并集结果存入新集合destination中<br>SDIFF  key  [key …]                 //差集运算<br>SDIFFSTORE  destination  key  [key …]        //将差集结果存入新集合destination中</p>
</blockquote>
</li>
<li><p>Set应用场景</p>
<ul>
<li><p>微信抽奖小程序</p>
<blockquote>
<p>1）点击参与抽奖加入集合<br>SADD key {userlD}<br>2）查看参与抽奖所有用户<br>SMEMBERS key<br>3）抽取count名中奖者<br>SRANDMEMBER key [count] / SPOP key [count]</p>
</blockquote>
</li>
<li><p>微信微博点赞，收藏，标签</p>
<blockquote>
<ol>
<li>点赞<br>SADD  like:{消息ID}  {用户ID}</li>
<li>取消点赞<br>SREM like:{消息ID}  {用户ID}</li>
<li>检查用户是否点过赞<br>SISMEMBER  like:{消息ID}  {用户ID}</li>
<li>获取点赞的用户列表<br>SMEMBERS like:{消息ID}</li>
<li>获取点赞用户数<br>SCARD like:{消息ID}</li>
</ol>
</blockquote>
</li>
<li><p>集合操作</p>
<blockquote>
<p>set1{a，b，c}     set2{b，c，d}    set3{c，d，e}</p>
</blockquote>
<blockquote>
<p>SINTER set1 set2 set3  { c }<br>SUNION set1 set2 set3  { a,b,c,d,e }<br>SDIFF set1 set2 set3  { a }</p>
</blockquote>
</li>
</ul>
</li>
<li><p>微博/微信关注模型</p>
<blockquote>
<ol>
<li>诸葛老师关注的人:<br>zhugeSet-&gt; {guojia, xushu}</li>
<li>杨过老师关注的人:<br>yangguoSet–&gt; {zhuge, baiqi, guojia, xushu}</li>
<li>郭嘉老师关注的人:<br>guojiaSet-&gt; {zhuge, yangguo, baiqi, xushu, xunyu)</li>
<li>我和杨过老师共同关注:<br>SINTER zhugeSet yangguoSet–&gt; {guojia, xushu}</li>
<li>我关注的人也关注他(杨过老师):<br>SISMEMBER guojiaSet yangguo<br>SISMEMBER xushuSet yangguo</li>
<li>我可能认识的人:<br>SDIFF yangguoSet zhugeSet-&gt;(zhuge, baiqi}</li>
</ol>
</blockquote>
</li>
<li><p>集合操作实现电商商品筛选</p>
<blockquote>
<p>SADD  brand:huawei  P40<br>SADD  brand:xiaomi  mi-10<br>SADD  brand:iPhone iphone12<br>SADD os:android  P40  mi-10<br>SADD cpu:brand:intel  P40  mi-10<br>SADD ram:8G  P40  mi-10  iphone12<br>SINTER  os:android  cpu:brand:intel  ram:8G -&gt;  {P40，mi-10}</p>
</blockquote>
</li>
</ul>
<h4 id="1-6-ZSet数据结构"><a href="#1-6-ZSet数据结构" class="headerlink" title="1.6 ZSet数据结构"></a>1.6 ZSet数据结构</h4><ul>
<li><p>ZSet常用操作</p>
<blockquote>
<p>ZADD key score member [[score member]…]    //往有序集合key中加入带分值元素<br>ZREM key member [member …]        //从有序集合key中删除元素<br>ZSCORE key member             //返回有序集合key中元素member的分值<br>ZINCRBY key increment member        //为有序集合key中元素member的分值加上increment<br>ZCARD key                //返回有序集合key中元素个数<br>ZRANGE key start stop [WITHSCORES]    //正序获取有序集合key从start下标到stop下标的元素<br>ZREVRANGE key start stop [WITHSCORES]    //倒序获取有序集合key从start下标到stop下标的元素</p>
</blockquote>
</li>
<li><p>Zset集合操作</p>
<p>ZUNIONSTORE destkey numkeys key [key …]     //并集计算<br>ZINTERSTORE destkey numkeys key [key …]    //交集计算</p>
</li>
<li><p>Zset集合操作实现排行榜</p>
<blockquote>
<p>1）点击新闻<br>ZINCRBY  hotNews:20190819  1  守护香港<br>2）展示当日排行前十<br>ZREVRANGE  hotNews:20190819  0  9  WITHSCORES<br>3）七日搜索榜单计算<br>ZUNIONSTORE  hotNews:20190813-20190819  7<br>hotNews:20190813  hotNews:20190814… hotNews:20190819<br>4）展示七日排行前十<br>ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</p>
</blockquote>
</li>
</ul>
<h3 id="2、Redis高性能原理"><a href="#2、Redis高性能原理" class="headerlink" title="2、Redis高性能原理"></a>2、Redis高性能原理</h3><p>​    问题1：Redis是单线程的吗？</p>
<p>​    Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如    持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src/redis-benchmark get <span class="comment">// 压测get指令 单机qps理论上可以达到10w</span></span><br></pre></td></tr></table></figure>

<p>​    问题2：Redis为什么那么快？</p>
<p>​    因为它所有的数据都在<strong>内存</strong>中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为 Redis 是单线程，所以要小心使用     Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。 </p>
<p>​    问题3：<strong>Redis 单线程如何处理那么多的并发客户端连接？</strong></p>
<p>​    Redis的<strong>IO多路复用</strong>：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p>
<p>​    问题4：Redis如何正确遍历key</p>
<p>​    1&gt;keys * 命令：<strong>全量遍历键</strong>，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用</p>
<p>​    2&gt;<strong>scan：渐进式遍历键</strong></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>中间件</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring整合Mybatis</title>
    <url>/2022/08/10/02-02-02-Spring%E6%95%B4%E5%90%88Mybatis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h1><h2 id="1、Spring整合Mybatis核心配置类"><a href="#1、Spring整合Mybatis核心配置类" class="headerlink" title="1、Spring整合Mybatis核心配置类"></a>1、Spring整合Mybatis核心配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.tuling.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.tuling&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;    <span class="comment">// =====&gt;   spring.xml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt;  &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sqlSessionFactory&quot;&gt;</span></span><br><span class="line"><span class="comment">    *     datasource</span></span><br><span class="line"><span class="comment">    *     mapper文件的路径</span></span><br><span class="line"><span class="comment">    *     别名</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *   &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *   &lt;mapper-scan basePackage=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span>    <span class="comment">// =====  &gt;    &lt;bean  class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">( )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">      factoryBean.setDataSource(dataSource());</span><br><span class="line">      <span class="comment">// 设置 MyBatis 配置文件路径</span></span><br><span class="line">      factoryBean.setConfigLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;mybatis/mybatis-config.xml&quot;</span>));</span><br><span class="line">      <span class="comment">// 设置 SQL 映射文件路径</span></span><br><span class="line">      factoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath:mybatis/mapper/*.xml&quot;</span>));</span><br><span class="line">      factoryBean.setTypeAliases(User.class);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> factoryBean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_example&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、Mybatis-调用mapper接口的方法过程"><a href="#2、Mybatis-调用mapper接口的方法过程" class="headerlink" title="2、Mybatis 调用mapper接口的方法过程"></a>2、Mybatis 调用mapper接口的方法过程</h2><p><a href="https://www.processon.com/view/link/62f3c450e0b34d3a87d7cb58">Spring整合Mybatis</a></p>
<h2 id="3、Spring整合Mybatis的几种可行思路"><a href="#3、Spring整合Mybatis的几种可行思路" class="headerlink" title="3、Spring整合Mybatis的几种可行思路"></a>3、Spring整合Mybatis的几种可行思路</h2><ul>
<li>@Component注解在mapper接口上：不可用，spring启动过程会忽略接口类型的类，无法生成Beandefinition</li>
<li>@Bean：可以通过jdk动态代理生成接口类的bean，缺点：多个mapper类无法使用@Bean</li>
<li>@Import：可以实现多个类的注入spring容易，但是是spring 4.x提供的，mybatis在之前就有了，因出现时间原因mybatis无法使用此种方式</li>
<li>BeandifinitonRegistryPostProcessor：可以做到，配合BeandefinitonScanner进行扫描，重写ClassPathBeanDefinitionScanner类的isCompatible()方法</li>
<li>BeanPostProcessor：可以，较为麻烦。</li>
<li>FactoryBean：mybatis就是用的这种，比较灵活，bean生成可以自己控制。<strong>可以使用的思路</strong>。</li>
<li>设置Beandefinition的FactoryMethodName：设置工厂方法，配合Beandefinition使用，<strong>可以使用的思路</strong>。</li>
</ul>
<p>最后使用的是factoryBean，详细流程图见上图。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化、主从与哨兵架构</title>
    <url>/2022/05/31/03-00-01-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Redis持久化"><a href="#一、Redis持久化" class="headerlink" title="一、Redis持久化"></a>一、Redis持久化</h2><h3 id="1、redis持久化方式"><a href="#1、redis持久化方式" class="headerlink" title="1、redis持久化方式"></a>1、redis持久化方式</h3><ul>
<li><p><strong>RDB快照（snapshot）</strong></p>
<p>配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># save <span class="number">60</span> <span class="number">1000</span>  (释：60s内<span class="number">1000</span>次改动)   <span class="comment">//关闭RDB只需要将所有的save保存策略注释掉即可 </span></span><br><span class="line"># save <span class="number">900</span> <span class="number">1</span></span><br><span class="line"># save <span class="number">300</span> <span class="number">10</span></span><br><span class="line"># save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line">## 可以配置多条 只要一条满足就会做持久化</span><br></pre></td></tr></table></figure>

<p>手动执行命令进行rdb快照：</p>
<p>save </p>
<p>bgsave</p>
<p>两种方式对比：</p>
<p><strong>save与bgsave对比：</strong></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>save</strong></th>
<th><strong>bgsave</strong></th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞redis其它命令</td>
<td>是</td>
<td>否(在生成子进程执行调用fork函数时会有短暂阻塞)</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>主线程执行，阻塞客户端命令</td>
<td>需要fork子进程，消耗内存</td>
</tr>
</tbody></table>
<p><strong>配置自动生成rdb文件后台使用的是bgsave方式。</strong></p>
<p><strong>RDB持久化缺点:</strong></p>
<p><strong>可能会丢数据：在redis执行了几条修改命令 但是没有达到rdb持久化条件，然后redis又宕机的情况，这种会发生数据丢失</strong></p>
</li>
<li><p><strong>AOF（append-only file）</strong></p>
<p>记录执行的修改的redis指令</p>
<p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># appendonly yes</span><br></pre></td></tr></table></figure>

<p><strong>AOF重写</strong></p>
<p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># auto-aof-rewrite-min-size 64mb   <span class="comment">//aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</span></span><br><span class="line"># auto-aof-rewrite-percentage <span class="number">100</span>  <span class="comment">//aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br></pre></td></tr></table></figure>

<p>当然AOF还可以手动重写，进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF</p>
<p>注意，<strong>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p>
<p><strong>注：如果同时开启了rdb和aof持久化，那么它在持久化的时候会同时进行rdb和aof持久化</strong></p>
</li>
<li><p><strong>Redis 4.0 混合持久化</strong></p>
<p>混合持久化的前提是开启aof持久化</p>
<p>配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># aof-use-rdb-preamble yes  </span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>如果开启了混合持久化，<strong>AOF在重写时</strong>，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写<strong>这一刻之前</strong>的内存做RDB快照处理，并且将RDB快照内容和<strong>增量的</strong>AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</p>
<p>于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。</p>
</li>
<li><p>Redis数据备份策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近<span class="number">48</span>小时的备份</span><br><span class="line">每天都保留一份当日的数据备份到一个目录中去，可以保留最近<span class="number">1</span>个月的备份</span><br><span class="line">每次copy备份的时候，都把太旧的备份给删了</span><br><span class="line">每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二、Redis主从与哨兵架构"><a href="#二、Redis主从与哨兵架构" class="headerlink" title="二、Redis主从与哨兵架构"></a>二、Redis主从与哨兵架构</h2><h3 id="2-1-Redis的主从架构原理"><a href="#2-1-Redis的主从架构原理" class="headerlink" title="2.1 Redis的主从架构原理"></a>2.1 Redis的主从架构原理</h3><ul>
<li>全量复制</li>
</ul>
<p><img src="/2022/05/31/03-00-01-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84/image-20220601001339115.png" alt="image-20220601001339115"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 说明</span><br><span class="line">master收到PSYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加载到内存中。然后，master再将之前缓存在内存中的命令发送给slave。</span><br><span class="line">当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master，如果master收到了多个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。</span><br><span class="line">主从复制(全量复制)流程图：   默认主从同步使用rdb，跟是否开启rdb持久化无关</span><br></pre></td></tr></table></figure>

<ul>
<li><p>部分复制（断点续传）</p>
<p><img src="/2022/05/31/03-00-01-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84/image-20220601001436858.png" alt="image-20220601001436858"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 说明</span><br><span class="line">当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2<span class="number">.8</span>版本开始，redis改用可以支持部分数据复制的命令PSYNC去master同步数据，slave与master能够在网络连接断开重连后只进行部分数据复制(断点续传)。</span><br><span class="line">master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变化了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。</span><br></pre></td></tr></table></figure>

<p><strong>主从复制风暴问题：</strong></p>
<p>描述：一个主节点配置了多个从节点，多个从节点同时请求向主节点复制数据，这就是主从复制风暴</p>
<p>解决：其它从节点可以从另外的从节点复制数据</p>
<p><img src="/2022/05/31/03-00-01-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84/image-20220601001600409.png" alt="image-20220601001600409"></p>
<p><strong>管道（Pipeline）操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">客户端可以一次性发送多个请求而不用等待服务器的响应，待所有命令都发送完后再一次性读取服务的响应，这样可以极大的降低多条命令执行的网络传输开销，管道执行多条命令的网络开销实际上只相当于一次命令执行的网络开销。需要注意到是用pipeline方式打包命令发送，redis必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。</span><br><span class="line">pipeline中发送的每个command都会被server立即执行，如果执行失败，将会在此后的响应中得到信息；也就是pipeline并不是表达“所有command都一起成功”的语义，管道中前面命令失败，后面命令不会有影响，继续执行。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Redis哨兵高可用架构"><a href="#2-2-Redis哨兵高可用架构" class="headerlink" title="2.2 Redis哨兵高可用架构"></a>2.2 Redis哨兵高可用架构</h3><p><img src="/2022/05/31/03-00-01-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84/image-20220601001807563.png" alt="image-20220601001807563"></p>
<p>哨兵的好处：</p>
<p>主节点挂掉之后，可以自动切换主节点，</p>
<p>缺点：</p>
<p>主从切换的过程，会丢数据</p>
<p>** 哨兵集群搭建 **</p>
<p>我搭的哨兵集群，无法自动切换主节点，很奇怪，折腾了很长时间，有时间再查具体原因</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>中间件</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>持久化</tag>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis底层核心数据结构&amp;Redis6新特性【下】</title>
    <url>/2022/06/06/03-00-04-Redis%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%90%E4%B8%8B%E3%80%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Redis底层核心数据结构-amp-Redis6新特性"><a href="#Redis底层核心数据结构-amp-Redis6新特性" class="headerlink" title="Redis底层核心数据结构&amp;Redis6新特性"></a>Redis底层核心数据结构&amp;Redis6新特性</h2><h3 id="1、List底层数据结构"><a href="#1、List底层数据结构" class="headerlink" title="1、List底层数据结构"></a>1、List底层数据结构</h3>]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用集群</title>
    <url>/2022/06/01/03-00-06-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Redis高可用集群"><a href="#一、Redis高可用集群" class="headerlink" title="一、Redis高可用集群"></a>一、Redis高可用集群</h2><h3 id="1-1-几种集群方案比较"><a href="#1-1-几种集群方案比较" class="headerlink" title="1.1 几种集群方案比较"></a>1.1 几种集群方案比较</h3><ul>
<li><strong>哨兵模式</strong></li>
</ul>
<p>示意图：</p>
<p><img src="/2022/06/01/03-00-06-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/image-20220602004453441.png" alt="image-20220602004453441"></p>
<p>优缺点:</p>
<blockquote>
<p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率</p>
</blockquote>
<ul>
<li><strong>高可用集群模式</strong></li>
</ul>
<p>示意图：</p>
<p><img src="/2022/06/01/03-00-06-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/image-20220602004545445.png" alt="image-20220602004545445"></p>
<p>优缺点：</p>
<blockquote>
<p>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵·也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(<strong>官方推荐不超过1000个节点</strong>)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单 </p>
</blockquote>
<h3 id="1-2Redis集群原理分析"><a href="#1-2Redis集群原理分析" class="headerlink" title="1.2Redis集群原理分析"></a>1.2<strong>Redis集群原理分析</strong></h3><blockquote>
<p>Redis Cluster通过分片技术，将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整</p>
</blockquote>
<p><strong>槽位定位算法</strong></p>
<blockquote>
<p>crc16 算法算出hash值</p>
<p>在对16384取模</p>
</blockquote>
<p><strong>跳转重定位</strong></p>
<blockquote>
<p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p>
</blockquote>
<h3 id="1-3-Redis集群节点间的通信机制（采取gossip协议进行通信）"><a href="#1-3-Redis集群节点间的通信机制（采取gossip协议进行通信）" class="headerlink" title="1.3 Redis集群节点间的通信机制（采取gossip协议进行通信）"></a>1.3 Redis集群节点间的通信机制（采取gossip协议进行通信）</h3><p><strong>通信方式：</strong></p>
<ul>
<li><p>集中式</p>
<blockquote>
<p>优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助zookeeper集中式存储元数据。</p>
</blockquote>
</li>
<li><p>gossip</p>
<blockquote>
<p>gossip协议包含多种消息，包括ping，pong，meet，fail等等。 </p>
<p>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；</p>
<p>ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据(类似自己感知到的集群节点增加和移除，hash slot信息等)； </p>
<p>pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新； </p>
<p>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
<p>gossip通信的10000端口(自己提供服务的端口号+10000)</p>
</blockquote>
</li>
</ul>
<p><strong>网络抖动</strong></p>
<blockquote>
<p>Redis Cluster 提供了一种选项cluster-node-timeout【节点超时时间】，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p>
</blockquote>
<h3 id="1-4-Redis集群选举原理分析"><a href="#1-4-Redis集群选举原理分析" class="headerlink" title="1.4 Redis集群选举原理分析"></a>1.4 Redis集群选举原理分析</h3><p><strong>过程：</strong></p>
<blockquote>
<p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p>
<p>1.slave发现自己的master变为FAIL【可能所有的从节点都会向主节点发送消息】</p>
<p>2.将自己记录的集群currentEpoch（选举周期）加1，并广播FAILOVER_AUTH_REQUEST（错误转移请求） 信息</p>
<p>3.其他节点收到该信息，只有master响应，判断请求者的合法性（是否是选主信息），并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p>
<p>【在一个选举周期内，master只响应第一个发起选主请求的slave】</p>
<p>4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK</p>
<p>5.slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</p>
<p>【如果真有巧合，几个从节点收到的master的ack数目相等，则会重新发起选举】</p>
<p>6.slave广播Ping消息通知其他集群节点。</p>
</blockquote>
<p><strong>选举的延迟机制</strong></p>
<ul>
<li>延迟计算公式：</li>
</ul>
<p> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p>
<p>【这个公式可以达到包含最新的数据的slave节点，优先发起选举】</p>
<ul>
<li>SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</li>
</ul>
<p><strong>集群脑裂数据丢失问题</strong></p>
<blockquote>
<p>【集群脑裂，网络恢复，数据丢失】</p>
<p>redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p>
<p><strong>举例说明：</strong></p>
<p><strong>一个小主从集群：A（master）、B（slave）、C（slave）</strong></p>
<p><strong>当A、B、C出现网络分区，从节点会选举为主节点，比如C当选主节点；在网络恢复前，A和C都可以写入数据，相当于有多个主节点；那么当A网络恢复，A会成为C的从节点，A的数据会被抹去，那么会有部分写入A中的数据（B、C没有写入的）会被抹除，从而出现数据丢失；</strong></p>
<p><strong>如果配置了以下参数，A出现分区时，连接不上B和C，所以数据无法写入A，但是能写入C，因为C有一个从节点B</strong></p>
</blockquote>
<p>规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">min-replicas-to-write <span class="number">1</span>  <span class="comment">//写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span></span><br></pre></td></tr></table></figure>

<p><strong>这个配置值需满足：这个配置值 + 1（leader数量）&gt;（节点数量）/2 + 1</strong></p>
<p><strong>上面参数的具体意思是：主节点写入了数据，至少同步了一个从节点，才会返回给客户端写入成功</strong></p>
<p>如果没有从节点可以，写入主节点数据就会提示</p>
<p><img src="/2022/06/01/03-00-06-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/image-20220602005337110.png" alt="image-20220602005337110"></p>
<h3 id="1-6-Redis的几个参数"><a href="#1-6-Redis的几个参数" class="headerlink" title="1.6 Redis的几个参数"></a>1.6 Redis的几个参数</h3><ul>
<li><p>cluster-require-full-coverage</p>
<blockquote>
<p>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线且没有相应的从库进行故障恢复时，集群仍然可用，如果为yes则集群不可用。</p>
<p>【当三个主从小集群，有一个没有主节点时，整个集群不可用】</p>
</blockquote>
</li>
<li><p><strong>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数</strong></p>
<blockquote>
<p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p>
<p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是<strong>从节省机器资源角度出发</strong>说的。</p>
<p>【如果只有两个master，则一个master挂了，这个master在做选举的时候，因为不满足半数，无法选举主节点；</p>
<p>并且如果有三个节点，那么最多允许挂一个主节点；如果有四个节点，最多也是允许挂一个节点，从资源节省角度来看，奇数个更合适】</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>分布式</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis底层核心数据结构&amp;Redis6新特性【上】</title>
    <url>/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Redis核心数据结构-amp-Redis6新特性"><a href="#Redis核心数据结构-amp-Redis6新特性" class="headerlink" title="Redis核心数据结构&amp;Redis6新特性"></a>Redis核心数据结构&amp;Redis6新特性</h2><h3 id="1、Redis-C底层数据结构"><a href="#1、Redis-C底层数据结构" class="headerlink" title="1、Redis C底层数据结构"></a>1、Redis C底层数据结构</h3><ul>
<li><p>Redis 字符串</p>
<blockquote>
<p>Redis底层C语言实现的，c语言字符串底层是字符数组，redis服务端需要跟各种语言打交道，比如java，php，go等，他们的字符串类型都是不可控的，c语言以\0作为字符串结尾，其它语言也有可能有其它的处理。</p>
<p>Redis底层字符串通过SDS（simple dynamic string）来实现【二进制安全的数据结构】</p>
<ul>
<li><p>数据结构</p>
<p>好处：</p>
<p>二进制安全的数据结构</p>
<p>提供了内存预分配机制，避免了频繁的内存分配</p>
<p>兼容c语言的函数库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis <span class="number">3.2</span> 以前</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// 当前长度  4字节 最大为2的32次方-1 比较大 所以3.2之后优化成了多个不同大小的字符串数据结构  </span></span><br><span class="line">    <span class="keyword">int</span> free; <span class="comment">// 剩余可用长度</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line">redis <span class="number">3.2</span> 后</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr5 </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr8 </span>&#123;</span><br><span class="line">    uint8_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint8_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr16 </span>&#123;</span><br><span class="line">    uint16_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint16_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr32 </span>&#123;</span><br><span class="line">    uint32_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint32_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr64 </span>&#123;</span><br><span class="line">........</span><br><span class="line">    </span><br><span class="line">## 举例：</span><br><span class="line">有如下字符串：</span><br><span class="line">sds:</span><br><span class="line">    free:<span class="number">0</span></span><br><span class="line">	len:<span class="number">6</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;zzzaaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;zzzaaa&quot;</span>  ----&gt; <span class="string">&quot;zzzaaaccc&quot;</span></span><br><span class="line">则会计算需要增加的长度：</span><br><span class="line">len = <span class="number">6</span>;addlen = <span class="number">3</span></span><br><span class="line">扩容两倍【长度不超过1M即<span class="number">1024</span>*<span class="number">1024</span>，成倍扩容，超过的化 每次增加1M长度】</span><br><span class="line">（len + addlen） * <span class="number">2</span> = <span class="number">18</span></span><br><span class="line">====&gt;</span><br><span class="line">sds:</span><br><span class="line">    free:<span class="number">9</span></span><br><span class="line">    len:<span class="number">9</span></span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;zzzaaaccc&quot;</span> </span><br><span class="line">====&gt;改为zzzaaaccc123</span><br><span class="line">sds:</span><br><span class="line">    free:<span class="number">6</span></span><br><span class="line">    len:<span class="number">12</span></span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;zzzaaaccc123&quot;</span></span><br><span class="line"></span><br><span class="line">好处：字符串增加不用额外再分配空间</span><br><span class="line">空间换时间 长度只扩大 不缩小                </span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
<li><p>RedisDB：redis 数据库，select db</p>
</li>
<li><p>Dict：字典，所有的k,v都是存在于字典里面；字典里面包含两个dictht【两个dictht原因是扩容使用，redis的渐进式rehash扩容，当需要扩容时不是一次性将数据迁移过去，而是分多次】，扩容是主线程进行的。</p>
<blockquote>
<p>1.Redis扩容并不是一次性把数据全部迁移到新数组。当然首先会去帮你扩容，扩容完之后，挨个hash桶位进行迁移，这就是渐进式的rehash。</p>
<p>2.动态扩容是指新增的数据会放入新的hashtable中，如果是老数据则先从旧的hashtable中迁移到新的hashtable，会操作两个DB。<br>老DB是用ht[0]指向的，新DB使用ht[1]指向的。如果没有rehash，ht[1]是指向null的。<br>如果有新数据插入，会先在老DB中判断，ht[0]没有就会放入ht[1]里面，ht[0]存在就迁移到ht[1]。</p>
</blockquote>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/358366217">渐进式rehash</a></p>
<p>  dictht：就是一个数组，里面存储的是dictEntity指针，指向dictEntity，dictht默认大小4。当dictht使用的长度达到dictht长度时，则进行扩容。当扩容没有结束时，查询数据会去dictht[0]、doctht[1]中分别查找。</p>
<p>  dictEntity：dictht里面存储的数据，包含 key、value、next【当键发生hash冲突的时候将冲突的值使用next指针指向，并且采用头插法，后面进来的数据放到表头，用来解决hash冲突】；value指向redisObject对象，存放具体的值</p>
<p>  redisObject：封装redis 键值对的值数据的，type：指定用什么类型【string、list、hash、set、zset】，encoding用来表示编码类型【raw、int、embstr、ziplist】、*ptr指向真实存储的位置</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## redis数据结构<span class="comment">// 字典【其它不重要的略过】</span></span><br><span class="line">ReidsDb:</span><br><span class="line">	dict *dict; ---&gt;dict:</span><br><span class="line">				dictht ht[<span class="number">2</span>]; ---&gt;dictEntry:</span><br><span class="line">										  	  *key <span class="comment">// sds</span></span><br><span class="line">                                            *val  <span class="comment">// 存储数据 -------&gt;redisObject:</span></span><br><span class="line">                                            *next <span class="comment">// 解决hash冲突   	type</span></span><br><span class="line">                                                					  encoding</span><br><span class="line">                                                					  *ptr <span class="comment">// 真正指向真实数据-----&gt;	</span></span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/RedisDB%E4%B8%BB%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="RedisDB主体数据结构"></h3><p>redis数据类型</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220605183209350.png" alt="image-20220605183209350"></p>
<ul>
<li><p>bitmap</p>
<p>底层是string数据结构，即sds，通过char[]数组实现，一个数组元素表示8个bit位，bitmap因为基于string，所以最大为512M，长度最大为2的32次方-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设置bitmap  offset位置的值命令：  set key offset value[<span class="number">0</span>/<span class="number">1</span>]   [bit位的值默认是<span class="number">0</span>]</span><br><span class="line">获取bitmap  offset位置的值命令：  get key offset</span><br><span class="line">统计bitmap  位的值为<span class="number">1</span>的数量命令：  bitcount key start end [start end 为起始终止值，单位是字节数]</span><br><span class="line">查询位数字bitmap的字节数命令： strlen key</span><br><span class="line">## 使用场景</span><br><span class="line"><span class="number">1</span>、统计日活，按照每天日期作为key</span><br><span class="line">用户id（数字类型）作为offset</span><br><span class="line"><span class="number">2</span>、连续登录的情况</span><br><span class="line">昨天登录的bitmap</span><br><span class="line">和今天登录的bitmap</span><br><span class="line">命令：bitop and|or  key1 key2 destkey  [bitop是位运算的操作  and|or 表示按位与|或  key1和key2表示他们参与运算   destkey 表示目标结果存储在destkey]</span><br><span class="line">bitmap按位与</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220605193508999.png" alt="bitmap基本操作"></p>
</li>
</ul>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220605195034410.png" alt="bitmap按位与|或"></p>
<h2 id="2、List数据结构"><a href="#2、List数据结构" class="headerlink" title="2、List数据结构"></a>2、List数据结构</h2><p><code>List数据结构</code></p>
<p>List是一个有序的数据结构（按加入的时序排序），Redis采用quicklist（双端链表）和ziplist作为list的底层实现。可以通过设置每个ziplist的最大容量，quicklist的数据压缩范围，提升数据存取效率。</p>
<p><code>List常用操作</code></p>
<p>LPUSH  key  value [value …]         //将一个或多个值value插入到key列表的表头(最左边)</p>
<p>RPUSH  key  value [value …]         //将一个或多个值value插入到key列表的表尾(最右边)</p>
<p>LPOP  key            //移除并返回key列表的头元素</p>
<p>RPOP  key            //移除并返回key列表的尾元素</p>
<p>LRANGE  key  start  stop        //返回列表key中指定区间内的元素，区间以偏移量start和stop指定</p>
<p>BLPOP  key  [key …]  timeout    //从key列表表头弹出一个元素，若列表中没有元素，阻塞等待                    timeout秒,如果timeout=0,一直阻塞等待</p>
<p>BRPOP  key  [key …]  timeout     //从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待                    timeout秒,如果timeout=0,一直阻塞等待</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220409221812515.png" alt="Redis数据结构之List"></p>
<p><code>常用数据结构</code></p>
<p>Stack(栈) = LPUSH + LPOP</p>
<p>Queue(队列）= LPUSH + RPOP</p>
<p>Blocking MQ(阻塞队列）= LPUSH + BRPOP</p>
<p><code>redis List数据结构为什么不用链表实现</code></p>
<p>List数据结构可以使用数组和链表实现，redis底层为什么不用链表来实现list呢？</p>
<ul>
<li>1)胖指针问题，链表需要存储下一个元素指针，这个通常占用较大空间</li>
<li>2)链表数据随机存储，产生大量的内存碎片，没法很好的利用cpu读取内存的空间局部性原理</li>
</ul>
<p><code>ziplist【底层是一段连续的空间】</code></p>
<p>zlbytes：4个字节，标识当前ziplist存多少数据</p>
<p>zltail：4个字节，尾节点的索引的位置，可以通过o(1)的时间复杂度找到尾结点，方便从尾到头遍历</p>
<p>zllen：当前ziplist有多少个元素</p>
<p>zlend：恒等于255，标识数据结尾</p>
<p>entry：包含三个部分，prerawlen：前面元素的信息，方便从前往后，从后往前遍历；len：当前数据的信息，例如类型</p>
<p>ziplist：是一个非常紧凑的二进制数据结构，Redis并没有直接将数据存储在ziplist中。</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/ziplist.png" alt="ziplist"></p>
<blockquote>
<p>每个entry包含三部分：</p>
<ul>
<li>prerawlen：前面一个元素的信息，如果前面要给元素的大小（字节数）小于254，说明前面的元素是比较小的节点，数据量小于254，此时prerawlen占用一个字节（一个字节最大表示255）；如果前面一个元素大于254，用五个字节表示</li>
<li>len：当前元素的信息，表示的信息见上图</li>
<li>data：当前元素的信息</li>
</ul>
<p>为什么这样设计呢？</p>
<p>如果使用链表的 pre,next表示双向链表，因为指针存在胖指针问题（即指针占用空间很大）导致内存被大量使用，所以设计ziplist，可以减轻内存占用</p>
<p>为什么没有直接使用zipList存储元素呢？</p>
<p>ziplist删除和修改比较麻烦，会涉及到多个数据结构的修改。因此采用下面的双端链表来实现。</p>
</blockquote>
<p><code>quicklist双端链表 + ziplist 实现Redis list存储</code></p>
<p>双端链表：把整个ziplist分块，用链表对其关联，每一个链表的节点对应非常多的元素，包含头节点head，尾节点tail;</p>
<p>quicklistNode：存放每个节点的信息</p>
<p>每个ziplist数据越来越多的时候，ziplist也会进行分裂，分裂成多个节点，具体多大就分裂，参考下面配置list-max-ziplist-size参数</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/quicklist.png" alt="quicklist"></p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220409233909847.png"></p>
<h3 id="3、Hash数据结构"><a href="#3、Hash数据结构" class="headerlink" title="3、Hash数据结构"></a>3、Hash数据结构</h3><p>Hash 数据结构底层实现为一个字典( dict ),也是RedisBb用来存储K-V的数据结构,当数据量比较小，或者单个元素比较小时，底层用ziplist存储，数据大小和元素数量阈值可以通过如下参数设置</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220410162948512.png" alt="image-20220410162948512"></p>
<p>hash-max-ziplist-entries  512    //  ziplist 元素个数超过 512 ，将改为hashtable编码 【即使用hashtable存储】<br>hash-max-ziplist-value    64      //  单个元素大小超过 64 byte时，将改为hashtable编码</p>
<p><strong>String和hash两个数据结构的优缺点？</strong></p>
<ul>
<li>频繁使用string数据结构，可能导致redisdb频繁扩容，因为有多个key；而使用hash结构，多个数据公用一个key，不同的field。hash结构一定程度上可以避免频繁扩容。</li>
<li>使用string方便设置过期时间，而hash只能对外层的key设置过期时间，对field无法设置过期时间。</li>
</ul>
<h3 id="4、Set数据结构"><a href="#4、Set数据结构" class="headerlink" title="4、Set数据结构"></a>4、Set数据结构</h3><p>Set 为无序的，自动去重的集合数据类型，Set 数据结构底层实现为一个value 为 null 的 字典( dict ),当数据可以用整形表示时，Set集合将被编码为intset数据结构。两个条件任意满足时<br>Set将用hashtable存储数据。1， 元素个数大于 set-max-intset-entries , 2 ， 元素无法用整形表示 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set-max-intset-entries <span class="number">512</span>       <span class="comment">// intset 能存储的最大元素个数，超过则用hashtable编码</span></span><br></pre></td></tr></table></figure>

<h3 id="5、ZSet数据结构"><a href="#5、ZSet数据结构" class="headerlink" title="5、ZSet数据结构"></a>5、ZSet数据结构</h3><p>ZSet  为有序的，自动去重的集合数据类型，ZSet 数据结构底层实现为 字典(dict) + 跳表(skiplist) ,当数据比较少时，用ziplist编码结构存储。 </p>
<p><strong>ZSet如果用内存连续的数组实现行不行？</strong></p>
<p>不行，数组实现的化，当数据插入或删除时，会有大量的数据移动；所以redis底层采用了链表的方式实现。</p>
<p>ZSet底层是跳表实现：</p>
<p>时间复杂度为logN</p>
<p>跳表是空间换时间的方式。</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220606214824573.png" alt="image-20220606214824573"></p>
<p>ZSet底层采用dict + 跳表实现的：</p>
<blockquote>
<p>dict用于快速查找分值</p>
<p>跳表快速查找数据，实现排序</p>
</blockquote>
<p>Redis底层跳表的实现：</p>
<p>头节点不存储数据，用作索引层。</p>
<p>同一层的数据通过forward指针指向【从前往后遍历】，同时每个节点通过回退指针backword指向【便于从后往前遍历】。</p>
<p>遍历数据时从最高的层高往下遍历。</p>
<p><img src="/2022/04/09/03-00-05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis6%E6%96%B0%E7%89%B9%E6%80%A7/image-20220606220124338.png" alt="image-20220606220124338"></p>
<h3 id="6、GeoHash算法"><a href="#6、GeoHash算法" class="headerlink" title="6、GeoHash算法"></a>6、GeoHash算法</h3><p>GeoHash是一种地理位置编码方法。 由Gustavo Niemeyer 和 G.M. Morton于2008年发明，它将地理位置编码为一串简短的字母和数字。它是一种分层的空间数据结构，将空间细分为网格形状的桶，这是所谓的z顺序曲线的众多应用之一，通常是空间填充曲线。</p>
<blockquote>
<p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p>
<p>Redis GEO 操作方法有：</p>
<ul>
<li>geoadd：添加地理位置的坐标。</li>
<li>geopos：获取地理位置的坐标。</li>
<li>geodist：计算两个位置之间的距离。</li>
<li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li>
<li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li>
<li>geohash：返回一个或多个位置对象的 geohash 值。</li>
</ul>
</blockquote>
<p>geo底层基于zset</p>
<h3 id="7、Redis-6-0新特性"><a href="#7、Redis-6-0新特性" class="headerlink" title="7、Redis 6.0新特性"></a>7、Redis 6.0新特性</h3><ol>
<li><p><strong>多线程</strong></p>
<p>redis 6.0 提供了多线程的支持，redis 6 以前的版本，严格来说也是多线程，只不过执行用户命令的请求时单线程模型，还有一些线程用来执行后台任务， 比如 unlink 删除 大key，rdb持久化等。</p>
<p>redis 6.0 提供了多线程的读写IO, 但是最终执行用户命令的线程依然是单线程的，这样，就没有多线程数据的竞争关系，依然很高效。</p>
</li>
<li><p><strong>Client Side Cache</strong></p>
<p>客户端缓存：redis 6 提供了服务端追踪key的变化，客户端缓存数据的特性，这需要客户端实现</p>
<p>执行流程为， 当客户端访问某个key时，服务端将记录key 和 client ，客户端拿到数据后，进行客户端缓存，这时，当key再次被访问时，key将被直接返回，避免了与redis 服务器的再次交互，节省服务端资源，当数据被其他请求修改时，服务端将主动通知客户端失效的key，客户端进行本地失效，下次请求时，重新获取最新数据。</p>
</li>
<li><p><strong>Acls</strong></p>
<p>ACL 是对于命令的访问和执行权限的控制，默认情况下，可以有执行任意的指令，兼容以前版本</p>
<p>ACL设置有两种方式：</p>
<ol>
<li>命令方式</li>
</ol>
<p>​    ACL SETUSER + 具体的权限规则， 通过 ACL SAVE 进行持久化</p>
<ol start="2">
<li>对 ACL 配置文件进行编写，并且执行 ACL LOAD 进行加载</li>
</ol>
<p>ACL存储有两种方式，但是两种方式不能同时配置，否则直接报错退出进程</p>
<ol>
<li><p>redis 配置文件： redis.conf</p>
</li>
<li><p>ACL配置文件, 在redis.conf 中通过 aclfile  /path  配置acl文件的路径</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>分布式</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁</title>
    <url>/2022/06/02/03-00-07-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><h3 id="1、常见分布式锁实现原理"><a href="#1、常见分布式锁实现原理" class="headerlink" title="1、常见分布式锁实现原理"></a>1、常见分布式锁实现原理</h3><ul>
<li><p>setnx key value</p>
<blockquote>
<p>通过setnx命令，当且仅当key不存在时，将key的值设置为value；当key已经存在时，不执行set操作</p>
<p>SETNX是【SET If Not Exists】(如果不存在，则set)的简写；</p>
<p>返回值：</p>
<p>1 设置key成功<br>0 设置key失败</p>
<p>使用：</p>
<p>使用setnx，加锁成功后，通过expire给锁增加过期时间，使用完解锁</p>
<p>优点：简单，在并发不高的场景下，可以使用</p>
<p>缺点：加锁和设置过期时间非原子操作，可能出现加锁之后，程序异常，没有设置过期时间，导致程序阻塞</p>
</blockquote>
</li>
<li><p>SET实现的分布式锁</p>
<blockquote>
<p>语法：</p>
<p>SET key value [EX seconds|PX milliseconds] [NX|XX]</p>
<p>将键<code>key</code>设定为指定的“字符串”值。如果 <code>key</code> 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。当<code>set</code>命令执行成功之后，之前设置的过期时间都将失效。</p>
<p>使用：通过命令加锁，加锁的同时会设置过期时间，用完之后进行解锁</p>
<p>优点：加锁和设置过期时间是原子操作，不会出现程序一直阻塞的问题</p>
<p>缺点：过期时间内，线程A加锁的业务还没有执行完，可能其它线程 线程B会获取锁，然后之前的线程A执行完进行解锁，导致线程B的锁被释放了</p>
</blockquote>
</li>
</ul>
<h3 id="2、Redisson实现的分布式锁"><a href="#2、Redisson实现的分布式锁" class="headerlink" title="2、Redisson实现的分布式锁"></a>2、Redisson实现的分布式锁</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此为单机模式</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取锁对象</span></span><br><span class="line">        RLock redissonLock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="comment">//加分布式锁</span></span><br><span class="line">        redissonLock.lock();  <span class="comment">//  .setIfAbsent(lockKey, clientId, 30, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)); <span class="comment">// jedis.get(&quot;stock&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>); <span class="comment">// jedis.set(key,value)</span></span><br><span class="line">                System.out.println(<span class="string">&quot;扣减成功，剩余库存:&quot;</span> + realStock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            redissonLock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>底层逻辑：</p>
<ul>
<li>锁续命</li>
<li>锁重入</li>
</ul>
<p><img src="/2022/06/02/03-00-07-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png" alt="Redisson分布式锁原理"></p>
<p>加锁逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加分布式锁</span></span><br><span class="line">redissonLock.lock();</span><br><span class="line">------&gt;加锁</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lockInterruptibly();<span class="comment">/**【0】*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">------&gt;加锁【<span class="number">0</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lockInterruptibly(-<span class="number">1</span>, <span class="keyword">null</span>);<span class="comment">/**【1】*/</span></span><br><span class="line">    &#125;</span><br><span class="line">------&gt;加锁【<span class="number">1</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId(); <span class="comment">// 线程id</span></span><br><span class="line">        Long ttl = tryAcquire(leaseTime, unit, threadId);<span class="comment">/**【2】*/</span></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;  <span class="comment">// 加锁成功</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// redis的发布/订阅  抢锁失败 订阅channel 【redisson_lock__channel】</span></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">        commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 没加锁成功 自旋  非公平锁实现</span></span><br><span class="line">                ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 又尝试加一次锁</span></span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123; <span class="comment">// 加锁成功 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// waiting for message</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); <span class="comment">// 调用Semaphore信号量 许可数量为0 获取许可逻辑 获取不到 阻塞ttl s  阻塞等待 让出cpu  不会占用cpu   -----&gt;唤醒 见  【7】</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquire();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unsubscribe(future, threadId);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">    &#125;</span><br><span class="line">------&gt;加锁【<span class="number">2</span>】</span><br><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(tryAcquireAsync(leaseTime, unit, threadId)<span class="comment">/**【3】*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">------&gt;加锁【<span class="number">3</span>】</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; <span class="comment">// 默认-1 会走下面逻辑</span></span><br><span class="line">            <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125;</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<span class="comment">/**【4】*/</span></span><br><span class="line">        ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Long ttlRemaining = future.getNow();</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;  <span class="comment">// 加锁成功</span></span><br><span class="line">                    scheduleExpirationRenewal(threadId);  <span class="comment">/**【5】*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">------&gt;加锁【<span class="number">4</span>】</span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">        internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">		<span class="comment">// 通过lua脚本加锁</span></span><br><span class="line">        <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                  <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +   <span class="comment">// key不存在 往hash中添加数据 同时设置过期时间</span></span><br><span class="line">                      <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;return nil; &quot;</span> +		<span class="comment">// 加锁成功 ，返回null</span></span><br><span class="line">                  <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> + <span class="comment">// key 和filed存在 value值自增 重新设置过期时间【锁重入逻辑】</span></span><br><span class="line">                      <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, <span class="comment">// 没有加锁成功 返回这个key剩余的过期时间</span></span><br><span class="line">                    Collections.&lt;Object&gt;singletonList(getName()<span class="comment">/**redis key getLock()方法传入*/</span>), internalLockLeaseTime<span class="comment">/**过期时间，默认30s*/</span>, getLockName(threadId)<span class="comment">/**设置一个值	*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">------&gt;加锁【<span class="number">5</span>】</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                </span><br><span class="line">                RFuture&lt;Boolean&gt; future = commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                        <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +  <span class="comment">// 判断hash的key 对应的field是否存在[存在表明没有执行完]，存在则设置key过期</span></span><br><span class="line">                            <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">                </span><br><span class="line">                future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123; <span class="comment">// 延时任务 延时执行</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, future.cause());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (future.getNow()) &#123;</span><br><span class="line">                            <span class="comment">// reschedule itself</span></span><br><span class="line">                            scheduleExpirationRenewal(threadId);  <span class="comment">// 此处自我调用 达到了类似定时任务执行的效果 值得借鉴 好处是时间间隔可控，这里是续命逻辑，通过类似定时任务逻辑达到续命的目的</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, internalLockLeaseTime / <span class="number">3</span> 【值为<span class="number">10</span>】, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), task) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解锁逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//解锁</span></span><br><span class="line">redissonLock.unlock();</span><br><span class="line">-----&gt;【<span class="number">0</span>】</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boolean opStatus = get(unlockInnerAsync(Thread.currentThread().getId())<span class="comment">/**【1】*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span></span><br><span class="line">                    + id + <span class="string">&quot; thread-id: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opStatus) &#123;</span><br><span class="line">            cancelExpirationRenewal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Future&lt;Void&gt; future = unlockAsync();</span></span><br><span class="line"><span class="comment">//        future.awaitUninterruptibly();</span></span><br><span class="line"><span class="comment">//        if (future.isSuccess()) &#123;</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (future.cause() instanceof IllegalMonitorStateException) &#123;</span></span><br><span class="line"><span class="comment">//            throw (IllegalMonitorStateException)future.cause();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        throw commandExecutor.convertException(future);</span></span><br><span class="line">    &#125;</span><br><span class="line">-----&gt;【<span class="number">1</span>】</span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +  <span class="comment">// key不存在，已经解锁了</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +  <span class="comment">// 发布消息，通知解锁，【解锁消息】</span></span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> + <span class="comment">// 这个锁是不是当前线程加的 不是 返回nil</span></span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +  <span class="comment">// 是当前线程  这个是重入逻辑，重入次数减1</span></span><br><span class="line">                <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +					<span class="comment">// 重入续命</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +							<span class="comment">// counter为0 删除key，发布消息</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span>+</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">                Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----&gt;订阅监听【<span class="number">7</span>】</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockPubSub</span> <span class="keyword">extends</span> <span class="title">PublishSubscribe</span>&lt;<span class="title">RedissonLockEntry</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long unlockMessage = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RedissonLockEntry <span class="title">createEntry</span><span class="params">(RPromise&lt;RedissonLockEntry&gt; newPromise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLockEntry(newPromise);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 订阅的消息 消费逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message.equals(unlockMessage)) &#123;</span><br><span class="line">            value.getLatch().release();  <span class="comment">// 信号量解锁唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Runnable runnableToExecute = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (value) &#123;</span><br><span class="line">                    Runnable runnable = value.getListeners().poll();</span><br><span class="line">                    <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (value.getLatch().tryAcquire()) &#123;</span><br><span class="line">                            runnableToExecute = runnable;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            value.addListener(runnable);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runnableToExecute.run();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存设计与性能优化</title>
    <url>/2022/06/04/03-00-09-Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Redis缓存设计与性能优化"><a href="#Redis缓存设计与性能优化" class="headerlink" title="Redis缓存设计与性能优化"></a>Redis缓存设计与性能优化</h2><p>使用Redis作为缓存可能出现的问题，上一章节已经讲了很多了，不在赘述。</p>
<h3 id="1、开发规范与性能优化"><a href="#1、开发规范与性能优化" class="headerlink" title="1、开发规范与性能优化"></a>1、开发规范与性能优化</h3><ul>
<li><p>键值设计</p>
<p>需要考虑以下因素</p>
<ul>
<li>【建议】: 可读性和可管理性</li>
<li>【建议】：简洁性</li>
<li>【强制】：不要包含特殊字符</li>
</ul>
</li>
<li><p>value设计</p>
<ul>
<li><p>【强制】：拒绝bigkey(防止网卡流量、慢查询)</p>
<blockquote>
<p>在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。</p>
<ol>
<li>字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。</li>
<li>非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。</li>
</ol>
<p>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p>
<p>反例：一个包含200万个元素的list。</p>
<p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）</p>
<p><strong>bigkey的危害：</strong></p>
<p>1.导致redis阻塞</p>
<p>2.网络拥塞</p>
<p>bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s    1000/8)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例也造成影响，其后果不堪设想。</p>
</blockquote>
</li>
<li><p>过期删除</p>
<blockquote>
<p>有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(<strong>lazyfree-lazy-expire yes</strong>)，就会存在阻塞Redis的可能性。</p>
<p><strong>bigkey的产生：</strong></p>
<p>一般来说，bigkey的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：</p>
<p>(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。</p>
<p>(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。</p>
<p>(3) 缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey。</p>
<p><strong>bigkey的优化</strong></p>
<ol>
<li>拆</li>
</ol>
<p>big list： list1、list2、…listN</p>
<p>big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据</p>
<p>\2. 如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。</p>
<ol start="2">
<li><p>【推荐】：选择适合的数据类型。</p>
</li>
<li><p>【推荐】：控制key的生命周期，redis不是垃圾桶。</p>
<p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>命令使用</strong></p>
<ul>
<li>【推荐】 O(N)命令关注N的数量</li>
<li>【推荐】：禁用命令</li>
<li>【推荐】合理使用select  redis数据库功能比较弱</li>
<li>【推荐】使用批量操作提高效率</li>
<li>【建议】Redis事务功能较弱，不建议过多使用，可以用lua替代</li>
</ul>
</li>
<li><p><strong>客户端使用</strong></p>
<ul>
<li><p>避免多个应用使用一个Redis实例</p>
</li>
<li><p>使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p>
</li>
<li><p>高并发下建议客户端添加熔断功能(例如sentinel、hystrix)</p>
</li>
<li><p>设置合理的密码，如有必要可以使用SSL加密访问</p>
</li>
<li><p><strong>Redis对于过期键有三种清除策略：</strong></p>
<blockquote>
<ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期(默认每100ms)主动淘汰一批<strong>已过期</strong>的key，这里的一批只是部分过期key，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放</li>
<li>当前已用内存超过maxmemory限定时，触发<strong>主动清理策略</strong></li>
</ol>
<p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p>
<p><strong>a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>b) 针对所有的key做处理：</strong></p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p><strong>c) 不处理：</strong></p>
<ol>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<p><strong>LRU 算法****（Least Recently Used，最近最少使用）【热点数据】</strong></p>
<p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<p><strong>LFU 算法****（Least Frequently Used，最不经常使用）【周期性使用，偶发性的】</strong></p>
<p>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。</p>
<p>根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。</p>
<p>当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis总结</title>
    <url>/2022/06/07/03-00-10-Redis%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h2><p><a href="https://www.processon.com/view/link/629f69045653bb0ca01c6b52">Redis总结</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper特性与节点数据类型</title>
    <url>/2022/06/09/03-02-00-Zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Zookeeper特性与节点数据类型"><a href="#一、Zookeeper特性与节点数据类型" class="headerlink" title="一、Zookeeper特性与节点数据类型"></a>一、Zookeeper特性与节点数据类型</h2><h3 id="1、什么是Zookeeper"><a href="#1、什么是Zookeeper" class="headerlink" title="1、什么是Zookeeper"></a>1、什么是Zookeeper</h3><blockquote>
<p>zookeeper，它是一个分布式协调框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
</blockquote>
<h3 id="2、Zookeeper核心概念"><a href="#2、Zookeeper核心概念" class="headerlink" title="2、Zookeeper核心概念"></a>2、Zookeeper核心概念</h3><ul>
<li><p><strong>文件系统数据结构</strong></p>
<blockquote>
<p>Zookeeper维护一个类似文件系统的数据结构：                                                          </p>
<p><img src="/2022/06/09/03-02-00-Zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20220610001322544.png" alt="image-20220610001322544"></p>
<p>每个子目录项都被称作为 **znode(目录节点)**，和文件系统类似，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode。</p>
<p>有六种类型的znode：</p>
<ul>
<li><p>PERSISTENT-持久化目录节点</p>
<blockquote>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在</p>
</blockquote>
</li>
<li><p>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</p>
<blockquote>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p>
</blockquote>
</li>
<li><p>EPHEMERAL-临时目录节点</p>
<blockquote>
<p>客户端与zookeeper断开连接后，该节点被删除</p>
</blockquote>
</li>
<li><p>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p>
<blockquote>
<p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p>
</blockquote>
</li>
<li><p>Container 节点</p>
<blockquote>
<p>3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除,定时任务默认60s 检查一次</p>
</blockquote>
</li>
<li><p>TTL 节点</p>
<blockquote>
<p>通过后台线程进行轮询，过期时间不是很精准</p>
<p>好处：不需要维护节点被删除的时间段，服务端可以自动清除</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>监听通知机制</strong></p>
<blockquote>
<p>所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触发一次。</p>
</blockquote>
<ul>
<li><p>对节点的监听</p>
<blockquote>
<p>如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知</p>
</blockquote>
</li>
<li><p>对目录的监听</p>
<blockquote>
<p>如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知</p>
</blockquote>
</li>
<li><p>对某个目录的递归子节点监听</p>
<blockquote>
<p>如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h3><ul>
<li><p>分布式配置中心</p>
</li>
<li><p>分布式注册中心</p>
</li>
<li><p>分布式锁</p>
</li>
<li><p>分布式队列</p>
</li>
<li><p>集群选举</p>
</li>
<li><p>分布式屏障</p>
</li>
<li><p>发布/订阅</p>
</li>
</ul>
<h3 id="4、Zookeeper实操"><a href="#4、Zookeeper实操" class="headerlink" title="4、Zookeeper实操"></a>4、Zookeeper实操</h3><p><strong>操作节点</strong></p>
<ul>
<li><p>zookeeper常用操作</p>
<blockquote>
<p>[zk: localhost:2181(CONNECTED) 80] help<br>ZooKeeper -server host:port cmd args</p>
<pre><code>addauth scheme auth
close 
config [-c] [-w] [-s]
connect host:port
create [-s] [-e] [-c] [-t ttl] path [data] [acl]
delete [-v version] path
deleteall path
delquota [-n|-b] path
get [-s] [-w] path
getAcl [-s] path
history 
listquota path
ls [-s] [-w] [-R] path
ls2 path [watch]
printwatches on|off
quit 
reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]
redo cmdno
removewatches path [-c|-d|-a] [-l]
rmr path
set [-s] [-v version] path data
setAcl [-s] [-v version] [-R] path acl
setquota -n|-b val path
stat [-w] path
sync path
</code></pre>
</blockquote>
</li>
<li><p>创建zookeeper 节点命令</p>
<blockquote>
<p>create [-s] [-e] [-c] [-t ttl] path [data] [acl]          </p>
<p>中括号为可选项，没有则默认创建持久化节点</p>
<p>-s: 顺序节点</p>
<p>-e: 临时节点</p>
<p>-c: 容器节点</p>
<p>-t:  可以给节点添加过期时间，默认禁用，需要通过系统参数启用    </p>
<p>例：</p>
<p>create  /test-node some-data              【如上，没有加任何可选参数，创建的就是持久化节点】</p>
</blockquote>
</li>
<li><p>查看节点：</p>
<blockquote>
<p>get  /test-node              </p>
</blockquote>
</li>
<li><p>修改数据</p>
<blockquote>
<p>set /test-node some-data-changed</p>
</blockquote>
</li>
<li><p>查看节点状态信息：</p>
<blockquote>
<p>stat /test-node </p>
<p><strong>Stat</strong></p>
<ul>
<li>cZxid：创建znode的事务ID（Zxid的值）。</li>
<li>mZxid：最后修改znode的事务ID。</li>
<li>pZxid：最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）。</li>
<li>ctime：znode创建时间。</li>
<li>mtime：znode最近修改时间。</li>
<li>dataVersion：znode的当前数据版本。</li>
<li>cversion：znode的子节点结果集版本（一个节点的子节点增加、删除都会影响这个版本）。</li>
<li>aclVersion：表示对此znode的acl版本。</li>
<li>ephemeralOwner：znode是临时znode时，表示znode所有者的 session ID。 如果znode不是临时znode，则该字段设置为零。</li>
<li>dataLength：znode数据字段的长度。</li>
<li>numChildren：znode的子znode的数量。</li>
</ul>
<p>查看节点状态信息同时查看数据:</p>
<p><strong>get -s node-name</strong></p>
<p>根据状态数据中的版本号有并发修改数据实现乐观锁的功能:</p>
<p>get -s /node-name</p>
</blockquote>
</li>
<li><p>创建子节点</p>
<blockquote>
<p>create /test-node/test-sub-node              </p>
</blockquote>
</li>
<li><p>查看子节点信息，比如根节点下面的所有子节点， 加一个大写 R  可以查看递归子节点列表</p>
<blockquote>
<p>ls /<br>ls -R node-name</p>
</blockquote>
</li>
<li><p>创建临时节点</p>
<blockquote>
<p>create -e /ephemeral data               【create 后跟一个 -e 创建临时节点 ， 临时节点不能创建子节点】</p>
</blockquote>
</li>
<li><p>创建序号节点，加参数 -s</p>
<blockquote>
<p>create    /seq-parent  data // 创建父目录，单纯为了分类，非必须 create -s /seq-parent/  data // 创建顺序节点。顺序节点将再seq-parent 目录下面，顺序递增 序号是十进制的10位，最大2的32次方              </p>
</blockquote>
</li>
<li><p>创建临时顺序节点,其它增删查改和其他节点无异</p>
<blockquote>
<p>create -s -e  /ephemeral-node/前缀-              </p>
</blockquote>
</li>
<li><p>创建容器节点</p>
<blockquote>
<p>容器节点主要用来容纳字节点，如果没有给其创建子节点，容器节点表现和持久化节点一样，如果给容器节点创建了子节点，后续又把子节点清空，容器节点也会被zookeeper删除。</p>
<p>create -c /container              </p>
</blockquote>
</li>
</ul>
<p><strong>事件监听机制：</strong></p>
<p>但是<strong>每个目录下</strong>的目录监听也是一次性的【每个子目录最多能够触发一次】</p>
<ul>
<li><p>针对节点的监听：一定事件触发，对应的注册立刻被移除，所以事件监听是一次性的</p>
<blockquote>
<p>get  -w  /path   // 注册监听的同时获取数据  服务端主动推送变化给客户端，客户端实时感知 【无论数据是否真的有变动，比如你set 的值跟原值一样，也会推送给客户端】 stat -w /path   // 对节点进行监听，且获取元数据信息              </p>
</blockquote>
</li>
<li><p>针对目录的监听，如下图，目录的变化，会触发事件，且一旦触发，对应的监听也会被移除，后续对节点的创建没有触发监听事件</p>
<blockquote>
<p>ls -w /path  【只有当目录下面有节点加入或删除时，才会有通知，修改节点下面的内容 不会通知  目的：简单 降低复杂性】              </p>
</blockquote>
</li>
<li><p>针对递归子目录的监听</p>
<blockquote>
<p>ls -R -w /path ： -R 区分大小写，一定用大写               </p>
</blockquote>
</li>
</ul>
<h3 id="5、Zookeeper-的-ACL-权限控制-Access-Control-List"><a href="#5、Zookeeper-的-ACL-权限控制-Access-Control-List" class="headerlink" title="5、Zookeeper 的 ACL 权限控制( Access Control   List )"></a>5、<strong>Zookeeper 的 ACL 权限控制( Access Control   List )</strong></h3><blockquote>
<p>Zookeeper 的ACL 权限控制,可以控制节点的读写操作,保证数据的安全性，Zookeeper ACL 权限设置分为 3 部分组成，分别是：<strong>权限模式</strong>（Scheme）、<strong>授权对象</strong>（ID）、<strong>权限信息</strong>（Permission）</p>
</blockquote>
<ul>
<li><strong>Scheme（权限模式）</strong></li>
<li><strong>授权对象（ID）</strong></li>
<li><strong>权限信息（Permission）</strong></li>
</ul>
<h3 id="6、ZooKeeper-内存数据和持久化"><a href="#6、ZooKeeper-内存数据和持久化" class="headerlink" title="6、ZooKeeper 内存数据和持久化"></a>6、<strong>ZooKeeper 内存数据和持久化</strong></h3><ul>
<li><p><strong>事务日志</strong></p>
<blockquote>
<p>针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，当然，Zookeeper也会将数据变更应用到内存数据库中</p>
</blockquote>
</li>
<li><p><strong>数据快照</strong></p>
<blockquote>
<p>数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper客户端使用与集群特性</title>
    <url>/2022/06/10/03-02-01-Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Zookeeper-Java-客户端"><a href="#一、Zookeeper-Java-客户端" class="headerlink" title="一、Zookeeper Java 客户端"></a>一、Zookeeper Java 客户端</h2><h3 id="1、zookeeper原生方式"><a href="#1、zookeeper原生方式" class="headerlink" title="1、zookeeper原生方式"></a>1、zookeeper原生方式</h3><blockquote>
<ul>
<li>maven坐标</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.5</span><span class="number">.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>客户端创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperClientTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ADDRESS=<span class="string">&quot;192.168.32.139:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_NODE=<span class="string">&quot;/zk-node&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        zooKeeper=<span class="keyword">new</span> ZooKeeper(ZK_ADDRESS, SESSION_TIMEOUT, event -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getState()== Watcher.Event.KeeperState.SyncConnected &amp;&amp;</span><br><span class="line">                    event.getType()== Watcher.Event.EventType.None)&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                log.info(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;连接中....&quot;</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 创建zookeeper实例方法</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, ZKClientConfig)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly, HostProvider)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly, HostProvider, ZKClientConfig)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly, ZKClientConfig)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[])</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[], <span class="keyword">boolean</span>, HostProvider)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[], <span class="keyword">boolean</span>, HostProvider, ZKClientConfig)</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span>  sessionTimeout, Watcher watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[], <span class="keyword">boolean</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>connectString</td>
<td>ZooKeeper服务器列表，由英文逗号分开的host:port字符串组成， 每一个都代表一台ZooKeeper机器，如，host1:port1,host2:port2,host3:port3。另外，也可以在connectString中设置客户端连接上ZooKeeper 后的根目录，方法是在host:port字符串之后添加上这个根目录，例如,host1:port1,host2:port2,host3:port3/zk-base,这样就指定了该客户端连接上ZooKeeper服务器之后,所有对ZooKeeper 的操作，都会基于这个根目录。例如，客户端对/sub-node 的操作，最终创建 /zk-node/sub-node, 这个目录也叫Chroot，即客户端隔离命名空间。</td>
</tr>
<tr>
<td>sessionTimeout</td>
<td>会话的超时时间，是一个以“毫秒”为单位的整型值。在ZooKeeper中有 会话的概念，在一个会话周期内，ZooKeeper客户端和服务器之间会通过心跳检 测机制来维持会话的有效性，一旦在sessionTimeout时间内没有进行有效 的心跳检测，会话就会失效。</td>
</tr>
<tr>
<td>watcher</td>
<td>ZooKeeper允许 客户端在构造方法中传入一个接口 watcher (org.apache. zookeeper. Watcher)的实现类对象来作为默认的 Watcher事件通知处理器。当然，该参 数可以设置为null 以表明不需要设置默认的 Watcher处理器。</td>
</tr>
<tr>
<td>canBeReadOnly</td>
<td>这是一个boolean类型的参数，用于标识当前会话是否支持“read-only(只 读)”模式。默认情况下，在ZooKeeper集群中，一个机器如果和集群中过半及 以上机器失去了网络连接，那么这个机器将不再处理客户端请求（包括读写请 求)。但是在某些使用场景下，当ZooKeeper服务器发生此类故障的时候，我们 还是希望ZooKeeper服务器能够提供读服务（当然写服务肯定无法提供）—— 这就是 ZooKeeper的“read-only”模式。</td>
</tr>
<tr>
<td>sessionId和 ses sionPasswd</td>
<td>分别代表会话ID和会话秘钥。这两个参数能够唯一确定一个会话，同时客户 端使用这两个参数可以实现客户端会话复用，从而达到恢复会话的效果。具体 使用方法是，第一次连接上ZooKeeper服务器时，通过调用ZooKeeper对象实 例的以下两个接口，即可获得当前会话的ID和秘钥: long getSessionId(); byte[]getSessionPasswd( ); 荻取到这两个参数值之后，就可以在下次创建ZooKeeper对象实例的时候传 入构造方法了</td>
</tr>
</tbody></table>
</li>
<li><p>创建同步节点/异步创建节点/修改节点数据</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 创建同步节点</span><br><span class="line">String path = zooKeeper.create(ZK_NODE, <span class="string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">## 异步创建节点</span><br><span class="line"> zooKeeper.create(ZK_NODE, <span class="string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">             CreateMode.PERSISTENT,</span><br><span class="line">             (rc, path, ctx, name) -&gt; log.info(<span class="string">&quot;rc  &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;</span>,rc,path,ctx,name),<span class="string">&quot;context&quot;</span>);</span><br><span class="line">## 修改节点数据 【带版本号】</span><br><span class="line">Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">    <span class="keyword">byte</span>[] data = zooKeeper.getData(ZK_NODE, <span class="keyword">false</span>, stat);</span><br><span class="line">    log.info(<span class="string">&quot;修改前: &#123;&#125;&quot;</span>,<span class="keyword">new</span> String(data));</span><br><span class="line">    zooKeeper.setData(ZK_NODE, <span class="string">&quot;changed!&quot;</span>.getBytes(), stat.getVersion());</span><br><span class="line">     <span class="keyword">byte</span>[] dataAfter = zooKeeper.getData(ZK_NODE, <span class="keyword">false</span>, stat);</span><br><span class="line">    log.info(<span class="string">&quot;修改后: &#123;&#125;&quot;</span>,<span class="keyword">new</span> String(dataAfter));</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、Curator方式"><a href="#二、Curator方式" class="headerlink" title="二、Curator方式"></a>二、Curator方式</h2><blockquote>
<p>简介：Java 语言编程的 ZooKeeper 客户端框架，Curator项目是现在ZooKeeper 客户端中使用最多，对ZooKeeper 版本支持最好的第三方客户端，并推荐使用，Curator 把我们平时常用的很多 ZooKeeper 服务开发功能做了封装，例如 Leader 选举、分布式计数器、分布式锁。这就减少了技术人员在使用 ZooKeeper 时的大部分底层细节开发工作。在会话重新连接、Watch 反复注册、多种异常处理等使用场景中，用原生的 ZooKeeper 处理比较复杂。而在使用 Curator 时，由于其对这些功能都做了高度的封装，使用起来更加简单，不但减少了开发时间，而且增强了程序的可靠性。</p>
</blockquote>
<h3 id="1、Curator使用"><a href="#1、Curator使用" class="headerlink" title="1、Curator使用"></a>1、Curator使用</h3><blockquote>
<ul>
<li><p>maven坐标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>会话创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 静态工厂方式</span><br><span class="line"><span class="comment">// 重试策略 </span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">client.start();</span><br><span class="line">##  fluent 风格创建</span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.128.129:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)  <span class="comment">// 会话超时时间</span></span><br><span class="line">                .connectionTimeoutMs(<span class="number">5000</span>) <span class="comment">// 连接超时时间</span></span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">&quot;base&quot;</span>) <span class="comment">// 包含隔离名称</span></span><br><span class="line">                .build();</span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure>

<p><strong>关键参数：</strong></p>
<ul>
<li><p>connectionString：服务器地址列表</p>
</li>
<li><p>retryPolicy：重试策略</p>
<table>
<thead>
<tr>
<th><strong>策略名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ExponentialBackoffRetry</td>
<td>重试一组次数，重试之间的睡眠时间增加</td>
</tr>
<tr>
<td>RetryNTimes</td>
<td>重试最大次数</td>
</tr>
<tr>
<td>RetryOneTime</td>
<td>只重试一次</td>
</tr>
<tr>
<td>RetryUntilElapsed</td>
<td>在给定的时间结束之前重试</td>
</tr>
</tbody></table>
</li>
<li><p>超时时间：Curator 客户端创建过程中，有两个超时时间的设置。</p>
<blockquote>
<p>一个是 sessionTimeoutMs 会话超时时间，用来设置该条会话在 ZooKeeper 服务端的失效时间。另一个是 connectionTimeoutMs 客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收 ZooKeeper 服务端应答的时间。sessionTimeoutMs 作用在服务端，而 connectionTimeoutMs 作用在客户端。</p>
</blockquote>
</li>
<li><p>创建节点/一次性创建带层级结构的节点/获取数据/更新节点/删除节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 创建节点</span><br><span class="line">String path = curatorFramework.create().forPath(<span class="string">&quot;/curator-node&quot;</span>);</span><br><span class="line"><span class="comment">// curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(&quot;/curator-node&quot;,&quot;some-data&quot;.getBytes())</span></span><br><span class="line">## 一次性创建带层级结构的节点</span><br><span class="line">String pathWithParent=<span class="string">&quot;/node-parent/sub-node-1&quot;</span>;</span><br><span class="line">    String path = curatorFramework.create().creatingParentsIfNeeded().forPath(pathWithParent);</span><br><span class="line">## 获取数据</span><br><span class="line"><span class="keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/curator-node&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;get data from  node :&#123;&#125;  successfully.&quot;</span>,<span class="keyword">new</span> String(bytes));</span><br><span class="line">## 更新节点</span><br><span class="line">curatorFramework.setData().forPath(<span class="string">&quot;/curator-node&quot;</span>,<span class="string">&quot;changed!&quot;</span>.getBytes());</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/curator-node&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;get data from  node /curator-node :&#123;&#125;  successfully.&quot;</span>,<span class="keyword">new</span> String(bytes));</span><br><span class="line">## 删除节点</span><br><span class="line">String pathWithParent=<span class="string">&quot;/node-parent&quot;</span>;</span><br><span class="line">    curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(pathWithParent);</span><br><span class="line">注：guaranteed：该函数的功能如字面意思一样，主要起到一个保障删除成功的作用，其底层工作方式是：只要该客户端的会话有效，就会在后台持续发起删除请求，直到该数据节点在 ZooKeeper 服务端被删除。</span><br><span class="line">deletingChildrenIfNeeded：指定了该函数后，系统在删除该数据节点的时候会以递归的方式直接删除其子节点，以及子节点的子节点。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="三、Zookeeper-集群模式"><a href="#三、Zookeeper-集群模式" class="headerlink" title="三、Zookeeper 集群模式"></a>三、<strong>Zookeeper 集群模式</strong></h2><p>Zookeeper 集群模式一共有三种类型的角色</p>
<p><strong>Leader</strong>:  处理所有的事务请求（写请求），可以处理读请求，集群中只能有一个Leader</p>
<p><strong>Follower</strong>：只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。</p>
<p><strong>Observer</strong>：只能处理读请求。不能参与选举 </p>
<p><strong>Zookeeper 3.5.0 新特性： 集群动态配置</strong></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群Leader选举源码</title>
    <url>/2022/06/12/03-02-03-Zookeeper%E9%9B%86%E7%BE%A4Leader%E9%80%89%E4%B8%BE%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Zookeeper集群Leader选举源码"><a href="#Zookeeper集群Leader选举源码" class="headerlink" title="Zookeeper集群Leader选举源码"></a>Zookeeper集群Leader选举源码</h2><h3 id="1、单机启动遇到的问题"><a href="#1、单机启动遇到的问题" class="headerlink" title="1、单机启动遇到的问题"></a>1、单机启动遇到的问题</h3><ul>
<li><p><strong>客户端启动报错：java.lang.ClassNotFoundException: org.apache.commons.cli.ParseException</strong></p>
<p>解决方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 修改pom文件 该注释的注释 该增加的增加</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-cli&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-cli&lt;/artifactId&gt;</span><br><span class="line">  &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、启动或leader宕机选举leader流程"><a href="#2、启动或leader宕机选举leader流程" class="headerlink" title="2、启动或leader宕机选举leader流程"></a>2、启动或leader宕机选举leader流程</h3><p><img src="/2022/06/12/03-02-03-Zookeeper%E9%9B%86%E7%BE%A4Leader%E9%80%89%E4%B8%BE%E6%BA%90%E7%A0%81/image-20220612191051125.png" alt="image-20220612191051125"></p>
<blockquote>
<p>myid：每台机器的标识，自己配置的</p>
<p>zxid：这台机器对应的最大的事务id</p>
<p>举例分析：</p>
<p>场景：有三台机器myid分别为1，2，3；启动顺序1、2、3</p>
<p>投票的过程：就是将自己选则的leader节点发送给集群中的其它机器</p>
<p>1&gt;myid为1的先启动，会先投给自己一票，将这一票的信息发送给其它机器（假设此时myid为2的已经启动）【投票会将自己的投票发送给集群的其它节点】</p>
<p>2&gt;myid为2的启动，也会先投自己一票，并且将选票发送给其它节点</p>
<p>3&gt;第一轮投票完了；<strong>myid为1的</strong>将自己投的票和收到的票做对比，优先选择zxid大的作为leader【如图左上角备注】，zxid越大，收到的数据越多。第一轮投票，因为机器都是刚启动，zxid都是一样的，当zxid一样，还会根据myid大小，优先选择myid大的为leader，所以myid为1的选择myid为2的作为leader，但是因为没有超过半数机制（因为有三台机器，至少需要2台选myid为2的，才能选举成功，此时myid为3的还未启动，并且myid为1 的投的是它自己），因此第一次投票作废。</p>
<p>4&gt;开始第二轮投票，每个节点会将自己第一轮的投票结果发送给其它节点。<strong>第一轮的结果是：myid为1的选择myid为2的作为leader，myid为2的也选自己作为leader。</strong>所以第二轮myid为1的和myid为2的都是投myid为2的，超过半数，所以myid为2的选为了leader节点</p>
<p>5&gt;myid为3的启动，发现leader已经选出来的，就把自己设置为follower节点。</p>
</blockquote>
<h3 id="3、leader选举多层队列架构"><a href="#3、leader选举多层队列架构" class="headerlink" title="3、leader选举多层队列架构"></a>3、<strong>leader选举多层队列架构</strong></h3><p>整个zookeeper选举底层可以分为选举应用层和消息传输层，应用层有自己的队列统一接收和发送选票，传输层也设计了自己的队列，但是按发送的机器分了队列，避免给每台机器发送消息时相互影响，比如某台机器如果出问题发送不成功则不会影响对正常机器的消息发送。</p>
<p><img src="/2022/06/12/03-02-03-Zookeeper%E9%9B%86%E7%BE%A4Leader%E9%80%89%E4%B8%BE%E6%BA%90%E7%A0%81/image-20220614004652576.png" alt="image-20220614004652576"></p>
<h3 id="3、流程图"><a href="#3、流程图" class="headerlink" title="3、流程图"></a>3、流程图</h3><p><a href="https://www.processon.com/view/link/62a5ca09e0b34d29446d6d7b">zookeeper选举leader源码流程图–待补充完整</a></p>
<p>zookeeper选举leader算法本身不难，复杂在节点间的通信和高性能优化上，发送选举内容和接收其它节点选票内容都是通过阻塞队列实现的。</p>
<p>补充了流程图，源码通信那块太绕了，先看第一遍，后面再看第二遍</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
        <tag>集群Leader选举</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper基础使用总结</title>
    <url>/2022/06/14/03-02-04-Zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://www.processon.com/view/link/62a8b44607912939b22eb485">Zookeeper总结</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>总结</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper分布式一致性协议ZAB源码</title>
    <url>/2022/06/15/03-02-05-Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEZAB%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Zookeeper分布式一致性协议ZAB"><a href="#Zookeeper分布式一致性协议ZAB" class="headerlink" title="Zookeeper分布式一致性协议ZAB"></a>Zookeeper分布式一致性协议ZAB</h2><h3 id="1、什么是ZAB协议"><a href="#1、什么是ZAB协议" class="headerlink" title="1、什么是ZAB协议"></a>1、什么是ZAB协议</h3><blockquote>
<p><strong>整个Zookeeper就是一个多节点分布式一致性算法的实现，底层采用的实现协议是ZAB。</strong></p>
<p><strong>ZAB协议介绍【虽然是强一致性的，但不是实时强一致性，即顺序一致性（zxid）】</strong></p>
<p>ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。</p>
<p>Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper 并没有使用 Paxos ，而是采用了 ZAB 协议，ZAB是Paxos算法的一种简化实现。</p>
<p>ZAB 协议定义：<strong>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持</strong> <strong>崩溃恢复</strong> <strong>和</strong> <strong>原子广播</strong> <strong>的协议</strong>。下面我们会重点讲这两个东西。</p>
<p>基于该协议，Zookeeper 实现了一种 主备模式 的系统架构来保持集群中各个副本之间数据一致性。</p>
</blockquote>
<h3 id="2、消息广播"><a href="#2、消息广播" class="headerlink" title="2、消息广播"></a>2、<strong>消息广播</strong></h3><blockquote>
<p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 <strong>两阶段提交过程</strong>。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数(含leader自己)成功响应，则执行 commit 操作。</p>
<p><strong>整个广播流程如下：</strong></p>
<p><img src="/2022/06/15/03-02-05-Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEZAB%E6%BA%90%E7%A0%81/image-20220615231246480.png" alt="image-20220615231246480"></p>
<blockquote>
<p>通过以上步骤，就能够保持集群之间数据的一致性。</p>
<p><strong>还有一些细节：</strong></p>
<ol>
<li>Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务ID（ZXID），ZAB 协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理，主要通过消息队列实现。</li>
<li>在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。</li>
<li>zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到客户端的写请求，也会转发到 Leader 服务器进行处理，Follower只能处理读请求。</li>
<li><strong>ZAB协议规定了如果一个事务在一台机器上被处理(commit)成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。</strong></li>
</ol>
</blockquote>
</blockquote>
<h3 id="3、崩溃恢复"><a href="#3、崩溃恢复" class="headerlink" title="3、崩溃恢复"></a>3、<strong>崩溃恢复</strong></h3><blockquote>
<p>刚刚我们说消息广播过程中，Leader 崩溃怎么办？还能保证数据一致吗？</p>
<p>实际上，当 Leader 崩溃，即进入我们开头所说的崩溃恢复模式（崩溃即：Leader 失去与过半 Follwer 的联系）。下面来详细讲述。</p>
<p>假设1：Leader 在复制数据给所有 Follwer 之后，还没来得及收到Follower的ack返回就崩溃，怎么办？</p>
<p>假设2：Leader 在收到 ack 并提交了自己，同时发送了部分 commit 出去之后崩溃怎么办？</p>
<p><strong>针对这些问题，ZAB 定义了 2 个原则：</strong></p>
<ol>
<li>ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。</li>
<li>ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。</li>
</ol>
<p>所以，ZAB 设计了下面这样一个选举算法：</p>
<p><strong>能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。</strong></p>
<p>针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器 ZXID 最大的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。</p>
<p>而且这么做有一个好处是：<strong>可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。</strong></p>
</blockquote>
<h3 id="4、数据同步"><a href="#4、数据同步" class="headerlink" title="4、数据同步"></a>4、<strong>数据同步</strong></h3><blockquote>
<p>当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。</p>
<p>当 Follwer 服务器成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。</p>
<p>实际上，Leader 服务器处理或丢弃事务都是依赖着 ZXID 的，那么这个 ZXID 如何生成呢？</p>
<p>答：在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。</p>
<p>而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值(leader选举周期)，当一轮新的选举结束后，会对这个值加一，并且事务id又从0开始自增。</p>
<p><img src="/2022/06/15/03-02-05-Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEZAB%E6%BA%90%E7%A0%81/image-20220615231404116.png" alt="image-20220615231404116"></p>
<blockquote>
<p>高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的 Leader。简化了数据恢复流程。</p>
<p>基于这样的策略：当 Follower 连接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。</p>
</blockquote>
</blockquote>
<h3 id="5、源码流程图"><a href="#5、源码流程图" class="headerlink" title="5、源码流程图"></a>5、源码流程图</h3><p>待补充，zab这块太绕了，越看越懵，后面再抽时间看一遍</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
        <tag>ZAB</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ环境搭建</title>
    <url>/2022/08/07/03-04-01-RocketMQ%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="RocketMQ基本概念及环境搭建"><a href="#RocketMQ基本概念及环境搭建" class="headerlink" title="RocketMQ基本概念及环境搭建"></a>RocketMQ基本概念及环境搭建</h1><h2 id="1、MQ介绍"><a href="#1、MQ介绍" class="headerlink" title="1、MQ介绍"></a>1、MQ介绍</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>MQ：MessageQueue，消息队列。 队列，是一种FIFO 先进先出的数据结构。消息由生产者发送到MQ进行排队，然后按原来的顺序交由消息的消费者进行处理。QQ和微信就是典型的MQ。</p>
<blockquote>
<p>MQ的作用主要有以下三个方面：</p>
<ul>
<li><p>异步</p>
<p>例子：快递员发快递，直接到客户家效率会很低。引入菜鸟驿站后，快递员只需要把快递放到菜鸟驿站，就可以继续发其他快递去了。客户再按自己的时间安排去菜鸟驿站取快递。</p>
<p>作用：异步能提高系统的响应速度、吞吐量。</p>
</li>
<li><p>解耦</p>
<p>例子：《Thinking in JAVA》很经典，但是都是英文，我们看不懂，所以需要编辑社，将文章翻译成其他语言，这样就可以完成英语与其他语言的交流。</p>
<p>作用：</p>
<p>1、服务之间进行解耦，才可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。</p>
<p>2、另外，解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行消费，并且消费者的增加或者减少对生产者没有影响。</p>
</li>
<li><p>削峰</p>
<p>例子：长江每年都会涨水，但是下游出水口的速度是基本稳定的，所以会涨水。引入三峡大坝后，可以把水储存起来，下游慢慢排水。</p>
<p>作用：以稳定的系统资源应对突发的流量冲击。</p>
</li>
</ul>
</blockquote>
<h3 id="1-2-MQ的优缺点"><a href="#1-2-MQ的优缺点" class="headerlink" title="1.2 MQ的优缺点"></a>1.2 MQ的优缺点</h3><p>上面MQ的所用也就是使用MQ的优点。 但是引入MQ也是有他的缺点的：</p>
<ul>
<li>系统可用性降低</li>
</ul>
<p>系统引入的外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。这就需要考虑如何保证MQ的高可用。</p>
<ul>
<li>系统复杂度提高</li>
</ul>
<p>引入MQ后系统的复杂度会大大提高。以前服务之间可以进行同步的服务调用，引入MQ后，会变为异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：如何保证消费不会丢失？不会被重复调用？怎么保证消息的顺序性等问题。</p>
<ul>
<li>消息一致性问题</li>
</ul>
<p>A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，C系统处理失败怎么办？这就需要考虑如何保证消息数据处理的一致性。</p>
<h3 id="1-3-几大MQ产品比较"><a href="#1-3-几大MQ产品比较" class="headerlink" title="1.3 几大MQ产品比较"></a>1.3 几大MQ产品比较</h3><h2 id><a href="#" class="headerlink" title></a><img src="/2022/08/07/03-04-01-RocketMQ%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/MQ%E4%BA%A7%E5%93%81%E6%AF%94%E8%BE%83.png" alt="MQ产品比较"></h2><h2 id="2、RocketMQ环境搭建"><a href="#2、RocketMQ环境搭建" class="headerlink" title="2、RocketMQ环境搭建"></a>2、RocketMQ环境搭建</h2><h3 id="2-1-下载地址"><a href="#2-1-下载地址" class="headerlink" title="2.1 下载地址"></a>2.1 下载地址</h3><blockquote>
<p> RocketMQ运行版本下载地址： <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip</a></p>
<p> RocketMQ源码版本下载地址： <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-source-release.zip">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-source-release.zip</a></p>
</blockquote>
<h3 id="2-2-快速按照RocketMQ"><a href="#2-2-快速按照RocketMQ" class="headerlink" title="2.2 快速按照RocketMQ"></a>2.2 快速按照RocketMQ</h3><ul>
<li> 我们需要创建一个操作用户用来运行自己的程序，与root用户区分开。使用root用户创建一个oper用户，并给他创建一个工作目录。</li>
</ul>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@worker1 ~]# useradd oper</span><br><span class="line">[root@worker1 ~]# passwd oper </span><br><span class="line">设置用户密码</span><br><span class="line">123qwertyu</span><br><span class="line">[root@worker1 ~]# mkdir /app</span><br><span class="line">[root@worker1 ~]# chown oper:oper /app</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>按照JDK，设置环境变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[oper<span class="meta">@worker1</span> tools]$ tar -zxvf jdk-8u171-linux-x64.tar.gz</span><br><span class="line">[oper<span class="meta">@worker1</span> tools]$ mv jdk1<span class="number">.8</span><span class="number">.0_171</span>/ /app/jdk1<span class="number">.8</span></span><br></pre></td></tr></table></figure>

<p>配置环境变量。使用 vi ~/.bash_profile编辑文件，在下面加入以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/app/jdk1<span class="number">.8</span>/</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:$HOME/.local/bin:$HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>编辑完成后，执行 source ~/.bash_profile让环境变量生效</p>
</li>
<li><p> 然后我们把下载的rocketmq-all-4.7.1-bin-release.zip在本地完成解压，并上传到/app/rocketmq目录。完成后，把rocketmq的bin目录也配置到环境变量当中。 vi ~/.bash_profile，加入以下内容，并执行source ~/.bash_profile让环境变量生效：</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/app/jdk1<span class="number">.8</span>/</span><br><span class="line">export ROCKETMQ_HOME=/app/rocketmq/rocketmq-all-<span class="number">4.7</span><span class="number">.1</span>-bin-release</span><br><span class="line">PATH=$ROCKETMQ_HOME/bin:$JAVA_HOME/bin:$PATH:$HOME/.local/bin:$HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>  这样RocketMQ就安装完成了。我们把他运行起来。</p>
<blockquote>
<p>这个ROCKETMQ_HOME的环境变量是必须要单独配置的，如果不配置的话，启动NameSever和Broker都会报错。</p>
<p>这个环境变量的作用是用来加载$ROCKETMQ_HOME/conf下的除broker.conf以外的几个配置文件。所以实际情况中，可以不按这个配置，但是一定要能找到配置文件。</p>
</blockquote>
<h2 id="3、RocketMQ快速运行"><a href="#3、RocketMQ快速运行" class="headerlink" title="3、RocketMQ快速运行"></a>3、RocketMQ快速运行</h2><h3 id="3-1RocketMQ组件结构"><a href="#3-1RocketMQ组件结构" class="headerlink" title="3.1RocketMQ组件结构"></a>3.1RocketMQ组件结构</h3><p><img src="/2022/08/07/03-04-01-RocketMQ%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/RocketMQ%E7%BB%84%E4%BB%B6.png" alt="RocketMQ组件"></p>
<p> RocketMQ由以下这几个组件组成</p>
<ul>
<li>NameServer : 提供轻量级的Broker路由服务。</li>
<li>Broker：实际处理消息存储、转发等服务的核心组件。</li>
<li>Producer：消息生产者集群。通常是业务系统中的一个功能模块。</li>
<li>Consumer：消息消费者集群。通常也是业务系统中的一个功能模块。</li>
</ul>
<p>所以我们要启动RocketMQ服务，需要先启动NameServer。</p>
<h3 id="3-2-启动NameServer"><a href="#3-2-启动NameServer" class="headerlink" title="3.2 启动NameServer"></a>3.2 启动NameServer</h3><ul>
<li><p>修改nameServer启动jvm参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -</span></span><br><span class="line"><span class="string">XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p> 然后我们用静默启动的方式启动NameServer服务：</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup bin/mqnamesrv &amp; </span><br></pre></td></tr></table></figure>

<h3 id="3-3-启动Broker"><a href="#3-3-启动Broker" class="headerlink" title="3.3 启动Broker"></a>3.3 启动Broker</h3><ul>
<li><p>修改Jvm参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span></span><br></pre></td></tr></table></figure>

<p> 然后我们需要找到$ROCKETMQ_HOME/conf/broker.conf， vi指令进行编辑，在最下面加入一个配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">autoCreateTopicEnable=<span class="keyword">true</span></span><br></pre></td></tr></table></figure></li>
<li><p> 然后也以静默启动的方式启动runbroker.sh</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup ./mqbroker &amp;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在观察runserver.sh和runbroker.sh时，我们还可以查看到其他的JVM执行参数，这些参数都可以进行定制。例如我们观察到一个比较有意思的地方，nameServer使用的是CMS垃圾回收器，而Broker使用的是G1垃圾回收器</span><br></pre></td></tr></table></figure>

<h3 id="3-4-关闭RocketMQ服务"><a href="#3-4-关闭RocketMQ服务" class="headerlink" title="3.4 关闭RocketMQ服务"></a>3.4 关闭RocketMQ服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>关闭NameServer</span><br><span class="line">sh bin/mqshutdown namesrv</span><br><span class="line"># <span class="number">2.</span>关闭Broker</span><br><span class="line">sh bin/mqshutdown broker</span><br></pre></td></tr></table></figure>

<h2 id="4、RocketMQ集群架构"><a href="#4、RocketMQ集群架构" class="headerlink" title="4、RocketMQ集群架构"></a>4、RocketMQ集群架构</h2><h3 id="4-1RocketMQ集群中的各个角色"><a href="#4-1RocketMQ集群中的各个角色" class="headerlink" title="4.1RocketMQ集群中的各个角色"></a>4.1RocketMQ集群中的各个角色</h3><p>一个完整的RocketMQ集群中，有如下几个角色</p>
<ul>
<li>Producer：消息的发送者；举例：发信者</li>
<li>Consumer：消息接收者；举例：收信者</li>
<li>Broker：暂存和传输消息；举例：邮局</li>
<li>NameServer：管理Broker；举例：各个邮局的管理机构</li>
<li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li>
</ul>
<blockquote>
<p>我们之前的测试案例中，Topic是什么？topic=’TopicTest’</p>
<p>现在你能看懂我们之前在broker.conf中添加的autoCreateTopicEnable=true这个属性的用处了吗？</p>
</blockquote>
<ul>
<li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li>
</ul>
<blockquote>
<p>在我们之前的测试案例中，一个queueId就代表了一个MessageQueue。有哪些queueId？ 0，1，2，3四个MessageQueue</p>
</blockquote>
<p><a href="https://www.processon.com/view/link/62d96be7f346fb1ede177e68">RocketMQ总结</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ高级原理</title>
    <url>/2022/08/20/03-04-03-RocketMQ%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="一、基础概念："><a href="#一、基础概念：" class="headerlink" title="一、基础概念："></a>一、基础概念：</h1><p> 这一部分我们先来总结下RocketMQ的一些重要的基础概念：</p>
<h2 id="1-消息模型（Message-Model）"><a href="#1-消息模型（Message-Model）" class="headerlink" title="1 消息模型（Message Model）"></a>1 消息模型（Message Model）</h2><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h2 id="2-消息生产者（Producer）"><a href="#2-消息生产者（Producer）" class="headerlink" title="2 消息生产者（Producer）"></a>2 消息生产者（Producer）</h2><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<p>生产者中，会把同一类Producer组成一个集合，叫做生产者组，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p>生产者组：主要用于事务消息中，用来做消息回查，比如其中一个发送者不可用，同一个生产者组中的其它生产者可以进行回查，提供了一个容错机制</p>
<h2 id="3-消息消费者（Consumer）"><a href="#3-消息消费者（Consumer）" class="headerlink" title="3 消息消费者（Consumer）"></a>3 消息消费者（Consumer）</h2><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<ul>
<li>拉取式消费的应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</li>
<li>推动式消费模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</li>
</ul>
<p>消费者同样会把同一类Consumer组成一个集合，叫做消费者组，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<ul>
<li>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</li>
<li>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</li>
<li>消息消费之后不会立马删除，每次消费后会更新消费位点，rocketmq有另外的删除机制，跟消费者无关；rocketMQ 可以配置文件保留时间，默认保留48小时，凌晨4点删除【不管有没有消费】</li>
</ul>
<h2 id="4-主题（Topic）"><a href="#4-主题（Topic）" class="headerlink" title="4 主题（Topic）"></a>4 主题（Topic）</h2><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<p>同一个Topic下的数据，会分片保存到不同的Broker上，而每一个分片单位，就叫做MessageQueue。MessageQueue是生产者发送消息与消费者消费消息的最小单位。</p>
<h2 id="5-代理服务器（Broker-Server）"><a href="#5-代理服务器（Broker-Server）" class="headerlink" title="5 代理服务器（Broker Server）"></a>5 代理服务器（Broker Server）</h2><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<p>Broker Server是RocketMQ真正的业务核心，包含了多个重要的子模块：</p>
<ul>
<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</li>
<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li>
<li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li>
<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li>
<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li>
</ul>
<p>而Broker Server要保证高可用需要搭建主从集群架构。RocketMQ中有两种Broker架构模式：</p>
<ul>
<li>普通集群：</li>
</ul>
<p>这种集群模式下会给每个节点分配一个固定的角色，master负责响应客户端的请求，并存储消息。slave则只负责对master的消息进行同步保存，并响应部分客户端的读请求。消息同步方式分为同步同步和异步同步。</p>
<p>这种集群模式下各个节点的角色无法进行切换，也就是说，master节点挂了，这一组Broker就不可用了。</p>
<ul>
<li>Dledger高可用集群：</li>
</ul>
<p>Dledger是RocketMQ自4.5版本引入的实现高可用集群的一项技术。这个模式下的集群会随机选出一个节点作为master，而当master节点挂了后，会从slave中自动选出一个节点升级成为master。</p>
<p>Dledger技术做的事情：1、接管Broker的CommitLog消息存储 2、从集群中选举出master节点 3、完成master节点往slave节点的消息同步。</p>
<p>Dledger的关键部分是在他的节点选举上。Dledger是使用Raft算法来进行节点选举的。这里简单介绍下Raft算法的选举过程:</p>
<blockquote>
<p>首先：每个节点有三个状态，Leader，follower和candidate(候选人)。正常运行的情况下，集群中会有一个leader，其他都是follower，follower只响应Leader和Candidate的请求，而客户端的请求全部由Leader处理，即使有客户端请求到了一个follower，也会将请求转发到leader。</p>
<p> 集群刚启动时，每个节点都是follower状态，之后集群内部会发送一个timeout信号，所有follower就转成candidate去拉取选票，获得大多数选票的节点选为leader，其他候选人转为follower。如果一个timeout信号发出时，没有选出leader，将会重新开始一次新的选举。而Leader节点会往其他节点发送心跳信号，确认他的leader状态。</p>
<p>– 然后会启动定时器，如果在指定时间内没有收到Leader的心跳，就会转为Candidate状态，然后向其他成员发起投票请求，如果收到半数以上成员的投票，则Candidate会晋升为Leader。然后leader也有可能会退化成follower。</p>
<p> 然后，在Raft协议中，会将时间分为一些任意时间长度的时间片段，叫做term。term会使用一个全局唯一，连续递增的编号作为标识，也就是起到了一个逻辑时钟的作用。<img src="/2022/08/20/03-04-03-RocketMQ%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/RaftTerms.png" alt="RaftTerms"></p>
<p> 在每一个term时间片里，都会进行新的选举，每一个Candidate都会努力争取成为leader。获得票数最多的节点就会被选举为Leader。被选为Leader的这个节点，在一个term时间片里就会保持leader状态。这样，就会保证在同一时间段内，集群中只会有一个Leader。在某些情况下，选票可能会被各个节点瓜分，形成不了多数派，那这个term可能直到结束都没有leader，直到下一个term再重新发起选举，这也就没有了Zookeeper中的脑裂问题。而在每次重新选举的过程中， leader也有可能会退化成为follower。也就是说，在这个集群中， leader节点是会不断变化的。</p>
<p> 然后，每次选举的过程中，每个节点都会存储当前term编号，并在节点之间进行交流时，都会带上自己的term编号。如果一个节点发现他的编号比另外一个小，那么他就会将自己的编号更新为较大的那一个。而如果leader或者candidate发现自己的编号不是最新的，他就会自动转成follower。如果接收到的请求term编号小于自己的编号，term将会拒绝执行。</p>
<p> 在选举过程中，Raft协议会通过心跳机制发起leader选举。节点都是从follower状态开始的，如果收到了来自leader或者candidate的心跳RPC请求，那他就会保持follower状态，避免争抢成为candidate。而leader会往其他节点发送心跳信号，来确认自己的地位。如果follower一段时间(两个timeout信号)内没有收到Leader的心跳信号，他就会认为leader挂了，发起新一轮选举。</p>
<p> 选举开始后，每个follower会增加自己当前的term，并将自己转为candidate。然后向其他节点发起投票请求，请求时会带上自己的编号和term，也就是说都会默认投自己一票。之后candidate状态可能会发生以下三种变化：</p>
<ul>
<li><strong>赢得选举，成为leader</strong>： 如果它在一个term内收到了大多数的选票，将会在接下的剩余term时间内称为leader，然后就可以通过发送心跳确立自己的地位。(每一个server在一个term内只能投一张选票，并且按照先到先得的原则投出)</li>
<li><strong>其他节点成为leader</strong>： 在等待投票时，可能会收到其他server发出心跳信号，说明其他leader已经产生了。这时通过比较自己的term编号和RPC过来的term编号，如果比对方大，说明leader的term过期了，就会拒绝该RPC,并继续保持候选人身份; 如果对方编号不比自己小,则承认对方的地位,转为follower。</li>
<li><strong>选票被瓜分,选举失败</strong>: 如果没有candidate获取大多数选票, 则没有leader产生, candidate们等待超时后发起另一轮选举. 为了防止下一次选票还被瓜分,必须采取一些额外的措施, raft采用随机election timeout(随机休眠时间)的机制防止选票被持续瓜分。通过将timeout随机设为一段区间上的某个值, 因此很大概率会有某个candidate率先超时然后赢得大部分选票。</li>
</ul>
<p>所以以三个节点的集群为例，选举过程会是这样的：</p>
<ol>
<li>集群启动时，三个节点都是follower，发起投票后，三个节点都会给自己投票。这样一轮投票下来，三个节点的term都是1，是一样的，这样是选举不出Leader的。</li>
<li>当一轮投票选举不出Leader后，三个节点会进入随机休眠，例如A休眠1秒，B休眠3秒，C休眠2秒。</li>
<li>一秒后，A节点醒来，会把自己的term加一票，投为2。然后2秒时，C节点醒来，发现A的term已经是2，比自己的1大，就会承认A是Leader，把自己的term也更新为2。实际上这个时候，A已经获得了集群中的多数票，2票，A就会被选举成Leader。这样，一般经过很短的几轮选举，就会选举出一个Leader来。</li>
<li>到3秒时，B节点会醒来，他也同样会承认A的term最大，他是Leader，自己的term也会更新为2。这样集群中的所有Candidate就都确定成了leader和follower.</li>
<li>然后在一个任期内，A会不断发心跳给另外两个节点。当A挂了后，另外的节点没有收到A的心跳，就会都转化成Candidate状态，重新发起选举。</li>
</ol>
</blockquote>
<p>Dledger还会采用Raft协议进行多副本的消息同步：</p>
<blockquote>
<p>简单来说，数据同步会通过两个阶段，一个是uncommitted阶段，一个是commited阶段。</p>
<p>Leader Broker上的Dledger收到一条数据后，会标记为uncommitted状态，然后他通过自己的DledgerServer组件把这个uncommitted数据发给Follower Broker的DledgerServer组件。</p>
<p> 接着Follower Broker的DledgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的Dledger。然后如果Leader Broker收到超过半数的Follower Broker返回的ack之后，就会把消息标记为committed状态。</p>
<p> 再接下来， Leader Broker上的DledgerServer就会发送committed消息给Follower Broker上的DledgerServer，让他们把消息也标记为committed状态。这样，就基于Raft协议完成了两阶段的数据同步。</p>
</blockquote>
<p>最后，关于Dledger以及Raft协议的更底层的详细资料，后续会有一个分布式一致性协议的专题，将会结合其他分布式一致性算法做统一讲解，这里就不深入展开了。</p>
<h2 id="6-名字服务（Name-Server）"><a href="#6-名字服务（Name-Server）" class="headerlink" title="6 名字服务（Name Server）"></a>6 名字服务（Name Server）</h2><p>名称服务充当路由消息的提供者。Broker Server会在启动时向所有的Name Server注册自己的服务信息，并且后续通过心跳请求的方式保证这个服务信息的实时性。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<p>这种特性也就意味着NameServer中任意的节点挂了，只要有一台服务节点正常，整个路由服务就不会有影响。当然，这里不考虑节点的负载情况。</p>
<p>Name Server之间是完全独立的，broker启动的时候会往所有的Name Server发送注册信息，同时会进行心跳保持状态</p>
<h2 id="7-消息（Message）"><a href="#7-消息（Message）" class="headerlink" title="7 消息（Message）"></a>7 消息（Message）</h2><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题Topic。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<p>并且Message上有一个为消息设置的标志，Tag标签。用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<blockquote>
<p>关于Message的更详细字段，在源码的docs/cn/best_practice.md中有详细介绍。</p>
</blockquote>
<p><a href="https://www.processon.com/view/link/62d96be7f346fb1ede177e68">RocketMQ_思维导图</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ总结</title>
    <url>/2022/07/24/03-04-04-RocketMQ%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://www.processon.com/view/link/62d96be7f346fb1ede177e68">RocketMQ总结脑图</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka设计原理详解</title>
    <url>/2022/07/29/03-05-02-Kafka%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Kafka设计原理详解"><a href="#Kafka设计原理详解" class="headerlink" title="Kafka设计原理详解"></a>Kafka设计原理详解</h1><h2 id="1、kafka结构图"><a href="#1、kafka结构图" class="headerlink" title="1、kafka结构图"></a>1、kafka结构图</h2><p><img src="/2022/07/29/03-05-02-Kafka%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220730111347748.png" alt="image-20220730111347748"></p>
<h2 id="2、Kafka核心总控制器Controller"><a href="#2、Kafka核心总控制器Controller" class="headerlink" title="2、Kafka核心总控制器Controller"></a>2、<strong>Kafka核心总控制器Controller</strong></h2><p>在Kafka集群中会有一个或者多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态。</p>
<ul>
<li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。</li>
<li>当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。</li>
<li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。</li>
</ul>
<h2 id="3、Controller选举机制"><a href="#3、Controller选举机制" class="headerlink" title="3、Controller选举机制"></a>3、<strong>Controller选举机制</strong></h2><p>在kafka集群启动的时候，会自动选举一台broker作为controller来管理整个集群，选举的过程是集群中每个broker都会尝试在zookeeper上创建一个 <strong>/controller 临时节点</strong>，zookeeper会保证有且仅有一个broker能创建成功，这个broker就会成为集群的总控器controller。</p>
<p> 当这个controller角色的broker宕机了，此时zookeeper临时节点会消失，集群里其他broker会一直监听这个临时节点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，zookeeper又会保证有一个broker成为新的controller。</p>
<p>具备控制器身份的broker需要比其他普通的broker多一份职责，具体细节如下：</p>
<ol>
<li><strong>监听broker相关的变化</strong>。为Zookeeper中的/brokers/ids/节点添加BrokerChangeListener，用来处理broker增减的变化。</li>
<li><strong>监听topic相关的变化</strong>。为Zookeeper中的/brokers/topics节点添加TopicChangeListener，用来处理topic增减的变化；为Zookeeper中的/admin/delete_topics节点添加TopicDeletionListener，用来处理删除topic的动作。</li>
<li><strong>从Zookeeper中读取获取当前所有与topic、partition以及broker有关的信息并进行相应的管理。</strong>对于所有topic所对应的Zookeeper中的/brokers/topics/[topic]节点添加PartitionModificationsListener，用来监听topic中的分区分配变化。</li>
<li><strong>更新集群的元数据信息，****同步到其他普通的broker节点中。</strong></li>
</ol>
<h2 id="4、Partition副本选举Leader机制"><a href="#4、Partition副本选举Leader机制" class="headerlink" title="4、Partition副本选举Leader机制"></a>4、<strong>Partition副本选举Leader机制</strong></h2><p>controller感知到分区leader所在的broker挂了(controller监听了很多zk节点可以感知到broker存活)，controller会从ISR列表(参数unclean.leader.election.enable=false的前提下)里挑第一个broker作为leader(第一个broker最先放进ISR列表，可能是同步数据最多的副本)，如果参数unclean.leader.election.enable为true，代表在ISR列表里所有副本都挂了的时候可以在ISR列表以外的副本中选leader，这种设置，可以提高可用性，但是选出的新leader有可能数据少很多。</p>
<p>副本进入ISR列表有两个条件：</p>
<ol>
<li>副本节点不能产生分区，必须能与zookeeper保持会话以及跟leader副本网络连通</li>
<li>副本能复制leader上的所有写操作，并且不能落后太多。(与leader副本同步滞后的副本，是由 replica.lag.time.max.ms 配置决定的，超过这个时间都没有跟leader同步过的一次的副本会被移出ISR列表)</li>
</ol>
<h2 id="5、消费者消费消息的offset记录机制"><a href="#5、消费者消费消息的offset记录机制" class="headerlink" title="5、消费者消费消息的offset记录机制"></a>5、<strong>消费者消费消息的offset记录机制</strong></h2><p>每个consumer会定期将自己消费分区的offset提交给kafka内部topic：**__consumer_offsets<strong>，提交过去的时候，</strong>key是consumerGroupId+topic+分区号，value就是当前offset的值**，kafka会定期清理topic里的消息，最后就保留最新的那条数据</p>
<p> 因为__consumer_offsets可能会接收高并发的请求，kafka默认给其<strong>分配50个分区</strong>(可以通过offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。</p>
<p>通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区</p>
<p>公式：<strong>hash(consumerGroupId) % __consumer_offsets主题的分区数</strong></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka生产问题总结及性能优化实践</title>
    <url>/2022/07/30/03-05-03-Kafka%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、kafka可视化管理工具"><a href="#一、kafka可视化管理工具" class="headerlink" title="一、kafka可视化管理工具"></a>一、kafka可视化管理工具</h2><p><strong>Kafka可视化管理工具kafka-manager</strong></p>
<p><img src="/2022/07/30/03-05-03-Kafka%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/image-20220731123557477.png" alt="image-20220731123557477"></p>
<blockquote>
<p>安装及基本使用可参考：<a href="https://www.cnblogs.com/dadonggg/p/8205302.html">https://www.cnblogs.com/dadonggg/p/8205302.html</a></p>
</blockquote>
<h2 id="二、线上环境规划"><a href="#二、线上环境规划" class="headerlink" title="二、线上环境规划"></a>二、<strong>线上环境规划</strong></h2><p><img src="/2022/07/30/03-05-03-Kafka%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/image-20220731123625076.png" alt="image-20220731123625076"></p>
<blockquote>
<p><strong>JVM参数设置</strong></p>
<p>kafka是scala语言开发，运行在JVM上，需要对JVM参数合理设置，参看JVM调优专题</p>
<p>修改bin/kafka-start-server.sh中的jvm设置，假设机器是32G内存，可以如下设置：</p>
<p>export KAFKA_HEAP_OPTS=”-Xmx16G -Xms16G -Xmn10G -XX:MetaspaceSize=256M -XX:+UseG1GC -XX:MaxGCPauseMillis=50 -XX:G1HeapRegionSize=16M”</p>
<p>这种大内存的情况一般都要用G1垃圾收集器，因为年轻代内存比较大，用G1可以设置GC最大停顿时间，不至于一次minor gc就花费太长时间，当然，因为像kafka，rocketmq，es这些中间件，写数据到磁盘会用到操作系统的page cache，所以JVM内存不宜分配过大，需要给操作系统的缓存留出几个G。</p>
</blockquote>
<h2 id="三、线上问题及优化"><a href="#三、线上问题及优化" class="headerlink" title="三、线上问题及优化"></a>三、<strong>线上问题及优化</strong></h2><p><strong>1、消息丢失情况：</strong></p>
<p><strong>消息发送端</strong>：</p>
<p>（1）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。大数据统计报表场景，对性能要求很高，对数据丢失不敏感的情况可以用这种。</p>
<p>（2）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</p>
<p>（3）acks=-1或all： 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数，默认1跟（2）相同，至少改为2才有效)都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然如果min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。</p>
<p><strong>消息消费端</strong>：</p>
<p>如果消费这边配置的是自动提交，万一消费到数据还没处理完，就自动提交offset了，但是此时你consumer直接宕机了，未处理完的数据丢失了，下次也消费不到了。</p>
<p><strong>2、消息重复消费</strong></p>
<p><strong>消息发送端</strong>：</p>
<p>发送消息如果配置了重试机制，比如网络抖动时间过长导致发送端发送超时，实际broker可能已经接收到消息，但发送方会重新发送消息</p>
<p><strong>消息消费端</strong>：</p>
<p>如果消费这边配置的是自动提交，刚拉取了一批数据处理了一部分，但还没来得及提交，服务挂了，下次重启又会拉取相同的一批数据重复处理</p>
<p>一般消费端都是要做<strong>消费幂等</strong>处理的。</p>
<p><strong>3、消息乱序</strong></p>
<p>如果发送端配置了重试机制，kafka不会等之前那条消息完全发送成功才去发送下一条消息，这样可能会出现，发送了1，2，3条消息，第一条超时了，后面两条发送成功，再重试发送第1条消息，这时消息在broker端的顺序就是2，3，1了</p>
<p>所以，是否一定要配置重试要根据业务情况而定。也可以用同步发送的模式去发消息，当然acks不能设置为0，这样也能保证消息发送的有序。</p>
<p>kafka保证全链路消息顺序消费，需要从发送端开始，将所有有序消息发送到同一个分区，然后用一个消费者去消费，但是这种性能比较低，可以在消费者端接收到消息后将需要保证顺序消费的几条消费发到内存队列(可以搞多个)，一个内存队列开启一个线程顺序处理消息。</p>
<p><strong>如何保证消息发送到多个分区，消费的时候还能保证顺序消费？</strong></p>
<p><strong>1、消费端等待所有的消息接收到之后，对消息进行排序，然后再消费端顺序消费</strong></p>
<p><strong>4、消息积压</strong></p>
<p>1）线上有时因为发送方发送消息速度过快，或者消费方处理消息过慢，可能会导致broker积压大量未消费消息。</p>
<p>此种情况如果积压了上百万未消费消息需要紧急处理，可以修改消费端程序，让其将收到的消息快速转发到其他topic(可以设置很多分区)，然后再启动多个消费者同时消费新主题的不同分区。</p>
<p>2）由于消息数据格式变动或消费者程序有bug，导致消费者一直消费不成功，也可能导致broker积压大量未消费消息。</p>
<p>此种情况可以将这些消费不成功的消息转发到其它队列里去(类似<strong>死信队列</strong>)，后面再慢慢分析死信队列里的消息处理问题。</p>
<p><strong>5、延时队列</strong></p>
<p>延时队列存储的对象是延时消息。所谓的“延时消息”是指消息被发送以后，并不想让消费者立刻获取，而是等待特定的时间后，消费者才能获取这个消息进行消费，延时队列的使用场景有很多， 比如 ：</p>
<p>1）在订单系统中， 一个用户下单之后通常有 30 分钟的时间进行支付，如果 30 分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延时队列来处理这些订单了。</p>
<p>2）订单完成1小时后通知用户进行评价。</p>
<p><strong>实现思路：</strong>发送延时消息时先把消息按照不同的延迟时间段发送到指定的队列中（topic_1s，topic_5s，topic_10s，…topic_2h，这个一般不能支持任意时间段的延时），然后通过定时器进行轮训消费这些topic，查看消息是否到期，如果到期就把这个消息发送到具体业务处理的topic中，队列中消息越靠前的到期时间越早，具体来说就是定时器在一次消费过程中，对消息的发送时间做判断，看下是否延迟到对应时间了，如果到了就转发，如果还没到这一次定时任务就可以提前结束了。</p>
<p><strong>6、消息回溯</strong></p>
<p>如果某段时间对已消费消息计算的结果觉得有问题，可能是由于程序bug导致的计算错误，当程序bug修复后，这时可能需要对之前已消费的消息重新消费，可以指定从多久之前的消息回溯消费，这种可以用consumer的offsetsForTimes、seek等方法指定从某个offset偏移的消息开始消费，参见上节课的内容。</p>
<p><strong>7、分区数越多吞吐量越高吗</strong></p>
<p>可以用kafka压测工具自己测试分区数不同，各种情况下的吞吐量</p>
<p># 往test里发送一百万消息，每条设置1KB # throughput 用来进行限流控制，当设定的值小于 0 时不限流，当设定的值大于 0 时，当发送的吞吐量大于该值时就会被阻塞一段时间 bin/kafka-producer-perf-test.sh –topic test –num-records 1000000 –record-size 1024 –throughput -1 –producer-props bootstrap.servers=192.168.65.60:9092 acks=1</p>
<p><img src="/2022/07/30/03-05-03-Kafka%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/image-20220731123658526.png" alt="image-20220731123658526"></p>
<p>网络上很多资料都说分区数越多吞吐量越高 ， 但从压测结果来看，分区数到达某个值吞吐量反而开始下降，实际上很多事情都会有一个临界值，当超过这个临界值之后，很多原本符合既定逻辑的走向又会变得不同。一般情况分区数跟集群机器数量相当就差不多了。</p>
<p>当然吞吐量的数值和走势还会和磁盘、文件系统、 I/O调度策略等因素相关。</p>
<p>注意：如果分区数设置过大，比如设置10000，可能会设置不成功，后台会报错”java.io.IOException : Too many open files”。</p>
<p>异常中最关键的信息是“ Too many open flies”，这是一种常见的 Linux 系统错误，通常意味着文件描述符不足，它一般发生在创建线程、创建 Socket、打开文件这些场景下 。 在 Linux系统的默认设置下，这个文件描述符的个数不是很多 ，通过 ulimit -n 命令可以查看：一般默认是1024，可以将该值增大，比如：ulimit -n 65535</p>
<p><strong>8、消息传递保障</strong></p>
<ul>
<li>at most once(消费者最多收到一次消息，0–1次)：acks = 0 可以实现。</li>
<li>at least once(消费者至少收到一次消息，1–多次)：ack = all 可以实现。</li>
<li>exactly once(消费者刚好收到一次消息)：at least once 加上消费者幂等性可以实现，还可以用<strong>kafka生产者的幂等性</strong>来实现。</li>
</ul>
<p><strong>kafka生产者的幂等性</strong>：因为发送端重试导致的消息重复发送问题，kafka的幂等性可以保证重复发送的消息只接收一次，只需在生产者加上参数 props.put(“enable.idempotence”, true) 即可，默认是false不开启。    </p>
<p>具体实现原理是，kafka每次发送消息会生成PID和Sequence Number，并将这两个属性一起发送给broker，broker会将PID和Sequence Number跟消息绑定一起存起来，下次如果生产者重发相同消息，broker会检查PID和Sequence Number，如果相同不会再接收。</p>
<p>PID：每个新的 Producer 在初始化的时候会被分配一个唯一的 PID，这个PID 对用户完全是透明的。生产者如果重启则会生成新的PID。 Sequence Number：对于每个 PID，该 Producer 发送到每个 Partition 的数据都有对应的序列号，这些序列号是从0开始单调递增的。</p>
<p><strong>9、kafka的事务</strong></p>
<p>Kafka的事务不同于Rocketmq，Rocketmq是保障本地事务(比如数据库)与mq消息发送的事务一致性，Kafka的事务主要是保障一次发送多条消息的事务一致性(要么同时成功要么同时失败)，一般在kafka的流式计算场景用得多一点，比如，kafka需要对一个topic里的消息做不同的流式计算处理，处理完分别发到不同的topic里，这些topic分别被不同的下游系统消费(比如hbase，redis，es等)，这种我们肯定希望系统发送到多个topic的数据保持事务一致性。Kafka要实现类似Rocketmq的分布式事务需要额外开发功能。</p>
<p>kafka的事务处理可以参考<a href="http://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html">官方文档</a>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"> props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"> props.put(<span class="string">&quot;transactional.id&quot;</span>, <span class="string">&quot;my-transactional-id&quot;</span>);</span><br><span class="line"> Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props, <span class="keyword">new</span> StringSerializer(), <span class="keyword">new</span> StringSerializer());</span><br><span class="line"> <span class="comment">//初始化事务</span></span><br><span class="line"> producer.initTransactions();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//开启事务</span></span><br><span class="line">     producer.beginTransaction();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">         <span class="comment">//发到不同的主题的不同分区</span></span><br><span class="line">         producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;hdfs-topic&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">         producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;es-topic&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">         producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;redis-topic&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//提交事务</span></span><br><span class="line">     producer.commitTransaction();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) &#123;</span><br><span class="line">     <span class="comment">// We can&#x27;t recover from these exceptions, so our only option is to close the producer and exit.</span></span><br><span class="line">     producer.close();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">     <span class="comment">// For all other exceptions, just abort the transaction and try again.</span></span><br><span class="line">     <span class="comment">//回滚事务</span></span><br><span class="line">     producer.abortTransaction();</span><br><span class="line"> &#125;</span><br><span class="line"> producer.close();</span><br></pre></td></tr></table></figure>

<p><strong>10、kafka高性能的原因</strong></p>
<ul>
<li>磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾，不会写入文件中的某个位置(随机写)保证了磁盘顺序写。</li>
<li>数据传输的零拷贝</li>
<li>读写数据的批量batch处理以及压缩传输</li>
</ul>
<p>数据传输零拷贝原理：</p>
<p><img src="/2022/07/30/03-05-03-Kafka%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/image-20220731123736229.png" alt="image-20220731123736229"></p>
<p><strong>正常读文件：</strong></p>
<p><strong>1、broker调用scala语言api获取磁盘消息，在用户空间执行命令，底层会调用操作系统的读文件的函数</strong></p>
<p><strong>2、消息磁盘文件最先会被读到内核空间，读到操作系统的内核缓冲区</strong></p>
<p><strong>3、将内核缓冲区的数据复制到用户空间的用户缓冲区（JVM中的堆内存）</strong></p>
<p><strong>4、在程序中做一些处理，将处理之后的数据发送到socket缓冲区，在复制到网卡接口</strong></p>
<p><strong>5、最后由kafka消费程序消费</strong></p>
<p><strong>使用mmap零拷贝技术读文件：</strong></p>
<p><strong>1、上述第三步，不在将内核缓冲区的数据拷贝到用户缓冲区，而是在用户缓冲区对内核缓冲区做了一个引用、映射。直接访问这个引用，可以直接操作内核缓冲区的数据</strong></p>
<p><strong>2、kafka使用sendfile可以直接跳过socket缓冲区，直接将内核缓冲区的数据直接拷贝到网卡接口</strong></p>
<p><strong>结论：</strong></p>
<p><strong>四次拷贝变成两次</strong></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka总结</title>
    <url>/2022/07/31/03-05-04-kafka%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="hhttps://www.processon.com/view/link/62e7be845653bb07161a4b37">kafka总结</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot自动装配原理</title>
    <url>/2021/12/18/04-00-01-Spring-Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Boot</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot启动原理</title>
    <url>/2021/12/18/04-00-02-Spring-Boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Boot</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构-链表</title>
    <url>/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="数据结构之链表"><a href="#数据结构之链表" class="headerlink" title="数据结构之链表"></a>数据结构之链表</h2><p><code>二维数组的内存地址是怎么样的？写出寻址公式？</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i][j]: (i&lt;n,j&lt;m)</span><br><span class="line">loc=init_loc+(i*n+j)*size</span><br></pre></td></tr></table></figure>

<p><code>1.如何设计一个LRU缓存淘汰算法？</code></p>
<p>单链表：查找一个数据，每次查找从头开始查，如果存在并且空间足够【防止内存溢出】，删除此元素，然后插入头部；如果不存在插入头部</p>
<p><img src="/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/image-20220408010218463.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 自己用数组实现的 待优化版本</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Integer key;</span><br><span class="line">        <span class="keyword">public</span> Integer value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Entity[] arrays;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        arrays = <span class="keyword">new</span> Entity[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = -<span class="number">1</span>;</span><br><span class="line">        Entity curEntity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrays[i] != <span class="keyword">null</span> &amp;&amp; arrays[i].key == key) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                curEntity = arrays[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur; i &lt; index; i++) &#123;</span><br><span class="line">                arrays[i] = arrays[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            arrays[index] = curEntity;</span><br><span class="line">            <span class="keyword">return</span> curEntity.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrays == <span class="keyword">null</span> || arrays.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找</span></span><br><span class="line">        <span class="keyword">int</span> cur = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrays[i] != <span class="keyword">null</span> &amp;&amp; arrays[i].key == key) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur; i &lt; index; i++) &#123;</span><br><span class="line">                arrays[i] = arrays[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            arrays[index] = <span class="keyword">new</span> Entity(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span> == arrays.length) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                    arrays[i] = arrays[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                arrays[index] = <span class="keyword">new</span> Entity(key, value);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arrays[++index] = <span class="keyword">new</span> Entity(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>2.约瑟夫问题：约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。</code></p>
<p><code>例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。现在问你最后留下的人是谁？</code></p>
<p>约瑟夫问题：有 N 个人围成一圈，每个人都有一个编号，编号由入圈的顺序决定，第一个入圈的人编号为 1，最后一个为 N，从第 k (1&lt;=k&lt;=N)个人开始报数，数</p>
<p>到 m (1&lt;=m&lt;=N)的人将出圈，然后下一个人继续从 1 开始报数，直至所有人全部出圈，求依次出圈的编号。</p>
<p>循环链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.val = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 约瑟夫算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">yosef</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode cur =  head;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">7</span>;i++ )&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        ListNode prev;</span><br><span class="line">        <span class="keyword">while</span>(head.next!=head)&#123;</span><br><span class="line">			<span class="keyword">if</span>( count == M )&#123;</span><br><span class="line">                prev.next = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上述三行可换为如下</span></span><br><span class="line">            <span class="comment">// if(count == M-1)&#123;</span></span><br><span class="line">            <span class="comment">// head.next = head.next.next;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            count++;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1、什么是链表"><a href="#1、什么是链表" class="headerlink" title="1、什么是链表"></a>1、什么是链表</h3><p><code>定义：</code></p>
<p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。</p>
<p><img src="/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/image-20220407224540790.png"></p>
<p><code>特点：</code></p>
<p>(1)不需要连续的内存空间。</p>
<p>(2)有指针引用</p>
<p>(3)三种最常见的链表结构：单链表、双向链表和循环链表</p>
<p>(4)链表查找：从头节点开始遍历，一直到尾结点。O(N)</p>
<p>(5)链表插入：不需要像数组一样移动元素，也不用担心越界问题，但是要考虑内存爆炸问题。</p>
<p><img src="/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/image-20220407225614912.png"></p>
<h3 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h3><p>从单链表图中，可以发现，有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们一般把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。</p>
<p>其中，<strong>头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，</strong></p>
<p><strong>表示这是链表上最后一个结点</strong>。while(p.next != null){}  head头节点是需要自己记录的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 单链表</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> data,ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = data;</span><br><span class="line">        <span class="keyword">this</span>.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">// 头插法:插入链表的头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(data);</span><br><span class="line">        node.next = head;<span class="comment">//栈内存的引用</span></span><br><span class="line">        head = node;</span><br><span class="line">        <span class="comment">// 时间复杂度O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在pos处插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPos</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pos == <span class="number">0</span> )&#123;</span><br><span class="line">            insertHead(data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pos;i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(data);</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            node.next = next;</span><br><span class="line">            <span class="comment">// 或</span></span><br><span class="line">            <span class="comment">// node.next = cur.next;</span></span><br><span class="line">            <span class="comment">// cur.next = node;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间复杂度O(N)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">// 时间复杂度O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除pos位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePos</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pos == <span class="number">0</span> )&#123;</span><br><span class="line">            deleteHead();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pos;i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = cur.next.next;<span class="comment">// 直接断开 与 cur.next的连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间复杂度 O(N)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( cur.val == data )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="comment">// 时间复杂度 O(N)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、循环链表"><a href="#3、循环链表" class="headerlink" title="3、循环链表"></a>3、循环链表</h3><p>循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的</p>
<p>结点了。而循环链表的尾结点指针是指向链表的头结点。从循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p>
<p><img src="/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/image-20220407231159112.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## </span><br></pre></td></tr></table></figure>



<h3 id="4、双向链表"><a href="#4、双向链表" class="headerlink" title="4、双向链表"></a>4、双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结</p>
<p>点，还有一个前驱指针prev指向前面的结点。双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链</p>
<p>表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问</p>
<p>题呢？</p>
<p><img src="/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/image-20220407231351156.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##双向链表</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode pre;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = data;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNodeList</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode head;<span class="comment">//头</span></span><br><span class="line">    <span class="keyword">public</span> ListNode tail;<span class="comment">//尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNodeList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserthead</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(data);</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )&#123;</span><br><span class="line">            tail = node;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = node;</span><br><span class="line">			node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>( head.next == <span class="keyword">null</span> )&#123;</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            	head.pre = <span class="keyword">null</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除某个data</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>( cur.val == data )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( cur == head )&#123;</span><br><span class="line">            deleteHead();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( cur == tail )&#123;</span><br><span class="line">                cur.pre.next = cur.next;</span><br><span class="line">	            tail = cur.pre;</span><br><span class="line">                cur.pre = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.pre.next = cur.next;                </span><br><span class="line">                cur.next.pre = cur.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、数组VS链表"><a href="#5、数组VS链表" class="headerlink" title="5、数组VS链表"></a>5、数组VS链表</h3><p><img src="/2022/04/07/06-00-02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/image-20220407230540858.png"></p>
<p>重要区别：</p>
<ol>
<li><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读【空间局部性原理】数组中的数据，所以访问效率更高。</p>
</li>
<li><p>链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p>
</li>
<li><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。</p>
</li>
<li><p>动态扩容：数组需再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构-数组</title>
    <url>/2022/04/06/06-00-01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="数据结构之数组"><a href="#数据结构之数组" class="headerlink" title="数据结构之数组"></a>数据结构之数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">经典面试题：</span><br><span class="line">    给你一个文件里面包含全国人民（<span class="number">14</span>亿）的年龄数据（<span class="number">0</span>~<span class="number">180</span>），现在要你统计每一个年龄有多少人？</span><br><span class="line">    给定机器为 单台+2CPU+2G内存。不得使用现成的容器，比如map等。</span><br><span class="line">常用思路：</span><br><span class="line">    <span class="number">1</span>、分布式，跑多台机器。</span><br><span class="line">    <span class="number">2</span>、排序。不行×  全国<span class="number">14</span>亿，内存放不下最好的排序算法时间复杂度 O(nlogn)</span><br><span class="line">    <span class="number">3</span>、最好的方法：新建一个长度<span class="number">180</span>的数组，每次io读取一行数据，每次按照年龄到数组对应索引+<span class="number">1</span>;伪代码如下：</span><br><span class="line">        <span class="keyword">int</span>[] ageArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">180</span>];</span><br><span class="line">		<span class="keyword">int</span>[] data ;<span class="comment">// 14亿数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">14</span>亿;i++)&#123;</span><br><span class="line">            ageArray[data[i]]++;<span class="comment">//a[1]表示一岁的人有多少个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="keyword">null</span>;</span><br><span class="line">		String fileName = <span class="string">&quot;E:\\数组\\age1.txt&quot;</span>;</span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fileName),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		<span class="keyword">int</span> tot = <span class="number">0</span> ;	<span class="comment">// Integer 21亿</span></span><br><span class="line">		<span class="keyword">int</span> data [] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>];</span><br><span class="line">		<span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;		<span class="comment">//一行一行的读 O(n)</span></span><br><span class="line">			<span class="keyword">int</span> age = Integer.valueOf(str);</span><br><span class="line">			data[age] ++ ;</span><br><span class="line">			tot ++ ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//O(n) 14亿. 100万/秒 *1000 = 10亿 100~1000s之间 =&gt; 500s以下 60*8=480s</span></span><br><span class="line">		System.out.println(<span class="string">&quot;总共的数据大小: &quot;</span> + tot);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">200</span> ; i ++)&#123;<span class="comment">//下标从0开始的</span></span><br><span class="line">			System.out.println(i + <span class="string">&quot;:&quot;</span> + data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//144239ms =&gt; 144s</span></span><br><span class="line">		System.out.println(<span class="string">&quot;计算花费的时间为:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、什么是数组"><a href="#1、什么是数组" class="headerlink" title="1、什么是数组"></a>1、什么是数组</h3><ol>
<li><p>数组的定义</p>
<p>所谓数组，是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，</p>
<p>有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起</p>
<p>来的一种形式。这些无序排列的同类数据元素的集合称为数组。int 的数组你就不能存float 也不能存double</p>
<p>数组是用于储存多个相同类型数据的集合。通常用Array表示，也称之为线性表，画图演示</p>
</li>
<li><p>特点</p>
<p>(1)数组是相同数据类型的元素的集合。</p>
<p>(2)数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起。内存地址</p>
<p>(3)数组元素用整个数组的名字和它自己在数组中的顺序位置来表示。例如，a[0]表示名字为a的数组中的第一个元素，a[1]代表数组a的第二个元素，以此类</p>
<p>推。</p>
</li>
<li><p>表现形式<br>（1）一维数组</p>
<pre><code>Int a[],String a[]
</code></pre>
<p>（2）多维数组</p>
<pre><code>Int a[][],int a[][][]。 int a[m] [n] :内存空间是多少？ m*n  a [0] [10]: 链表解决，a[0]:-&gt;10&gt;2   a[1]-&gt;15
</code></pre>
</li>
<li><p>随机访问：</p>
<p>数组是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个非常重要的特性：随机访问。但有利就有弊，这两个限制也让数组的很多操作</p>
<p>变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<p>随机访问的重要应用：查找，面试重点</p>
</li>
<li><p>数组的缺点：插入和删除</p>
<p>实现代码：</p>
<p>设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。删除第N个位置的数据.</p>
</li>
<li><p>使用数组一定要注意访问越界问题。</p>
</li>
</ol>
<h3 id="2、ArrayList和数组"><a href="#2、ArrayList和数组" class="headerlink" title="2、ArrayList和数组"></a>2、ArrayList和数组</h3><p>本质是一样的，都是数组。ArrayList是JDK封装了。不需要管扩容等操作，数组的话就要你全部操作</p>
<p>两者之间应该如何选用？：</p>
<p>不知道数据大小的肯定选ArrayList。</p>
<p>如果你知道数据的大小而且你又非常关注性能那就用数组。</p>
<h3 id="3、堆栈数组"><a href="#3、堆栈数组" class="headerlink" title="3、堆栈数组"></a>3、堆栈数组</h3><p>Java分为堆栈两种内存。</p>
<p>什么是堆内存？：存放new创建的对象和数组</p>
<p>什么是栈内存？ 引用变量</p>
<p>堆栈都用Java用来存放数据的地方，与C++ /  c不一样。java自动管理我们的堆栈。gc，new出来的你没管过。</p>
<p>堆栈的区别：</p>
<ol>
<li><p><strong>栈的速度要快</strong></p>
</li>
<li><p><strong>栈内存的数据可以共享，主要存一些基本数据类型</strong>。</p>
</li>
</ol>
<p>int a = 3;    //在栈中创建变量a 然后给a赋值，先不会创建一个3而是先在栈中找有没有3，如果有直接指向。如果没有就加一个3进来。</p>
<p>int b =3;  //首先也要创建一个变量b，</p>
<h3 id="4、堆栈面试题"><a href="#4、堆栈面试题" class="headerlink" title="4、堆栈面试题"></a>4、堆栈面试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>面试经典：</span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; String str2 = <span class="string">&quot;abc&quot;</span>; System.out.println(str1==str2);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; String str2 = <span class="string">&quot;abc&quot;</span>; str1 = <span class="string">&quot;bcd&quot;</span>; </span><br><span class="line">System.out.println(str1 + <span class="string">&quot;,&quot;</span> + str2); 	<span class="comment">//bcd,abc</span></span><br><span class="line">System.out.println(str1==str2); 		<span class="comment">//false 虽然最开始 str1和str2都指向同一个变量abc但str1引用变化后不会改变str2的</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">str1 = <span class="string">&quot;bcd&quot;</span>; </span><br><span class="line">String str3 = str1; </span><br><span class="line">System.out.println(str3);  <span class="comment">//bcd</span></span><br><span class="line">String str4 = <span class="string">&quot;bcd&quot;</span>; </span><br><span class="line">System.out.println(str1 == str4);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">System.out.println(str1==str2); 	<span class="comment">//false  new在堆内存中新开了一个对象</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="string">&quot;ja&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;va&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">String s4 = s1 + s2; <span class="comment">//java 注意这个+号，java里面重载了+，其实调用了stringBuild，会new对象。</span></span><br><span class="line">System.out.println(s3 == s4);	<span class="comment">//false</span></span><br><span class="line">System.out.println(s3.equals(s4));	<span class="comment">//true 只是比较值</span></span><br></pre></td></tr></table></figure>

<h3 id="5、思考"><a href="#5、思考" class="headerlink" title="5、思考"></a>5、思考</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为什么很多计算机编程语言中数组的下标要从<span class="number">0</span>开始呢？</span><br><span class="line">定义一个数组一定会分配内存空间。数组的特点是内存是一段连续的地址。从<span class="number">0</span>开始便于定位其它索引地址，减少计算</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">到内存中申请空间：<span class="number">10001</span>,<span class="number">10002</span>,<span class="number">10003</span></span><br><span class="line">存数据</span><br><span class="line">a[<span class="number">0</span>] =&gt; <span class="number">10001</span>  ====&gt; <span class="number">10001</span>+<span class="number">0</span>*typesize</span><br><span class="line">a[<span class="number">1</span>] =&gt;  <span class="number">10002</span> =====&gt; <span class="number">10001</span>+<span class="number">1</span>*typesize</span><br><span class="line">a[<span class="number">2</span>]=&gt;   <span class="number">10003</span> =====&gt; <span class="number">10001</span>+<span class="number">2</span>*typesize</span><br><span class="line">如果我们不从<span class="number">0</span>开始 </span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10001</span>+(<span class="number">1</span>-<span class="number">1</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">10001</span>+(<span class="number">2</span>-<span class="number">1</span>)</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">10001</span>+(<span class="number">3</span>-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6、算法题"><a href="#6、算法题" class="headerlink" title="6、算法题"></a>6、算法题</h3><p><code>Leetcode70爬楼梯</code></p>
<p><code>题目描述</code>：</p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><code>思路分析</code>：</p>
<p>n阶楼梯：</p>
<ol>
<li>最后一步爬一个台阶 则方法数 f(n-1)</li>
<li>最后一步爬两个台阶 则方法数f(n-2)</li>
</ol>
<p>总方法数为f(n-1) + f(n-2);  当n=1,方法数为1，当n=2,方法数为2；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## <span class="number">1</span>、迭代法[最优法]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( n== <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( n ==<span class="number">2</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> N =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            N = first + next;</span><br><span class="line">            first = next;</span><br><span class="line">            next = N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">## <span class="number">2</span>、递归</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">climbStairs2</span><span class="params">(Integer n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( n== <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">2</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( map.get(n) != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = climbStairs2(n-<span class="number">1</span>)+climbStairs2(n-<span class="number">2</span>);</span><br><span class="line">            map.put(n,result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>剑指Offer Leetcode10斐波拉契数列</code></p>
<p><code>题目描述:</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span></span><br><span class="line">斐波那契数列由 <span class="number">0</span> 和 <span class="number">1</span> 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line">答案需要取模 <span class="number">1e9</span>+<span class="number">7</span>（<span class="number">1000000007</span>），如计算初始结果为：<span class="number">1000000008</span>，请返回 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p><code>思路分析:</code></p>
<p>f(n)=f(n-1)+f(n-2);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## <span class="number">1</span>、递归</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">## <span class="number">2</span>、双指针迭代</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,second=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = second;</span><br><span class="line">        <span class="keyword">int</span> second = first + second;</span><br><span class="line">        first = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Leetcode1两数之和</code></p>
<p><code>题目描述：</code></p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><code>思路分析：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## <span class="number">1</span>、最优解</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(target-nums[i]) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(target-nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">## <span class="number">2</span>、双重<span class="keyword">for</span>循环 暴力破解 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构-栈</title>
    <url>/2022/04/08/06-00-03-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><code>经典算法题:</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、如何设计一个括号匹配的功能？比如给你一串括号让你判断是否符合我们的括号原则，如下所示：</span><br><span class="line">[()&#123;()&#125;&#123;&#125;]符合&#123;&#125;[]&#123;[][[]</span><br><span class="line">[][]&#123;[](&#125;)</span><br><span class="line">&#123;&#125;[&#125;&#125;&#123;&#125;&#125;]]] 不符合</span><br><span class="line"><span class="number">2</span>、如何设计一个浏览器的前进和后退功能？</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    ## 栈数据结构处理</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String ss)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;[&#x27;</span> == ss.charAt(i) || <span class="string">&#x27;(&#x27;</span> == ss.charAt(i) || <span class="string">&#x27;&#123;&#x27;</span> == ss.charAt(i))&#123;</span><br><span class="line">                stack.push(ss.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Character ch = stack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>( !(ch == <span class="string">&#x27;[&#x27;</span> &amp;&amp; ss.charAt(i) == <span class="string">&#x27;]&#x27;</span>|| ch == <span class="string">&#x27;(&#x27;</span> &amp;&amp; ss.charAt(i) == <span class="string">&#x27;)&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; ss.charAt(i) == <span class="string">&#x27;&#125;&#x27;</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();<span class="comment">// 栈为空 才有匹配 有值  说明左括号比较多</span></span><br><span class="line">    &#125;</span><br><span class="line">    ## 字符串替换</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String ss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            s = s.replace(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;[]&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;()&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、什么是栈"><a href="#1、什么是栈" class="headerlink" title="1、什么是栈"></a>1、什么是栈</h3><p><code>如何理解栈</code></p>
<p>比如我们在放盘子的时候都是从下往上一个个放，拿的时候是从上往下一个个的那，不能从中间抽，这种其实就是一个典型的栈型数据结构。后进先出即Last In </p>
<p>First Out （LIFO）。</p>
<p><code>栈如何实现</code></p>
<p>其实它是一个限定仅在<strong>表尾</strong>进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是</p>
<p>把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<p>栈其实就是一个特殊的链表或者数组。</p>
<p>既然栈也是一个线性表，那么我们肯定会想到数组和链表，而且栈还有这么多限制，那为什么我们还要使用这个数据结构呢？不如直接使用数组和链表来的更直接</p>
<p>么？数组和链表暴露太多的接口，实现上更灵活了，有些技术理解不到位的人员就可能出错。所以在某些特定场景下最好是选择栈这个数据结构。</p>
<p>3.栈的分类</p>
<ul>
<li>（1）基于数组的栈——以数组为底层数据结构时，通常以数组头为栈底，数组头到数组尾为栈顶的生长方向</li>
</ul>
<p><img src="/2022/04/08/06-00-03-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/image-20220408220827005.png" alt="基于数组的栈"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];		<span class="comment">//最好就是开始的时候就设置大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;		<span class="comment">//大小 初始的元素个数</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">		a = (Item[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;	<span class="comment">//入栈就完成了		//时间复杂度 O(1)</span></span><br><span class="line">		</span><br><span class="line">		judgeSize();</span><br><span class="line">		a[n++] = item;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judgeSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &gt;= a.length)&#123;		<span class="comment">//元素个数已经超出了数组的个数</span></span><br><span class="line">			resize(<span class="number">2</span> * a.length);		<span class="comment">//10*2*2=40个大小了，我出栈了20个了，只剩下20了吧。</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; n &lt;= a.length / <span class="number">2</span>)&#123;</span><br><span class="line">			resize(a.length / <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;		<span class="comment">//扩容O（n）</span></span><br><span class="line">		Item[] temp = (Item[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i ++)&#123;</span><br><span class="line">			temp[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		a = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;		<span class="comment">//出栈 O(1)</span></span><br><span class="line">		<span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//item[n--]</span></span><br><span class="line">		<span class="comment">//item[--n]</span></span><br><span class="line">		Item item = a[--n];	<span class="comment">//n不是已经--了么 --n和n-- --n是先把n减了在用，n--先用了在减</span></span><br><span class="line">		a[n] = <span class="keyword">null</span>;	<span class="comment">//为什么要这一步</span></span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>（2）基于单链表的栈——以链表为底层的数据结构时，以链表头为栈顶，便于节点的插入与删除，压栈产生的新节点将一直出现在链表的头部</li>
</ul>
<p><img src="/2022/04/08/06-00-03-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/image-20220408220833196.png" alt="基于单链表的栈"></p>
<p><strong>最大的区别就是扩容，链表天然支持动态扩容。栈溢出。</strong></p>
<p>比较常用的是数组，链表容易溢出，数组可以灵活的控制长度。</p>
<p>4.栈的基本操作：假定以数组来实现</p>
<p>(1)入栈</p>
<p>(2)出栈</p>
<p>(3)时间复杂度分析</p>
<h3 id="2、栈的应用"><a href="#2、栈的应用" class="headerlink" title="2、栈的应用"></a>2、栈的应用</h3><ul>
<li><p>函数调用就是用栈来实现的</p>
</li>
<li><p>数学表达式求值：</p>
<p>比如用栈实现一个简单的四则运算：3+11*2+8-15/5，用栈来实现这个算术表达式</p>
<p>两个栈来实现：一个放数字 一个放符号。</p>
<p>我们从头开始遍历这个算术表达式：</p>
<p>1.遇到是数字 我们就直接入栈到数字栈里面去。</p>
<p>2.遇到是符合 就把符号栈的栈顶拿出来做比较。如果说他比栈顶符号的优先级高就直接入栈，如果比符号栈顶的优先级低或者相同，就从符号栈里面取栈顶进</p>
<p>行计算（从数字栈中取栈顶的2个数），计算完的结果还要再放入到数字栈中。</p>
</li>
<li><p>四则运算</p>
<p><img src="/2022/04/08/06-00-03-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/image-20220409001447367.png" alt="四则运算"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## opt 保存上一个操作符  num 保存上一个操作数  ch 是当前字符</span><br><span class="line">## 每次ch为一个操作符时   判断上一个操作符 opt的情况 根据类型 做不同操作（操作数为 栈顶元素  和 上一个操作数 num）</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> opt = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((!Character.isDigit(ch) &amp;&amp; <span class="string">&#x27; &#x27;</span> != ch) || i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stack.push(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stack.push(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stack.push(stack.pop() * num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stack.push(stack.pop() / num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                opt = ch;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法思想</title>
    <url>/2022/05/03/06-00-05-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://programmercarl.com/">讲解算法比较好的博客</a></p>
<h2 id="一、动态规划"><a href="#一、动态规划" class="headerlink" title="一、动态规划"></a>一、动态规划</h2><h3 id="1、动态规划定义"><a href="#1、动态规划定义" class="headerlink" title="1、动态规划定义"></a>1、动态规划定义</h3><p>​        如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策，每一个阶段都有若干个策略可供选择，一个阶段的策略确定以后，形成了本阶段的决策，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为<strong>多阶段决策问题</strong>。</p>
<p>当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。在多阶段决策问题中，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为<strong>动态规划方法</strong>。</p>
<p>​        动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，分治法基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解，但是分治法里子问题之间往往是互相独立的，可以并行求解。</p>
<h3 id="2、动态规划的解题步骤"><a href="#2、动态规划的解题步骤" class="headerlink" title="2、动态规划的解题步骤"></a>2、动态规划的解题步骤</h3><p>对于一个动态规划题目，有没有什么比较通用的求解步骤呢？可以采用下面的办法：</p>
<p>1、确定状态转移公式，当前的状态是怎么由前面的状态变化而来的及其与之相关联的辅助的dp数组（dp table）以及下标的含义。这一步往往也是最难的，这一步想清楚了，整个动态规划的问题基本上可以说就解决了一大半。一般来说，首先要确定dp数组中元素代表的意义，然后在这个意义之下，确定状态是如何在dp数组的元素之间如何变化的。</p>
<p>2、初始化dp数组。</p>
<p>3、根据题目条件开始遍历，并实现状态转移公式。</p>
<p>同时在实现的过程中，可以适当的输出dp数组的值，确定自己的代码实现思路无误。具体怎么做，我们用一个实际的题目来说明。</p>
<h3 id="3、什么样的问题适合用动态规划？"><a href="#3、什么样的问题适合用动态规划？" class="headerlink" title="3、什么样的问题适合用动态规划？"></a>3、什么样的问题适合用动态规划？</h3><p>什么样的问题适合用动态规划来解决呢?换句话说,动态规划能解决的问题有什么规律可循呢?</p>
<p>我们在前面所说的动态规划的定义就已经包含了这个问题的答案。它指的是动态规划适合解决的问题的模型就是“ 多阶段决策最优解模型”。</p>
<p>我们一般是用动态规划来解决最优问题。而解决问题的过程,需要经历多个决策阶段。每个决策阶段都对应着一组状态。 然后我们寻找一组决策序列 ,经过这组决策序列,能够产生最终期望求解的最优值。</p>
<p>而这个模型同时具备三个特征， 它们分别是最优子结构、无后效性和重复子问题。这三个概念比较抽象,我来逐一详细解释一 下。</p>
<p>1.最优子结构</p>
<p>最优子结构指的是,问题的最优解包含子问题的最优解。反过来说就是,我们可以通过子问题的最优解,推导出问题的最优解。如果我们把最优子结构,对应到我们前面定义的动态规划问题模型上,那我们也可以理解为,后面阶段的状态可以通过前面阶段的状态推导出来，前面的背包问题中，大背包的最优解需要通过小背包的最优解推导出来。</p>
<p>2.无后效性</p>
<p>无后效性有两层含义,第一层含义是,在推导后面阶段的状态的时候,我们只关心前面阶段的状态值,不关心这个状态是怎么一步一步推导出来的。 第二层含义是,某阶段状态一旦确定,就不受之后阶段的决策影响，这一点在背包问题中也很明显，小背包的解确定了，后面的大背包怎么解跟小背包没什么关系了，而且大背包在求解过程中使用小背包的解时，也不关心小背包的解怎么来的，都是直接使用。</p>
<p>3.重复子问题</p>
<p>我们在求解后面的阶段时，往往需要对前面的阶段反复求解，也就是有些子问题的求解是重复的。所以动态规划算法通常这样利用重复子问题性质：对每个子问题求解一次， 将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。从前面的背包问题中也可以看到这一点。</p>
<h2 id="二、回溯"><a href="#二、回溯" class="headerlink" title="二、回溯"></a>二、回溯</h2><h3 id="1、什么是回溯法"><a href="#1、什么是回溯法" class="headerlink" title="1、什么是回溯法"></a>1、什么是回溯法</h3><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p>
<h3 id="2、回溯法的效率"><a href="#2、回溯法的效率" class="headerlink" title="2、回溯法的效率"></a>2、回溯法的效率</h3><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？</p>
<p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<h3 id="3、回溯法解决的问题"><a href="#3、回溯法解决的问题" class="headerlink" title="3、回溯法解决的问题"></a>3、回溯法解决的问题</h3><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>组合和排列的区别</strong></p>
<p>组合是不强调元素顺序的，排列是强调元素顺序。</p>
<p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p>
<p>记住组合无序，排列有序，就可以了。</p>
<h3 id="4、如何理解回溯法"><a href="#4、如何理解回溯法" class="headerlink" title="4、如何理解回溯法"></a>4、如何理解回溯法</h3><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<h3 id="5、回溯法模板【重点】"><a href="#5、回溯法模板【重点】" class="headerlink" title="5、回溯法模板【重点】"></a>5、回溯法模板【重点】</h3><ul>
<li>回溯函数模板返回值以及参数</li>
</ul>
<p>在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。</p>
<p>回溯算法中函数返回值一般为void。</p>
<p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p>
<p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p>
<p>回溯函数伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></table></figure>

<p>1</p>
<ul>
<li>回溯函数终止条件</li>
</ul>
<p>既然是树形结构，就知道遍历树形结构一定要有终止条件。</p>
<p>所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p>
<p>所以回溯函数终止条件伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯搜索的遍历过程</li>
</ul>
<p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p>
<p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p>
<p>回溯函数遍历过程伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p>
<p>backtracking这里自己调用自己，实现递归。</p>
<p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p>
<p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>回溯算法</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构-队列</title>
    <url>/2022/04/09/06-00-04-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="1、什么是队列"><a href="#1、什么是队列" class="headerlink" title="1、什么是队列"></a>1、什么是队列</h3><p><code>队列的定义：</code></p>
<p>定义：队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受</p>
<p>限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p>
<p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以</p>
<p>只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表，LIFO。树</p>
<p>队列这个概念非常好理解。你可以把它想成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。</p>
<p>栈：后进先出。</p>
<p><code>队列的特点</code></p>
<p>（1）线性表：链表或者数组</p>
<p>（2）FIFO</p>
<p><code>队列的分类</code></p>
<ul>
<li><p>（1）顺序（单向）队列：（Queue） 只能在一端插入数据，另一端删除数据</p>
<p><img src="/2022/04/09/06-00-04-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/image-20220409122653217.png" alt="单向队列"></p>
</li>
<li><p>（2）循环（双向）队列（Deque）：每一端都可以进行插入数据和删除数据操作</p>
</li>
</ul>
<p><img src="/2022/04/09/06-00-04-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/image-20220409122711940.png" alt="循环队列"></p>
<p><code>队列的基本操作</code></p>
<p>队列的基本操作：</p>
<p>两个基本操作：入栈push()和出栈pop()。队列跟栈非常相似，支持的操作也很有限，</p>
<p>最基本的操作也是两个：</p>
<p>入队enqueue()，放一个数据到队列尾部；</p>
<p>出队dequeue()，从队列头部取一个元素。</p>
<p>所以，队列跟栈一样，也是一种操作受限的线性表数据结构。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如</p>
<p>循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。</p>
<h3 id="2、队列的实现"><a href="#2、队列的实现" class="headerlink" title="2、队列的实现"></a>2、队列的实现</h3><p><code>实现方式：</code></p>
<p><strong>顺序队列&amp;链式:</strong></p>
<p>链表就是可以无限扩容:内存 size大小控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 数组实现队列</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cap;<span class="comment">// 数组的大小，最大容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        cap = n;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 满了</span></span><br><span class="line">        <span class="keyword">if</span>( tail == cap )&#123;</span><br><span class="line">            <span class="comment">// 这里可以优化 把数据往前移动</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data[tail++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 为空</span></span><br><span class="line">        <span class="keyword">if</span>( head == tail )&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[head++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 用单向链表实现队列</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNodeQueue</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> ListNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = data;</span><br><span class="line">            next = <span class="keyword">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode head;</span><br><span class="line">    <span class="keyword">public</span> ListNode tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cap;<span class="comment">// 总容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;<span class="comment">// 当前容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNodeQueue</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">        cap = cap;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( size == cap )&#123;</span><br><span class="line">            <span class="keyword">return</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( size == <span class="number">0</span> )&#123;</span><br><span class="line">            head = <span class="keyword">new</span> ListNode(data);</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> ListNode(data);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pop取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( head == tail )&#123;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列</strong></p>
<p>怎么判断队列已经满了？</p>
<p>两种方法：</p>
<p>1、加了一个实际的size变量就可以了。</p>
<p>2、判断满：(tail+1)%n==head</p>
<p>怎么判断空？tail==head</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 循环队列</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="number">0</span>;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        cap = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列满 下面这种判断  等同于 (tail-head == -1) || (tail - head == cap -1)</span></span><br><span class="line">        <span class="keyword">if</span>( (tail+<span class="number">1</span>)%cap == head )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        data[tail]=data;</span><br><span class="line">        tail = (tail+<span class="number">1</span>)%cap; <span class="comment">// 这种判断防止越界从 cap-1 到 0  等同于 if(tail+1 == cap) tail =0; else tail++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == tail )&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> data = data[head];</span><br><span class="line">        head = (head+<span class="number">1</span>)%cap;<span class="comment">// 这种判断防止越界从 cap-1 -&gt; 0</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>push的时候：    </p>
<p>// 队列满 下面这种判断  等同于 (tail-head == -1) || (tail - head == cap -1)<br>        if( (tail+1)%cap == head ){<br>            return;<br>        }   </p>
<p>这种判断会浪费一个存储单元</p>
<p><img src="/2022/04/09/06-00-04-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/image-20220409170649951.png" alt="循环链表浪费一个存储空间"></p>
<p><strong>优先队列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 具体实现 后续补充 [本质是插入的时候排序]</span><br></pre></td></tr></table></figure>

<p><strong>阻塞队列</strong></p>
<p>此种具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。阻塞队列其实就是在队列基础上增加了阻塞操作。<strong>简单来说，就是在队列为空的时候，从队</strong></p>
<p><strong>头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再</strong></p>
<p><strong>插入数据，然后再返回。</strong></p>
<p>CPU：</p>
<p>线程池里面当任务满时，此时又来一个新任务，线程池是如何处理的？具体有哪些策略？这些策略又是如何实现的呢？</p>
<p>有几种处理策略：</p>
<p>1.排队：阻塞队列。有空闲的时候再拿，不就是那个take和put，如果是在公平的情况下，那肯定就是先进先出。这就是今天讲的队列。这时候我们就有两种方</p>
<p>式，一个是无限的排队队列。（链表，千万别用。LinkedBlockingQueue，JDK的），还有一种就是有界（用数组来实现的），只处理我们开的空间大小，多了的</p>
<p>继续抛出去。Integer.MAX=?2^32-1=21亿多，但是注意的是这个队列大小，别搞小了。就不够，大了就浪费。在一些小型系统，你知道数据请求量是不大的，可</p>
<p>以用。</p>
<p>2.丢弃：不处理了，直接抛出去。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题复习</title>
    <url>/2022/05/31/06-00-06-%E7%AE%97%E6%B3%95%E9%A2%98%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="1、两数之和-04-12"><a href="#1、两数之和-04-12" class="headerlink" title="1、两数之和    04.12"></a>1、<a href="https://leetcode.cn/problems/two-sum/">两数之和</a>    04.12</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(target - nums[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、两数相加-04-13"><a href="#2、两数相加-04-13" class="headerlink" title="2、两数相加  04.13"></a>2、<a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a>  04.13</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        ListNode resultNode = <span class="keyword">null</span>,falg=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">int</span> l1Value=<span class="number">0</span>,l2Value=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( l1 != <span class="keyword">null</span> )&#123;</span><br><span class="line">                l1Value = l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( l2 != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                l2Value = l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> result = l1Value + l2Value + temp,cur=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( result &gt;= <span class="number">10</span> )&#123;</span><br><span class="line">                cur = result-<span class="number">10</span>;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = result;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( resultNode == <span class="keyword">null</span> )&#123;</span><br><span class="line">                resultNode = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">                falg = resultNode;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resultNode.next = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">                resultNode = resultNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( temp != <span class="number">0</span> )&#123;</span><br><span class="line">            resultNode.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> falg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、无重复字符的最长子串-【重点复习】"><a href="#3、无重复字符的最长子串-【重点复习】" class="headerlink" title="3、无重复字符的最长子串   【重点复习】"></a>3、<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>   【重点复习】</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( s.length() &lt;= <span class="number">1</span>  )&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(start=<span class="number">0</span>,end=<span class="number">0</span>;end&lt;s.length();end++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(ch) )&#123;</span><br><span class="line">                start = Math.max(start,map.get(ch));</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end-start+<span class="number">1</span>);</span><br><span class="line">            map.put(ch,end+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原创</span></span><br><span class="line">    <span class="comment">// public int lengthOfLongestSubstring(String s) &#123;</span></span><br><span class="line">    <span class="comment">//     if( s == null )&#123;</span></span><br><span class="line">    <span class="comment">//         return 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     int res=0;</span></span><br><span class="line">    <span class="comment">//     String subStr=&quot;&quot;;</span></span><br><span class="line">    <span class="comment">//     for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int index = subStr.indexOf(s.charAt(i) + &quot;&quot;);</span></span><br><span class="line">    <span class="comment">//         if( index == -1 )&#123;</span></span><br><span class="line">    <span class="comment">//             res = Math.max(res,subStr.length()+1);</span></span><br><span class="line">    <span class="comment">//             subStr += s.charAt(i) + &quot;&quot;;</span></span><br><span class="line">    <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//             subStr = subStr.substring(subStr.indexOf(s.charAt(i) + &quot;&quot;)+1);</span></span><br><span class="line">    <span class="comment">//             subStr += s.charAt(i) + &quot;&quot;;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 时间复杂度 o(m+n)</span><br><span class="line">解法一：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n+m];</span><br><span class="line">        <span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=(m+n)/<span class="number">2</span>;i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( p1 &gt;= m || ( p2 &lt; n &amp;&amp; nums1[p1]&gt;nums2[p2] ))&#123;</span><br><span class="line">                result[i] = nums2[p2++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[i] = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( (n+m)%<span class="number">2</span>==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(result[result.length/<span class="number">2</span>-<span class="number">1</span>] + result[result.length/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result[result.length/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5  =&gt;nums1.length/2-1   nums1.length/2</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4   =&gt; nums1.length/2</span></span><br><span class="line">&#125;</span><br><span class="line">## 求中位数的过程可以看作求第nums1.length/<span class="number">2</span>-<span class="number">1</span>   nums1.length/<span class="number">2</span>小的数</span><br><span class="line">解法二[快速排序]：    </span><br><span class="line"> <span class="comment">// 解法二 快排 转换为求第N   nums1.length/2-1   nums1.length/2 小的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays2</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            result[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] nums = quickSort(result, <span class="number">0</span>, result.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n + m) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (nums[nums.length / <span class="number">2</span> - <span class="number">1</span>] + nums[nums.length / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= nums.length || end &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> partIndex = partition(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; partIndex) &#123;</span><br><span class="line">            quickSort(nums, start, partIndex - <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">         <span class="keyword">if</span> (end &gt; partIndex) &#123;</span><br><span class="line">            quickSort(nums, partIndex + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pRandom = (<span class="keyword">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> zoneIndex = start - <span class="number">1</span>;</span><br><span class="line">        swap(nums, pRandom, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[end]) &#123;</span><br><span class="line">                zoneIndex++;</span><br><span class="line">                <span class="keyword">if</span> (zoneIndex &lt; i) &#123;</span><br><span class="line">                    swap(nums, zoneIndex, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zoneIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">## 求中位数的过程可以看作求第nums1.length/<span class="number">2</span>-<span class="number">1</span>   nums1.length/<span class="number">2</span>小的数</span><br><span class="line">解法三[最小堆排序]：  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小堆解法 todo 需要优化</span></span><br><span class="line">    <span class="comment">// 解法二 快排 转换为求第N   nums1.length/2-1   nums1.length/2 小的数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length,len = m+n;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            result[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] nums = quickSort(result, <span class="number">0</span>, result.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((n + m) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (nums[nums.length / <span class="number">2</span> - <span class="number">1</span>] + nums[nums.length / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            swap(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(nums,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            adjustHeap(nums,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex=i,left=i/<span class="number">2</span>+<span class="number">1</span>,right=i/<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( left&lt;len &amp;&amp; nums[left]&lt;nums[minIndex] )&#123;</span><br><span class="line">            minIndex = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( right&lt;len &amp;&amp; nums[right] &lt; nums[left] &amp;&amp; nums[right] &lt; nums[minIndex] )&#123;</span><br><span class="line">            minIndex = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i != minIndex )&#123;</span><br><span class="line">            adjustHeap(nums,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">注：后面两种效率需要优化，需要做下截断</span><br></pre></td></tr></table></figure>

<h3 id="5、最长回文子串-待补充"><a href="#5、最长回文子串-待补充" class="headerlink" title="5、最长回文子串  待补充"></a>5、<a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a>  待补充</h3><h3 id="6、-正则表达式匹配-待补充"><a href="#6、-正则表达式匹配-待补充" class="headerlink" title="6、 正则表达式匹配 待补充"></a>6、<a href="https://leetcode.cn/problems/regular-expression-matching/"> 正则表达式匹配</a> 待补充</h3><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>这几天好像突然搞懂了递归的套路，比如说二叉树的这种题经常可以用递归的思想来解决。<strong>我不管你是怎么遍历的，我只需要明确我的递归函数的作用是什么，千万不要跳到递归函数中去用你的人脑压栈</strong>。 比如说找最近公共祖先这道题，算法的框架是这样的，我就让递归函数TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)的作用是从当前根节点向下搜索 p、q是否存在于当前节点的左右子树中，找到就返回相应的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"><span class="comment">//找到了q或p节点或者跨过了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l_res = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode r_res = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"><span class="comment">//如果在当前节点的左右子树中分别找到了给定了两个节点，则当前节点就是最近的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(l_res != <span class="keyword">null</span> &amp;&amp; r_res != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">//在左右子树中搜索的结果如果不是均不为null，说明给定的两个节点中存在包含关系，即一个节点在另一个节点的子树中，这时最近的公共祖先就是不为null的那个节点</span></span><br><span class="line">        <span class="keyword">return</span> l_res == <span class="keyword">null</span> ? r_res : l_res;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理</title>
    <url>/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="1、进程的概念"><a href="#1、进程的概念" class="headerlink" title="1、进程的概念"></a>1、进程的概念</h2><p>​        运行中的程序就叫做<strong>进程</strong>。</p>
<h2 id="2、并行与并发"><a href="#2、并行与并发" class="headerlink" title="2、并行与并发"></a>2、并行与并发</h2><p>​        并发是一种<strong>物理架构</strong>，多个cpu核同一时间执行多个任务。而并行是一种<strong>逻辑架构</strong>，在一个核上，多个任务通过竞争时间片交替执行。</p>
<p>​        并行与并发的关系图</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.png"></p>
<h2 id="3、进程的状态"><a href="#3、进程的状态" class="headerlink" title="3、进程的状态"></a>3、进程的状态</h2><p>​        <strong>单进程五状态模型：</strong></p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E4%BA%94%E6%88%96%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="进程5/7状态模型"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程进入就绪队列，就会变为就绪状态，各个状态转换如下：</span><br><span class="line">1、就绪-&gt;运行，当操作系统内存在着调度程序，当需要运行一个新进程时，调度程序选择一个就绪状态的进程，让其进入运行状态</span><br><span class="line">2、运行-&gt;就绪，运行态的进程，会占有cpu，每个进程会被分配一定的执行时间，时间片用完，状态就由运行态变为就绪状态</span><br><span class="line">3、运行-&gt;阻塞，进程请求调用操作系统的某些服务，但是操作系统没法立即给到它（比如这些服务需要比较耗时的初始化，比如io资源需要等待等），那么它就会进入阻塞状态</span><br><span class="line">4、阻塞-&gt;就绪，当等待结束了，就由阻塞进入就绪状态</span><br><span class="line">5、运行-&gt;终止，当前进程表示自己已经完成了，它就会被操作系统终止</span><br></pre></td></tr></table></figure>

<h2 id="4、进程的控制结构"><a href="#4、进程的控制结构" class="headerlink" title="4、进程的控制结构"></a>4、进程的控制结构</h2><p>​        在操作系统中，是用<strong>进程控制块</strong>（pcb）数据结构来描述进程的。</p>
<p>​        pcb是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个pcb,如果进程消失了，那么pcb也会消失。</p>
<p>​        pcb包含的信息：</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403214515124.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、进程管理：寄存器、程序计数器、堆栈指针、进程状态、优先级、调度参数、进程ID、父进程、进程组、信号...</span><br><span class="line">2、存储管理：Text段指针、数据段指针、堆栈段指针</span><br><span class="line">3、文件管理：根目录、工作目录、文件描述符、用户ID、组ID</span><br></pre></td></tr></table></figure>

<p>pcb组织形式：</p>
<p>通常是通过<strong>链表</strong>的方式进行组织，把具有相同状态的进程链在一起，组成各种队列，比如：</p>
<ol>
<li><p>所有处于就绪状态的进程链在一起，称为就绪队列</p>
</li>
<li><p>把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列</p>
<p>链表方式：</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403214747723.png"></p>
<p>除了链表的方式，还有索引的方式，如下图。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403214811202.png"></p>
</li>
</ol>
<h2 id="5、进程的切换"><a href="#5、进程的切换" class="headerlink" title="5、进程的切换"></a>5、进程的切换</h2><p>当一个正在运行的进程被中断，操作系统指定另一个就绪态的进程进入运行状态，这个过程就是<strong>进程切换</strong>，也叫<strong>上下文切换</strong>。</p>
<p><strong>该切换过程一般涉及以下步骤：</strong></p>
<p>1.保存处理器上下文环境</p>
<p>2.更新当前进程的pcb</p>
<p>3.将当前进程移到就绪队列或阻塞队列</p>
<p>4.根据调度算法，选择就绪队列中的一个合适的进程，将其更改为运行状态</p>
<p>5.更新内存管理的数据结构</p>
<p>6.新进程内对堆栈所保存的上下文信息载入到cpu的寄存器和程序计数器，占有cpu</p>
<p><strong>发生进程切换的场景</strong></p>
<ol>
<li>为了保证所有进程可以得到公平调度，cpu的时间被划分为一段段时间片，这些时间片在被轮流分配给各个进程，这样当某个进程时间片用尽后，就会被系统挂起，切换到其它正在等在cpu的进程运行</li>
<li>进程在系统资源不足时，需要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其它进程运行</li>
<li>当进程通过睡眠函数sleep这样的方法将自己主动挂起时，自然也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级的先运行 ，当前进程也会挂起，由高优先级进程来运行。</li>
<li>发生硬件中断时，cpu上的 的进程也会被挂起，转而执行内核中的中断服务程序。</li>
</ol>
<h2 id="6、线程"><a href="#6、线程" class="headerlink" title="6、线程"></a>6、线程</h2><p><strong>进程是资源分配的最小单位，线程是cpu调度的基本单位，线程是进程中的一条执行流程，一个进程包含多个线程，线程又被称之为轻量级进程。</strong></p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件资源等，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流程是独立的。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215049674.png"></p>
<p><strong>线程上下文切换的是什么</strong></p>
<ol>
<li>当两个线程不属于同一个进程，则切换的过程就跟进程切换是一样的</li>
<li><strong>当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就会保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong></li>
</ol>
<p>所以线程的上下文切换要别进程上下文切换开销小的多。</p>
<h2 id="7、进程调度"><a href="#7、进程调度" class="headerlink" title="7、进程调度"></a>7、进程调度</h2><p><strong>什么时候进行调度：</strong></p>
<ol>
<li><p>从就绪状态-&gt;运行状态</p>
</li>
<li><p>从运行状态-&gt;阻塞状态</p>
</li>
<li><p>从运行状态-&gt;结束状态</p>
</li>
</ol>
<p><strong>调度算法分为两类：</strong></p>
<ul>
<li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li>
<li>抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列中挑选另外一个进程，这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把cpu控制返回给调度程序进行调度，这就是常说的<strong>时间片机制</strong>。</li>
</ul>
<p><strong>以什么原则来调度进程</strong></p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215344419.png"></p>
<p>五种调度原则：</p>
<ul>
<li>cpu利用率</li>
<li>系统吞吐量</li>
<li>周转时间</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<p><strong>进程调度算法</strong></p>
<ul>
<li><p>先来先服务：先进就绪队列，则先被调度。问题：当前面任务耗费很长时间执行，那么后面的任务只需要执行很短的时间，也必须一直等待，属于<strong>非抢占式</strong></p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215428609.png"></p>
</li>
<li><p>时间片轮转：每个进程会被分配时间片，表示运行该进程在这个时间段运行，如果时间结束了，进程还没有运行完毕，那么会通过抢占式调度，将cpu分配给其它进程，该进程回到就绪队列。这是一种最简单最公平的调度算法，但是有可能会存在问题。<strong>缺点：</strong>如果时间片太短，频繁进行切换，会影响效率。如果进程时间片太长，有可能导致排后面的进程等待太长时间。因此时间片的长度，需要有大致合理的数值。（一般建议时间片20ms~50ms）</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215506907.png"></p>
</li>
<li><p>最短作业优先：按照作业时长排队，作业时间短的排前面先执行。缺点：一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使长作业不断的往后推，致使长作业不会被运行。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215604603.png"></p>
</li>
<li><p>最短剩余时间优先：从就绪队列中选择剩余时间最短的进程进行调度。该算法可以理解为最短作业优先和时间片轮转的结合。如果没有时间片，那么最短剩余时间其实就是最短作业时间，因为每个进程都是从投执行到尾。</p>
</li>
<li><p>优先级调度：按照优先级来调度。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215629550.png"></p>
</li>
<li><p>多级反馈队列调度：设置多个就绪队列，赋予每个就绪队列优先级，优先级越高的队列进程的时间片越短。兼顾了长短作业，同时有较好的响应时间。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215655867.png"></p>
</li>
</ul>
<h2 id="8、进程间通信"><a href="#8、进程间通信" class="headerlink" title="8、进程间通信"></a>8、进程间通信</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间都是每个进程共享的，所以进程之间的通信必须通过内核。</p>
<p>进程间的通信目的一般有共享数据、数据传输、消息通知、进程控制等。进程间的通信方式：共享<strong>内存、管道、消息队列、信号量</strong>。</p>
<ul>
<li><p>管道：管道传输数据是单向的。匿名管道：用完了就销毁，如linux 【|】。<strong>缺点：</strong>通信方式效率低，不适合进程间频繁的交换数据。<strong>好处：</strong>简单，同时我们也很容易的知道管道里面的数据已经被另一个进程读取了。<strong>对于匿名管道，它的通讯范围是存在父子关系的进程。对于命名管道，可以在不相关的进程间通信，基于文件。</strong></p>
</li>
<li><p>消息队列：消息队列是保存在内核中的消息链表。A进程给B进程发送消息，A进程把数据放在对应的消息队列后就可以返回了，B进程需要的时候再去读取数据就可以换了，数据读完后，内核会将数据删除掉。如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。<strong>缺点：</strong>消息队列通信过程中，存在用户态和内核态之间的数据拷贝。写入数据：用户态-&gt;内核态，读取消息：内核态-&gt;用户态。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215835113.png"></p>
</li>
<li><p>共享内存：消息队列的方式存在数据内核态和用户态转换，共享内存可以解决这一问题。共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中，这样这个进程写入的数据，另一个进程就能里面看到了，不需要拷贝来拷贝去。<strong>缺点：</strong>多个进程同时往这个物理内存写入，可以造成数据覆盖。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403215924096.png"></p>
</li>
<li><p>信号量：信号量其实就是一个整形的计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程通信的数据。信号量表示资源的数量，有两种原子操作，<strong>P操作</strong>信号量会减1，信号量&lt;0表示资源已被占用，进程阻塞等待 ,&gt;=0表示还有资源可用，进程可以正常执行，<strong>V操作</strong>信号量加1，信号量&lt;=0,表示当前有阻塞进程，于是会将该进程唤醒执行；&gt;0表示当前没有阻塞中的进程。</p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403220010341.png"></p>
</li>
<li><p>信号：信号一般用于一些异常情况下的进程间的通信，是一种异步通信，它的数据结构一般就是一个数字。信号是进程间通信机制中的<strong>唯一的异步通信机制。</strong>信号的来源主要有硬件来源。常用信号：Ctrl+c（SIGINT信号，表示终止该进程）Ctrl+Z（SIGTSTP 表示停止该进程，但还未结束）。进程需要为信号设置相应的 监听处理，当收到特定信号时，执行相应的操作，类似很多变成语言里面的通知机制。</p>
</li>
<li><p>Socket:前面几种都是在同一台主机上的进程间的通信，如果需要跨网络与不同主机上的进程之间通信，就需要sokcet通信了。socket不仅可以跨网络与不同主机进行通信，还可以在同主机上进行进程间通信。</p>
</li>
</ul>
<p><strong>进程间通信总结</strong></p>
<p><img src="/2022/04/03/08-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20220403214026093.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统&amp;网络&amp;基础数据结构总结</title>
    <url>/2022/04/10/09-00-00-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>



	<div class="row">
    <embed src="summary_01.png" width="100%" height="550" type="application/pdf">
	</div>




]]></content>
      <categories>
        <category>Java</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>总结</tag>
        <tag>操作系统</tag>
        <tag>计算机网络</tag>
        <tag>基础数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo解决推送github ssh key过期问题</title>
    <url>/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p>最近用hexo 推送博客到github，老是过一段时间提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">错误报告:You‘re using an RSA key with SHA-1, which is no longer allowed </span><br><span class="line">错误报告nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">ENOENT: no such file or directory, uv_cwd</span><br></pre></td></tr></table></figure>

<p>后通过如下步骤解决：</p>
<p>1、重新生成ssh key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>2、找到生成的公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">cat /root/.ssh/id_ed25519.pub</span><br><span class="line">windows:</span><br><span class="line">C:\Users\用户名\.ssh   【去这个目录找到生成时候的对应的文件名的文件】</span><br></pre></td></tr></table></figure>

<p>3、复制到github</p>
<p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。</p>
<p>4、设置文件夹及其子文件夹及文件权限</p>
<p><a href="https://blog.csdn.net/wangxiaozhonga/article/details/125322413">https://blog.csdn.net/wangxiaozhonga/article/details/125322413</a></p>
<p><a href="https://blog.csdn.net/Leo_Franklin/article/details/108858285">解决github ssh key 过期问题–有效果</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>



<p><a href="https://zhuanlan.zhihu.com/p/489362379">解决github访问过慢问题</a></p>
<p><a href="https://www.cnblogs.com/jj123/p/15740668.html">linux安装mysql教程</a></p>
<p><a href="https://github.com/dongfanger/pycnblog">markdown博客同步到博客园</a></p>
<p><a href="https://www.cnblogs.com/zongfa/p/14982504.html">markdown博客同步到博客园</a></p>
<p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">hexo 博客搭建</a></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/avator.jpg"></p>
<h2 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h2><p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-2ew3pm.webp" alt="wallhaven-2ew3pm"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-4ylgl0.webp" alt="wallhaven-4ylgl0"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-6k88jq.webp" alt="wallhaven-6k88jq"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-13mk9v.webp" alt="wallhaven-13mk9v"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-39qjjd.webp" alt="wallhaven-39qjjd"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-47ldq9.webp" alt="wallhaven-47ldq9"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-83w372.webp" alt="wallhaven-83w372"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-83yl1y.webp" alt="wallhaven-83yl1y"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-96w8e8.webp" alt="wallhaven-96w8e8"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-dgekog.webp" alt="wallhaven-dgekog"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-k9p8l6.webp" alt="wallhaven-k9p8l6"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-lm2762.webp" alt="wallhaven-lm2762"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-ne7lr8.webp" alt="wallhaven-ne7lr8"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-oxvkxp.webp" alt="wallhaven-oxvkxp"></p>
<p><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220803200906.jpg" alt="微信图片_20220803200906"><img src="/2022/04/25/10-00-00-hexo%E8%A7%A3%E5%86%B3%E6%8E%A8%E9%80%81github-ssh-key%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/wallhaven-xl67ov.webp" alt="wallhaven-xl67ov"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2021/12/11/about/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<blockquote>
<p>A developer, live in SZ, China.</p>
</blockquote>
<span id="more"></span>

<!-- <img src="" alt="avatar" width="300" style="border-radius:50%"/> -->

]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>解决maven jar包下载源码问题</title>
    <url>/2021/12/29/10-00-01-%E8%A7%A3%E5%86%B3maven-jar%E5%8C%85%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><a href="https://www.dandelioncloud.cn/article/details/1510888921704812546">解决maven jar包源码下载问题</a></p>
<p><a href="https://www.likecs.com/show-204662226.html">idea关闭重复代码提示</a></p>
<p>首先打开Idea中的 然后输入mvn dependency:resolve -Dclassifier=sources 最后成功…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">待加强的点</span><br><span class="line"><span class="number">1</span>、zookeeper源码  leader选举 和 zab</span><br><span class="line"><span class="number">2</span>、HashMap <span class="number">6</span>节课</span><br><span class="line"><span class="number">3</span>、jvm 底层字节码</span><br><span class="line"><span class="number">4</span>、</span><br></pre></td></tr></table></figure>





<p>推荐博客：</p>
<p><a href="https://www.yuque.com/kazike-pgsbs/sgv726">博客</a></p>
<p><a href="https://www.yuque.com/books/share/5f19528d-d89b-4b69-a7bd-9f436a2dd734/bs9d13">Spring 源码</a></p>
<p><a href="https://www.yuque.com/kazike-pgsbs/lcdhkb/aircwf">学习方法</a></p>
<p>目标 + 平台</p>
<p>目标+习惯+执行（要有反馈，正向反馈）</p>
<p>定好目标+养成习惯</p>
<p>简历是测试用例，checklist，专业度+价值观+能力测试+压力面试</p>
<p>学习：</p>
<p>自己给自己定时间：固定时间或碎片化时间，全身心投入，笔记图文结合（以图为主）</p>
<p>阶段性的：ppt演讲稿+视频</p>
<p>架构思维：</p>
<p>编程思维：</p>
<p>开发架构+业务架构</p>
<p><img src="/2021/12/29/10-00-01-%E8%A7%A3%E5%86%B3maven-jar%E5%8C%85%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/image-20220618212704506.png" alt="image-20220618212704506"></p>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>jar包</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/10/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>pdf预览</title>
    <url>/2021/12/13/pdf-preview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>



	<div class="row">
    <embed src="alibaba.pdf" width="100%" height="550" type="application/pdf">
	</div>






<object data="./alibaba.pdf" type="application/pdf" width="100%" height="100%"></object>]]></content>
      <categories>
        <category>其他</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>pdf</tag>
        <tag>文件预览</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2021/12/10/%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇准备记录自己的第一次博客，工作多年，也有了点收获，想要记录一些东西，所以就开始写博客。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器ParNew&amp;CMS与底层三色标记算法详解</title>
    <url>/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="垃圾收集器ParNew-amp-CMS与底层三色标记算法详解"><a href="#垃圾收集器ParNew-amp-CMS与底层三色标记算法详解" class="headerlink" title="垃圾收集器ParNew&amp;CMS与底层三色标记算法详解"></a>垃圾收集器ParNew&amp;CMS与底层三色标记算法详解</h2><h3 id="1、垃圾收集算法"><a href="#1、垃圾收集算法" class="headerlink" title="1、垃圾收集算法"></a>1、垃圾收集算法</h3><p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/clipboard-1650552624990.png" alt="img"></p>
<ul>
<li><p><strong>分代收集理论</strong></p>
<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
</li>
<li><p><strong>标记-复制算法</strong></p>
<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/96d6c205961c401fa08a222dd296f101-1650552914231.jpeg" alt="img"></p>
</li>
<li><p><strong>标记-清除算法</strong></p>
<p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题  (如果需要标记的对象太多，效率不高)</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ol>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/9ea2822391964677b532fa20ba6c1cfe.jpeg" alt="img"></p>
</li>
<li><p><strong>标记-整理算法</strong></p>
<p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/96ba7c6a2fe44eecbe32b64ada05e03f.jpeg" alt="img"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td>标记-复制算法</td>
<td>效率高，是其它两种算法的10倍以上</td>
<td align="left">浪费空间</td>
</tr>
<tr>
<td>标记-清除算法</td>
<td>简单</td>
<td align="left">1、效率低；2、容易产生空间碎片</td>
</tr>
<tr>
<td>标记-整理算法</td>
<td>不会产生空间碎片</td>
<td align="left">效率低</td>
</tr>
</tbody></table>
<h3 id="2、垃圾收集器"><a href="#2、垃圾收集器" class="headerlink" title="2、垃圾收集器"></a>2、垃圾收集器</h3><p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/clipboard-1650553117097.png" alt="img"></p>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<p><strong>1.1 Serial收集器</strong>(-XX:+UseSerialGC  -XX:+UseSerialOldGC)</p>
<p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1c5bbb8efda34d30a04c67eb39c32e43.jpeg" alt="img"></p>
<p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p>
<p><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，<strong>另一种用途是作为CMS收集器的后备方案</strong>。</p>
<p><strong>1.2 Parallel Scavenge收集器(</strong>-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代) JDK1.8默认的垃圾收集器)</p>
<p><strong>Parallel</strong>收集器其实<strong>就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>
<p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用复制算法。</strong></p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/f4928a43f18645a8891088ac5a0bc9c6.jpeg" alt="img"></p>
<p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(<strong>JDK8默认的新生代和老年代收集器</strong>)。</p>
<p><strong>1.3 ParNew收集器(****-XX:+UseParNewGC**</strong>)**</p>
<p>ParNew收集器其实<strong>跟Parallel收集器很类似</strong>，区别主要在于它可以和CMS收集器配合使用。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/4d6372782ad6472b8483a221172fb995.jpeg" alt="img"></p>
<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p><strong>1.4 CMS收集器(</strong>-XX:+UseConcMarkSweepGC(old))</p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为五个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程(STW)，并记录下gc roots<strong>直接能引用的对象</strong>，<strong>速度很快</strong>。【需要stw的原因是如果不做stw，那么跟gc roots直接引用的对象可能不断增加，导致初始标记一直无法完成】</li>
<li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。【并发的原因，提升用户体验，减少停顿时间】</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记【三色标记】产生变动的那一部分对象的标记记录，<strong>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。</strong></li>
<li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。</li>
<li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li>
</ul>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/e22d67705ee44f509442e7cd3b705910.jpeg" alt="img"></p>
<p>cms线程（垃圾收集线程）是字节码执行引擎再后端开启的线程</p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p>
<ul>
<li>对CPU资源敏感（会和服务抢资源）；</li>
<li>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>
<li>它使用的回收算法-<strong>“标记-清除”算法</strong>会导致收集结束时会有<strong>大量空间碎片</strong>产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>
<li>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，<strong>特别是在并发标记和并发清理阶段会出现</strong>，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”<strong>concurrent mode failure</strong>“，<strong>此时会进入stop the world，用serial old垃圾收集器来回收</strong></li>
</ul>
<p><strong>CMS的相关核心参数</strong></p>
<p>jvm参数有 -xx -version -x ，X越多表示越不稳定，后续可能会去掉</p>
<ol>
<li>-XX:+UseConcMarkSweepGC：启用cms </li>
<li>-XX:ConcGCThreads：并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）【内存碎片的整理也会stw,不会太慢，剩下的对象越多越慢】</li>
<li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次  </li>
<li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段**(<strong>也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间</strong>)**时的开销，一般CMS的GC耗时 80%都在标记阶段</li>
</ol>
<p>【老年代可能对新生代有跨代引用，先做一次minor gc 清除掉年轻代大多数无用对象之后，在做并发标记就会比较快】</p>
<ol>
<li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li>
</ol>
<p><strong>亿级流量电商系统如何优化JVM参数设置(ParNew+CMS)</strong></p>
<p>大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系统等等。</p>
<p>我们这里以比较核心的订单系统为例 </p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/clipboard-1650553251551.png" alt="img"></p>
<p>对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下：</p>
<p>调优前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上节课说过，这样设置可能会由于<strong>动态对象年龄判断原则</strong>导致频繁full gc。</p>
<p>于是我们可以更新下JVM参数设置：</p>
<p>调优后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=<span class="number">8</span> </span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/clipboard-1650554820731.png" alt="img"></p>
<p><strong>优化原则：</strong>让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc**。</p>
<p><strong>优化手段</strong>：1、降低对象进入老年代的gc分代年龄 2、提高年轻代内存占比</p>
<p>对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p>
<p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象。</p>
<p>可以适当调整JVM参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=<span class="number">8</span>  -XX:MaxTenuringThreshold=<span class="number">5</span> -XX:PretenureSizeThreshold=1M</span><br></pre></td></tr></table></figure>

<p>参数解释：-XX:MaxTenuringThreshold=5 年龄大与等于5，进入老年代，为什么设置为5？通过上面分析每25s产生一次young gc ，分代年龄达到5，说明已经过了几分钟了（大致是 5* 25 s）年轻代里面的对象早就变成垃圾了，如果经历了5次gc还没有被回收那么可用认为他是长期存活对象（可能是系统缓存对象，线程池对象，spring bean），直接放到老年代，这样就可以把年轻代空间腾出来，存放那些朝生夕死的对象。</p>
<p>-XX:PretenureSizeThreshold=1M </p>
<p>对于大多数系统，1M的对象大小已经是大对象了，大对象直接放到老年代</p>
<p><strong>需要注意的是：</strong>一般秒杀系统，对于单台机器，并发量可能是不稳定的。比如一般一台机器每秒能够支持300单，一秒只能能够完成订单生成；但是如果流量突增，导致每秒过来600个请求，那么可能会造成网络、磁盘、内存、带宽会比较吃紧，造成系统压力比较大，进而造成一个订单不一定能够在一秒之内生成，导致订单的处理周期时间会变长。最终导致的问题：当要发生minor gc 的最后几秒产生的订单都还没有执行完，导致这些对象都会从eden移到survivor区域，可能远远不止60M，甚至200多M，这样的话survivor区会放不下，会直接移到老年代。可能导致每隔几分钟有那么200M对象移到老年代，10、20、30分钟导致发生full gc。对于秒杀系统影响不大，秒杀系统大多前30分钟就完了</p>
<p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用<strong>ParNew+CMS(</strong>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC**)**</p>
<p>对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc最终进入老年代。</p>
<p>无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。</p>
<p>还有就是某次minor gc完了之后还有超过一两百M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。</p>
<p>我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次Full GC，Full GC的触发条件还有我们之前说过的<strong>老年代空间分配担保机制</strong>，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生full gc，这时候已经过了抢购的最高峰期，后续可能几小时才做一次FullGC。</p>
<p>对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。</p>
<p>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=3</span><br><span class="line"></span><br><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 【eden survivor比例】</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold=5 【分代年龄大于等于5 则进入老年代】</span><br><span class="line"></span><br><span class="line">-XX:PretenureSizeThreshold=1M 【大对象的值】</span><br><span class="line"></span><br><span class="line">-XX:+UseParNewGC 【新生代使用parnewgc】</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC 【老年代使用cms垃圾收集器】</span><br><span class="line"></span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSCompactAtFullCollection 【开启内存整理】</span><br><span class="line"></span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=3【3次full gc后内存整理】</span><br><span class="line"></span><br><span class="line">参数解释：-XX:CMSInitiatingOccupancyFraction=92</span><br><span class="line"></span><br><span class="line">老年代占比92%触发full gc 减少这个比例可以在一定程度下减少 concurrent mode failure出现的机率，也会导致老年代一部分空间浪费</span><br></pre></td></tr></table></figure>

<h3 id="3、垃圾收集底层算法实现"><a href="#3、垃圾收集底层算法实现" class="headerlink" title="3、垃圾收集底层算法实现"></a>3、垃圾收集底层算法实现</h3><p><strong>三色标记</strong></p>
<p>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</p>
<p>这里我们引入“<strong>三色标记</strong>”来给大家解释下，把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li><p><strong>黑色</strong>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</p>
</li>
<li><p><strong>灰色</strong>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</p>
</li>
<li><p><strong>白色</strong>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</p>
</li>
</ul>
<p><strong>漏标：扫描A对象的时候 A和D还没有建立连接，扫描到B，然后将B、D对象断开连接 ，将A和D建立连接。结果：A对象已经被扫描过了，不会再次扫描，扫描B的时候又扫不到D，这样D对象就会发生漏标。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args])</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    A a = <span class="keyword">new</span> A();    </span><br><span class="line">    D d = a.b.d;    </span><br><span class="line">    a.b.d = <span class="keyword">null</span>;    </span><br><span class="line">    a.d = d; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/clipboard-1650554974271.png" alt="img"></p>
<p><strong>多标-浮动垃圾</strong></p>
<p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>
<p><strong>漏标-读写屏障</strong></p>
<p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： <strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。</strong></p>
<p><strong>增量更新</strong>就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， <strong>黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了</strong>。</p>
<p><strong>原始快照</strong>就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(<strong>目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾</strong>)</p>
<p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。 </p>
<p><strong>写屏障</strong></p>
<p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * <span class="doctag">@param</span> field 某对象的成员变量，如 a.b.d  * <span class="doctag">@param</span> new_value 新值，如 null */</span> <span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;     *field = new_value; <span class="comment">// 赋值操作 &#125; </span></span><br><span class="line"></span><br><span class="line">所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;      pre_write_barrier(field);          <span class="comment">// 写屏障-写前操作    *field = new_value;     post_write_barrier(field, value);  // 写屏障-写后操作 &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>写屏障实现SATB</strong></li>
</ul>
<p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B<strong>原来成员变量的引用</strong>对象D记录下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_write_barrier</span><span class="params">(oop* field)</span> </span>&#123;    oop old_value = *field;    <span class="comment">// 获取旧值    remark_set.add(old_value); // 记录原来的引用对象 &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>写屏障实现增量更新</strong></li>
</ul>
<p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A<strong>新的成员变量引用</strong>对象D记录下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;      remark_set.add(new_value);  <span class="comment">// 记录新引用的对象 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>读屏障</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">oop_field_load</span><span class="params">(oop* field)</span> </span>&#123;    pre_load_barrier(field); <span class="comment">// 读屏障-读取前操作    return *field; &#125;</span></span><br><span class="line"></span><br><span class="line">读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_load_barrier</span><span class="params">(oop* field)</span> </span>&#123;      oop old_value = *field;    remark_set.add(old_value); <span class="comment">// 记录读取到的对象 &#125;</span></span><br></pre></td></tr></table></figure>

<p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li><strong>CMS：写屏障 + 增量更新</strong></li>
<li><strong>G1，Shenandoah：写屏障 + SATB</strong></li>
<li><strong>ZGC：读屏障</strong></li>
</ul>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<p><strong>为什么G1用SATB？CMS用增量更新？</strong></p>
<p><strong>我的理解</strong>：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p>
<p><strong>记忆集与卡表</strong></p>
<p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</p>
<p>为此，在新生代可以引入记录集（<strong>Remember Set</strong>）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p>
<p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p>
<p>hotspot使用一种叫做“卡表”(<strong>Cardtable</strong>)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p>
<p>卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。</p>
<p>hotSpot使用的卡页是2^9大小，即512字节</p>
<p><img src="/2022/04/19/00-00-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8ParNew-CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/ac2f4c8a417f.png" alt="img"></p>
<p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.</p>
<p>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</p>
<p><strong>卡表的维护</strong></p>
<p>卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。</p>
<p>Hotspot使用<strong>写屏障</strong>维护卡表状态。</p>
<h2 id="每日总结"><a href="#每日总结" class="headerlink" title="每日总结"></a>每日总结</h2><p>1、JVM垃圾收集算法</p>
<p>标记-复制算法：将内存区域分为大小想等的两块区域，每次垃圾回收只针对其中一块区域，将存活对象移到到另外一块区域，然后在把使用过的区域清除掉，这样每次的回收就是对内存区域的一半进行回收。优点：回收效率高，速度快；缺点：浪费空间</p>
<p>标记-清除算法：分为标记和清除两部分，标记存活的对象（也可以标记垃圾对象），统一回收所有未被标记的对象，也可以反过来。缺点：效率问题，如果需要比较的对象很多，效率不高；空间问题：标记清除后会产生大量不连续的内存碎片</p>
<p>标记-整理算法：标记过程和标记-清除算法一样，只是后续回收过程是把所有标记为存活的对象统一移动到一端，然后直接清理掉边界以外的内存。</p>
<p>分代收集理论：没有具体的算法，只是一个理论，根据老年代和年轻代的特点，采用不同的策略做垃圾回收。比如针对年轻代每次有99%的对象会死亡，采用复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
<p>2、垃圾收集器</p>
<p>垃圾收集器是垃圾收集算法的具体实现。</p>
<p>serial垃圾收集器：串行单线程收集器，适用于管理的内存比较小，比如几十M左右。年轻代采用复制算法，老年代采用标记整理算法。优点是简单。Serial Old是其老年代的垃圾收集器，同样是一个单线程收集器。</p>
<p>parallel Scavenge收集器：parallel是serial垃圾收集器的多线程版本，其关注的是吞吐量【即用户程序执行时间和总时间的比值】，新生代采用复制算法，老年代采用标记-整理算法。jdk1.8默认的垃圾收集器</p>
<p>parnew收集器：跟parallel收集器很像，区别主要是它可以配合cms垃圾收集器使用，新生代采用标记复制，老年代采用标记-整理。</p>
<p>CMS垃圾收集器：真正意义上的并行收集器。分为几个阶段1)初始标记：标记与gc root直接相连的对象，此阶段会产生stw。2）并发标记：用户线程和垃圾收集线程同时运行，从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程 ，可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。【并发的原因，提升用户体验，减少停顿时间】。3)重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。 4）并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。5）并发重置：重置本次GC过程中的标记数据。</p>
<p>优点：以最小用户停顿时间为目标，对用户体验友好；缺点：1）gc线程和用户线程同时运行，争抢服务器资源，对资源比较敏感2）无法处理浮动垃圾，即并发标记和并发清理阶段又产生的垃圾无法处理，只能下一次垃圾回收处理。3)老年代使用标记-清理算法会产生大量的垃圾碎片。4）可能发生concurrent mode failure的情况，在进行并发标记和并发清理时，由于用户程序也在运行导致可能在次触发gc，从而导致使用serial old串行收集器进行内存回收</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器G1&amp;ZGC详解</title>
    <url>/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="垃圾收集器G1-amp-ZGC详解"><a href="#垃圾收集器G1-amp-ZGC详解" class="headerlink" title="垃圾收集器G1&amp;ZGC详解"></a>垃圾收集器G1&amp;ZGC详解</h2><h3 id="1、G1收集器-XX-UseG1GC"><a href="#1、G1收集器-XX-UseG1GC" class="headerlink" title="1、G1收集器(-XX:+UseG1GC)"></a>1、G1收集器(-XX:+UseG1GC)</h3><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,<strong><strong>主要针对配备多颗处理器及大容量内存的机器</strong></strong>. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/%E6%88%AA%E5%9B%BE-1650643122599.png" alt="img"></p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/%E6%88%AA%E5%9B%BE-1650643129820.png" alt="img"></p>
<p>G1将Java堆划分为多个大小相等的独立区域（<strong>Region</strong>），JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER 定义)，实际可以超过该值，但是不推荐。</p>
<p>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数”-XX:G1HeapRegionSize”手动指定Region大小，但是推荐默认的计算方式。</p>
<p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p>
<p>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。</p>
<p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p>
<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，<strong>唯一不同的是对大对象的处理</strong>，G1有专门分配大对象的Region叫<strong>Humongous区</strong>，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</p>
<p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p>
<p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>
<p>G1收集器一次GC(主要值Mixed GC)的运作过程大致分为以下几个步骤：</p>
<ul>
<li><p><strong>初始标记</strong>（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，<strong>速度很快</strong> ；</p>
</li>
<li><p><strong>并发标记</strong>（Concurrent Marking）：同CMS的并发标记</p>
</li>
<li><p><strong>最终标记</strong>（Remark，STW）：同CMS的重新标记</p>
</li>
<li><p><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的<strong>回收价值和成本进行排序</strong>，<strong>根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划</strong>，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(<strong>Collection Set</strong>，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，<strong>回收算法主要用的是复制算法</strong>，<strong>将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</strong>。(注意：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了ZGC，Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)</p>
</li>
</ul>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643145759.png" alt="img"></p>
<p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</p>
<p>被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“<strong>标记整理</strong>”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”<strong>-XX:MaxGCPauseMillis</strong>“指定)内完成垃圾收集。</li>
</ul>
<p>毫无疑问， 可以由用户指定期望的停顿时间是G1收集器很强大的一个功能， 设置不同的期望停顿时间， 可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。 不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p>
<p><strong>G1垃圾收集分类</strong></p>
<p><strong>YoungGC</strong></p>
<p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC</p>
<p><strong>MixedGC</strong></p>
<p>不是FullGC，老年代的堆占有率达到参数(<strong>-XX:InitiatingHeapOccupancyPercent</strong>)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及<strong>大对象区</strong>，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够的空region</strong>能够承载拷贝对象就会触发一次Full GC</p>
<p><strong>Full GC</strong></p>
<p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p>
<p>年轻代对应进入老年代，对象挪动和之前的一样。对象初始还在在eden区域分配内存，发生young gc 对象挪到survivor区，survivor区内存不够新生代会自动扩充内存 之前的一些原则还是适用，比如对象动态年龄判定机制、长期存活对象进入老年代；记忆集和卡表同样适用，只是g1每个region都有一份卡表</p>
<p><strong>G1收集器参数设置</strong> </p>
<p>  -XX:+UseG1GC:使用G1收集器</p>
<p>  -XX:ParallelGCThreads:指定GC工作的线程数量</p>
<p>  -XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区</p>
<p>  -XX:MaxGCPauseMillis:目标暂停时间(默认200ms)</p>
<p>  -XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)</p>
<p>  -XX:G1MaxNewSizePercent:新生代内存最大空间</p>
<p>  -XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</p>
<p>  -XX:MaxTenuringThreshold:最大年龄阈值(默认15)【最大年龄超过15进入老年代】</p>
<p>  -XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(<strong>MixedGC</strong>)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了</p>
<p> -XX:G1MixedGCLiveThresholdPercent(默认85%)  region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</p>
<p>  -XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。</p>
<p>  -XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p>
<p><strong>G1垃圾收集器优化建议</strong></p>
<p>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。</p>
<p>那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。</p>
<p>或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。</p>
<p>所以这里核心还是在于调节 -XX:MaxGCPauseMills 这个参数【不能太小，不然每次回收的内存会比较小】的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc.</p>
<p><strong>什么场景适合使用G1</strong></p>
<ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<p><strong>每秒几十万并发的系统如何优化JVM</strong></p>
<p>Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题了，我们以前常说的对于eden区的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四十G的eden区可能也就一两分钟吧，那么意味着整个系统每运行一两分钟就会因为young gc卡顿几秒钟没法处理新消息，显然是不行的。那么对于这种情况如何优化了，我们可以使用G1收集器，设置 -XX:MaxGCPauseMills 为50ms，假设50ms能够回收三到四个G内存，然后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。</p>
<p>G1天生就适合这种大内存机器的JVM运行，可以比较完美的解决大内存垃圾回收时间过长的问题。</p>
<p><strong>年轻代young gc一定比老年代 full gc快吗？</strong></p>
<p>不一定，如果young gc内存特别大比如几十G时，老年代空间比较小，young gc可能会比full gc还慢</p>
<p><strong>ZGC收集器(-XX:+UseZGC)</strong></p>
<p>参考文章：<a href="https://wiki.openjdk.java.net/display/zgc/Main">https://wiki.openjdk.java.net/display/zgc/Main</a></p>
<p><a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf">http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf</a></p>
<p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器。</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643224506.png" alt="img"></p>
<p><strong>ZGC目标</strong></p>
<p>如下图所示，ZGC的目标主要有4个：</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643234355.png" alt="img"></p>
<ul>
<li><strong>支持TB量级的堆</strong>。我们生产环境的硬盘还没有上TB呢，这应该可以满足未来十年内，所有JAVA应用的需求了吧。 </li>
<li><strong>最大GC停顿时间不超10ms</strong>。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。 </li>
<li><strong>奠定未来GC特性的基础</strong>。</li>
<li>**最糟糕的情况下吞吐量会降低15%**。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。</li>
</ul>
<p>另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p>
<p><strong>不分代(暂时)</strong></p>
<p>单代，即ZGC「没有分代」。我们知道以前的垃圾回收器之所以分代，是因为源于“「大部分对象朝生夕死」”的假设，事实上大部分系统的对象分配行为也确实符合这个假设。</p>
<p>那么为什么ZGC就不分代呢？因为分代实现起来麻烦，作者就先实现出一个比较简单可用的单代版本，后续会优化。</p>
<p><strong>ZGC内存布局</strong></p>
<p>ZGC收集器是一款基于Region内存布局的， 暂时不设分代的， 使用了<strong>读屏障、 颜色指针</strong>等技术来实现可并发的标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的Region可以具有如图3-19所示的大、 中、 小三类容量：</p>
<ul>
<li>小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 <strong>每个大型Region中只会存放一个大对象</strong>， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作， 用于复制对象的收集器阶段， 稍后会介绍到）的， 因为复制一个大对象的代价非常高昂。</li>
</ul>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643244596.png" alt="img"></p>
<p><strong>NUMA-aware</strong></p>
<p>NUMA对应的有UMA，UMA即<strong>Uniform Memory Access Architecture</strong>，NUMA就是Non Uniform Memory Access Architecture。UMA表示内存只有一块，所有CPU都去访问这一块内存，那么就会存在竞争问题（争夺内存总线访问权），有竞争就会有锁，有锁效率就会受到影响，而且CPU核心数越多，竞争就越激烈。NUMA的话每个CPU对应有一块内存，且这块内存在主板上离这个CPU是最近的，每个CPU优先访问这块内存，那效率自然就提高了：</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/640.webp" alt="img"></p>
<p>服务器的NUMA架构在中大型系统上一直非常盛行，也是高性能的解决方案，尤其在系统延迟方面表现都很优秀。ZGC是能自动感知NUMA架构并充分利用NUMA架构特性的。</p>
<p><strong>ZGC运作过程</strong></p>
<p>ZGC的运作过程大致可划分为以下四个大的阶段：</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643267769.png" alt="img"></p>
<ul>
<li><strong>并发标记（Concurrent Mark）</strong>：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记(<strong>Mark Start</strong>)和最终标记(<strong>Mark End</strong>)也会出现短暂的停顿，与G1不同的是， ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新<strong>颜色指针</strong>(见下面详解)中的Marked 0、 Marked 1标志位。</li>
<li><strong>并发预备重分配（Concurrent Prepare for Relocate）</strong>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</li>
<li><strong>并发重分配（Concurrent Relocate）</strong>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forward Table）</strong>，记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(<strong>读屏障</strong>(见下面详解))所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</li>
</ul>
<p>ZGC的颜色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后， 这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。</p>
<ul>
<li><strong>并发重映射（Concurrent Remap）</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</li>
</ul>
<p><strong>颜色指针</strong></p>
<p>Colored Pointers，即颜色指针，如下图所示，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中。</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643276997.png" alt="img"></p>
<p>每个对象有一个64位指针，这64位被分为：</p>
<ul>
<li>18位：预留给以后使用；</li>
<li>1位：Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过finalizer才能访问；</li>
<li>1位：Remapped标识，设置此位的值后，对象未指向relocation set中（relocation set表示需要GC的Region集合）；</li>
<li>1位：Marked1标识；</li>
<li>1位：Marked0标识，和上面的Marked1都是标记对象用于辅助GC；</li>
<li>42位：对象的地址（所以它可以支持2^42=4T内存）：</li>
</ul>
<p><strong>为什么有2个mark标记？</strong></p>
<p>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记。</p>
<p>GC周期1：使用mark0, 则周期结束所有引用mark标记都会成为01。</p>
<p>GC周期2：使用mark1, 则期待的mark标记10，所有引用都能被重新标记。</p>
<p>通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC就无法支持32位操作系统，同样的也就无法支持压缩指针了（CompressedOops，压缩指针也是32位）。</p>
<p><strong>颜色指针的三大优势：</strong></p>
<ol>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li>
<li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li>
<li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<p><strong>读屏障</strong></p>
<p>之前的GC都是采用Write Barrier，这次ZGC采用了完全不同的方案读屏障，这个是ZGC一个非常重要的特性。</p>
<p>在标记和移动对象的阶段，每次「从堆里对象的引用类型中读取一个指针」的时候，都需要加上一个Load Barriers。</p>
<p>那么我们该如何理解它呢？看下面的代码，第一行代码我们尝试读取堆中的一个对象引用obj.fieldA并赋给引用o（fieldA也是一个对象时才会加上读屏障）。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。</p>
<p>那么，JVM是如何判断对象被移动过呢？就是利用上面提到的颜色指针，如果指针是Bad Color，那么程序还不能往下执行，需要「slow path」，修正指针；如果指针是Good Color，那么正常往下执行即可：</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643291024.png" alt="img"></p>
<p>❝ 这个动作是不是非常像JDK并发中用到的CAS自旋？读取的值发现已经失效了，需要重新读取。而ZGC这里是之前持有的指针由于GC后失效了，需要通过读屏障修正指针。❞ </p>
<p>后面3行代码都不需要加读屏障：Object p = o这行代码并没有从堆中读取数据；o.doSomething()也没有从堆中读取数据；obj.fieldB不是对象引用，而是原子类型。</p>
<p>正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销：</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643297962.png" alt="img"></p>
<p>那么，判断对象是Bad Color还是Good Color的依据是什么呢？就是根据上一段提到的Colored Pointers的4个颜色位。当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是Bad/Good Color了。</p>
<p><strong>PS：</strong>既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢？答案肯定是不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T。</p>
<p><strong>ZGC存在的问题</strong></p>
<p>ZGC最大的问题是<strong>浮动垃圾</strong>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>
<p>ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。</p>
<p><strong>解决方案</strong></p>
<p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<p><strong>ZGC参数设置</strong></p>
<p>启用ZGC比较简单，设置JVM参数即可：-XX:+UnlockExperimentalVMOptions 「-XX:+UseZGC」。调优也并不难，因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自动完成。下图所示是ZGC可以调优的参数：</p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/640.png" alt="img"></p>
<p><strong>ZGC触发时机</strong></p>
<p>ZGC目前有4中机制触发GC：</p>
<ul>
<li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。</li>
<li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。</li>
<li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。</li>
<li>主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</li>
</ul>
<p><strong>如何选择垃圾收集器</strong></p>
<ol>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li>
<li><strong>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC   【小内存的用G1或ZGC回收垃圾时间可能更长，因为算法复杂度比较高，时间比较长】</strong></li>
</ol>
<p><strong>下图有连线的可以搭配使用</strong></p>
<p><img src="/2022/04/22/00-00-06-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1-ZGC%E8%AF%A6%E8%A7%A3/clipboard-1650643316055.png" alt="img"></p>
<p><strong>JDK 1.8默认使用 Parallel(年轻代和老年代都是)</strong></p>
<p><strong>JDK 1.9默认使用 G1</strong>    </p>
<p><strong>安全点与安全区域</strong></p>
<p><strong>安全点</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。</p>
<p>这些特定的安全点位置主要有以下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的。</p>
<p><strong>安全区域又是什么？</strong></p>
<p>Safe Point 是对正在执行的线程设定的。</p>
<p>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p>
<p>因此 JVM 引入了 Safe Region。</p>
<p>Safe Region 是指在一段代码片段中，<strong>引用关系不会发生变化</strong>。在这个区域内的任意地方开始 GC 都是安全的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM调优工具详解及调优实战</title>
    <url>/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><strong>前置启动程序</strong></p>
<p>事先启动一个web应用程序，用jps查看其进程id，接着用各种jdk自带命令优化应用</p>
<p><strong>Jmap</strong></p>
<p>此命令可以用来查看内存信息，实例个数以及占用内存大小</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jmap -histo <span class="number">14660</span>  #查看历史生成的实例</span><br><span class="line">jmap -histo:live <span class="number">14660</span>  #查看当前存活的实例，执行过程中可能会触发一次full gc</span><br></pre></td></tr></table></figure>

<p>打开log.txt，文件内容如下：</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717297968.png" alt="img"></p>
<ul>
<li>num：序号</li>
<li>instances：实例数量</li>
<li>bytes：占用空间大小</li>
<li>class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</li>
</ul>
<p>堆信息</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717336518.png" alt="img"></p>
<p>堆内存dump</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=eureka.hprof 14660</span><br></pre></td></tr></table></figure>

<p>也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)</p>
<ol>
<li>-XX:+HeapDumpOnOutOfMemoryError</li>
<li>-XX:HeapDumpPath=./  （路径）</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// JVM设置    </span></span><br><span class="line">   <span class="comment">// -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         list.add(<span class="keyword">new</span> User(i++, UUID.randomUUID().toString()));</span><br><span class="line">         <span class="keyword">new</span> User(j--, UUID.randomUUID().toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以用jvisualvm命令工具导入该dump文件分析</strong></p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717373368.png" alt="img"></p>
<p><strong>Jstack</strong></p>
<p>查看堆栈情况</p>
<p>用jstack加进程id查找死锁，见如下示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread1 begin&quot;</span>);</span><br><span class="line">               Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread2 begin&quot;</span>);</span><br><span class="line">               Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717418373.png" alt="img"></p>
<p>“Thread-1” 线程名 </p>
<p>prio=5 优先级=5</p>
<p>tid=0x000000001fa9e000 线程id</p>
<p>nid=0x2d64 线程对应的本地线程标识nid</p>
<p>java.lang.Thread.State: BLOCKED 线程状态</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717426097.png" alt="img"></p>
<p>还可以用jvisualvm自动检测死锁</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717432836.png" alt="img"></p>
<p> <strong>远程连接jvisualvm</strong></p>
<p><strong>启动普通的jar程序JMX端口配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Dcom.sun.management.jmxremote.port=<span class="number">8888</span> -Djava.rmi.server.hostname=<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span> -Dcom.sun.management.jmxremote.ssl=<span class="keyword">false</span> -Dcom.sun.management.jmxremote.authenticate=<span class="keyword">false</span> -jar microservice-eureka-server.jar</span><br></pre></td></tr></table></figure>

<p>PS：</p>
<p>-Dcom.sun.management.jmxremote.port 为远程机器的JMX端口</p>
<p>-Djava.rmi.server.hostname 为远程机器IP</p>
<p><strong>tomcat的JMX配置：在catalina.sh文件里的最后一个JAVA_OPTS的赋值语句下一行增加如下配置行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote.port=8888 -Djava.rmi.server.hostname=192.168.50.60 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;</span></span><br></pre></td></tr></table></figure>

<p>连接时确认下端口是否通畅，可以临时关闭下防火墙</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld   #临时关闭防火墙</span><br></pre></td></tr></table></figure>

<p><strong>jstack找出占用cpu最高的线程堆栈信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.jvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行此代码，cpu会飙高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;  <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            math.compute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如19663</pid></p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717539962.png" alt="img"></p>
<p>2，按H，获取每个线程的内存情况 【shift+h】</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717539962.png" alt="img"></p>
<p>3，找到内存和cpu占用最高的线程tid，比如19664</p>
<p>4，转为十六进制得到 0x4cd0，此为线程id的十六进制表示</p>
<p>5，执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717539962.png" alt="img"></p>
<p>6，查看对应的堆栈信息找出可能存在问题的代码</p>
<p><strong>Jinfo</strong> </p>
<p>查看正在运行的Java应用程序的扩展参数 </p>
<p>查看jvm的参数</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650974007886.png" alt="img"></p>
<p>查看java系统参数</p>
<p>jinfo -sysprops pid 查询系统属性</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650974020201.png" alt="img"></p>
<p><strong>Jstat</strong></p>
<p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：</p>
<p>jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数]</p>
<p>注意：使用的jdk版本是jdk8</p>
<p>垃圾回收统计</p>
<p><strong>jstat -gc pid 最常用</strong>，可以评估程序内存使用及GC压力整体情况</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717633232.png" alt="img"></p>
<ul>
<li>S0C：第一个幸存区的大小，单位KB</li>
<li>S1C：第二个幸存区的大小</li>
<li>S0U：第一个幸存区的使用大小</li>
<li>S1U：第二个幸存区的使用大小</li>
<li>EC：伊甸园区的大小</li>
<li>EU：伊甸园区的使用大小</li>
<li>OC：老年代大小</li>
<li>OU：老年代使用大小</li>
<li>MC：方法区大小(元空间)</li>
<li>MU：方法区使用大小</li>
<li>CCSC:压缩类空间大小</li>
<li>CCSU:压缩类空间使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>YGCT：年轻代垃圾回收消耗时间，单位s</li>
<li>FGC：老年代垃圾回收次数 </li>
<li>FGCT：老年代垃圾回收消耗时间，单位s</li>
<li>GCT：垃圾回收消耗总时间，单位s</li>
</ul>
<p>堆内存统计</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717642147.png" alt="img"></p>
<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0C：第一个幸存区大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>EC：伊甸园区的大小</li>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代大小</li>
<li>OC:当前老年代大小</li>
<li>MCMN:最小元数据容量</li>
<li>MCMX：最大元数据容量</li>
<li>MC：当前元数据空间大小</li>
<li>CCSMN：最小压缩类空间大小</li>
<li>CCSMX：最大压缩类空间大小</li>
<li>CCSC：当前压缩类空间大小</li>
<li>YGC：年轻代gc次数</li>
<li>FGC：老年代GC次数</li>
</ul>
<p>新生代垃圾回收统计</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717653233.png" alt="img"></p>
<ul>
<li>S0C：第一个幸存区的大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>S0U：第一个幸存区的使用大小</li>
<li>S1U：第二个幸存区的使用大小</li>
<li>TT:对象在新生代存活的次数</li>
<li>MTT:对象在新生代存活的最大次数</li>
<li>DSS:期望的幸存区大小</li>
<li>EC：伊甸园区的大小</li>
<li>EU：伊甸园区的使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>YGCT：年轻代垃圾回收消耗时间</li>
</ul>
<p>新生代内存统计</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717662929.png" alt="img"></p>
<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0CMX：最大幸存1区大小</li>
<li>S0C：当前幸存1区大小</li>
<li>S1CMX：最大幸存2区大小</li>
<li>S1C：当前幸存2区大小</li>
<li>ECMX：最大伊甸园区大小</li>
<li>EC：当前伊甸园区大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代回收次数</li>
</ul>
<p>老年代垃圾回收统计</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/SoftWare/YoudaoNote/data/weixinobU7VjhvI_xPabJNr-TrodDikjY4/8f6d44c9d9134a78a516100242f38d60/clipboard.png" alt="img"></p>
<ul>
<li>MC：方法区大小</li>
<li>MU：方法区使用大小</li>
<li>CCSC:压缩类空间大小</li>
<li>CCSU:压缩类空间使用大小</li>
<li>OC：老年代大小</li>
<li>OU：老年代使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
<p>老年代内存统计</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/SoftWare/YoudaoNote/data/weixinobU7VjhvI_xPabJNr-TrodDikjY4/db0afa703b8b45cdb33b603877fd14ee/clipboard.png" alt="img"></p>
<ul>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代大小</li>
<li>OC：老年代大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
<p>元数据空间统计</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/SoftWare/YoudaoNote/data/weixinobU7VjhvI_xPabJNr-TrodDikjY4/fbf747efc2a84ffb97ea5ae79bf46c87/clipboard.png" alt="img"></p>
<ul>
<li>MCMN:最小元数据容量</li>
<li>MCMX：最大元数据容量</li>
<li>MC：当前元数据空间大小 </li>
<li>CCSMN：最小压缩类空间大小</li>
<li>CCSMX：最大压缩类空间大小</li>
<li>CCSC：当前压缩类空间大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717687825.png" alt="img"></p>
<ul>
<li>S0：幸存1区当前使用比例</li>
<li>S1：幸存2区当前使用比例</li>
<li>E：伊甸园区使用比例</li>
<li>O：老年代使用比例</li>
<li>M：元数据区使用比例</li>
<li>CCS：压缩使用比例</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
<p><strong>JVM运行情况预估</strong></p>
<p>用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p>
<p><strong>年轻代对象增长的速率</strong></p>
<p>可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。</p>
<p><strong>Young GC的触发频率和每次耗时</strong></p>
<p>知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道<strong>系统大概多久会因为Young GC的执行而卡顿多久。</strong></p>
<p><strong>每次Young GC后有多少对象存活和进入老年代</strong></p>
<p>这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出<strong>老年代对象增长速率。</strong></p>
<p><strong>Full GC的触发频率和每次耗时</strong></p>
<p>知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。</p>
<p><strong>优化思路</strong>其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p>
<p><strong>系统频繁Full GC导致系统卡顿是怎么回事</strong></p>
<ul>
<li>机器配置：2核4G</li>
<li>JVM内存大小：2G</li>
<li>系统运行时间：7天</li>
<li>期间发生的Full GC次数和耗时：500多次，200多秒</li>
<li>期间发生的Young GC次数和耗时：1万多次，500多秒</li>
</ul>
<p>大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右；</p>
<p>每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。</p>
<p>JVM参数设置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=<span class="number">6</span>  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M </span><br><span class="line">-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=<span class="number">75</span> -XX:+UseCMSInitiatingOccupancyOnly </span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717714884.png" alt="img"></p>
<p>大家可以结合<strong>对象挪动到老年代那些规则</strong>推理下我们这个程序可能存在的一些问题</p>
<p>经过分析感觉可能会由于对象动态年龄判断机制导致full gc较为频繁</p>
<p>为了给大家看效果，我模拟了一个示例程序(见课程对应工程代码：jvm-full-gc)，打印了jstat的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstat -gc <span class="number">13456</span> <span class="number">2000</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717742876.png" alt="img"></p>
<p>对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=<span class="number">6</span>  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M </span><br><span class="line">-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=<span class="number">92</span> -XX:+UseCMSInitiatingOccupancyOnly </span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717768183.png" alt="img"></p>
<p>优化完发现没什么变化，<strong>full gc的次数比minor gc的次数还多了</strong></p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717806011.png" alt="img"></p>
<p>我们可以推测下full gc比minor gc还多的原因有哪些？</p>
<p>1、元空间不够导致的多余full gc</p>
<p>2、显示调用System.gc()造成多余的full gc，这种一般线上尽量通过-XX:+DisableExplicitGC参数禁用，如果加上了这个JVM启动参数，那么代码中调用System.gc()没有任何效果</p>
<p>3、老年代空间分配担保机制</p>
<p>最快速度分析完这些我们推测的原因以及优化后，我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年代，这种情况我们可以借助jmap命令大概看下是什么对象</p>
<p><img src="/2022/04/23/00-00-07-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/clipboard-1650717814247.png" alt="img"></p>
<p>查到了有大量User对象产生，这个可能是问题所在，但不确定，还必须找到对应的代码确认，如何去找对应的代码了？</p>
<p>1、代码里全文搜索生成User对象的地方(适合只有少数几处地方的情况)</p>
<p>2、如果生成User对象的地方太多，无法定位具体代码，我们可以同时分析下占用cpu较高的线程，一般有大量对象不断产生，对应的方法代码肯定会被频繁调用，占用的cpu必然较高</p>
<p>可以用上面讲过的jstack或jvisualvm来定位cpu使用较高的代码，最终定位到的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/process&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processUserData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; users = queryUsers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            <span class="comment">//TODO 业务处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;user:&quot;</span> + user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟批量查询用户场景</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;User&gt; <span class="title">queryUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            users.add(<span class="keyword">new</span> User(i,<span class="string">&quot;zhuge&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，java的代码也是需要优化的，一次查询出500M的对象出来，明显不合适，要根据之前说的各种原则尽量优化到合适的值，尽量消除这种朝生夕死的对象导致的full gc</p>
<p><strong>内存泄露到底是怎么回事</strong></p>
<p>再给大家讲一种情况，一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。</p>
<p>这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm调优实战及常量池详解</title>
    <url>/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><strong>阿里巴巴Arthas详解</strong></p>
<p><strong>Arthas</strong> 是 Alibaba 在 2018 年 9 月开源的 <strong>Java 诊断</strong>工具。支持 JDK6+， 采用命令行交互模式，可以方便的定位和诊断线上程序运行问题。<strong>Arthas</strong> 官方文档十分详细，详见：<a href="https://alibaba.github.io/arthas"><em>https://alibaba.github.io/arthas</em></a></p>
<p> <strong>Arthas****使用场景</strong></p>
<p>得益于 <strong>Arthas</strong> 强大且丰富的功能，让 <strong>Arthas</strong> 能做的事情超乎想象。下面仅仅列举几项常见的使用情况，更多的使用场景可以在熟悉了 <strong>Arthas</strong> 之后自行探索。</p>
<ol>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>为什么 CPU 又升高了，到底是哪里占用了 CPU ？</li>
<li>运行的多线程有死锁吗？有阻塞吗？</li>
<li>程序运行耗时很长，是哪里耗时比较长呢？如何监测呢？</li>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>有什么办法可以监控到 JVM 的实时运行状态？</li>
</ol>
<p> <strong>Arthas****使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># github下载arthas</span><br><span class="line">wget https:<span class="comment">//alibaba.github.io/arthas/arthas-boot.jar</span></span><br><span class="line"># 或者 Gitee 下载</span><br><span class="line">wget https:<span class="comment">//arthas.gitee.io/arthas-boot.jar</span></span><br></pre></td></tr></table></figure>

<p>用java -jar运行即可，可以识别机器上所有Java进程(我们这里之前已经运行了一个Arthas测试程序，代码见下方)</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arthas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟 CPU 过高</span></span><br><span class="line">        cpuHigh();</span><br><span class="line">        <span class="comment">// 模拟线程死锁</span></span><br><span class="line">        deadThread();</span><br><span class="line">        <span class="comment">// 不断的向 hashSet 集合增加数据</span></span><br><span class="line">        addHashSetThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不断的向 hashSet 集合添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHashSetThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化常量</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    hashSet.add(<span class="string">&quot;count&quot;</span> + count);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpuHigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deadThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 创建资源 */</span></span><br><span class="line">        Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; get ResourceA&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resourceB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; get resourceB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; get ResourceB&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resourceA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; get resourceA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择进程序号1，进入进程信息操作</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812470545.png" alt="img"></p>
<p>输入<strong>dashboard</strong>可以查看整个进程的运行情况，线程、内存、GC、运行环境信息：</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812479044.png" alt="img"></p>
<p>输入<strong>thread</strong>可以查看线程详细情况</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812486746.png" alt="img"></p>
<p>输入 <strong>thread加上线程ID</strong> 可以查看线程堆栈</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812495439.png" alt="img"></p>
<p>输入 <strong>thread -b</strong> 可以查看线程死锁</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812503752.png" alt="img"></p>
<p>输入 <strong>jad加类的全名</strong> 可以反编译，这样可以方便我们查看线上代码是否是正确的版本</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812511982.png" alt="img"></p>
<p>使用 <strong>ognl</strong> 命令可以    </p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812523527.png" alt="img"></p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812537002.png" alt="img"></p>
<p>更多命令使用可以用help命令查看，或查看文档：<a href="https://alibaba.github.io/arthas/commands.html#arthas">https://alibaba.github.io/arthas/commands.html#arthas</a></p>
<p><strong>GC日志详解</strong></p>
<p>对于java应用我们可以通过一些配置把程序运行过程中的gc日志全部打印出来，然后分析gc日志得到关键性指标，分析GC原因，调优JVM参数。</p>
<p>打印GC日志方法，在JVM参数里增加参数，%t 代表时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xloggc:./gc-%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -XX:+PrintGCTimeStamps -XX:+PrintGCCause  </span><br><span class="line">-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">10</span> -XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure>

<p>Tomcat则直接加在JAVA_OPTS变量里。</p>
<p><strong>如何分析GC日志</strong></p>
<p>运行程序加上对应gc日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar -Xloggc:./gc-%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -XX:+PrintGCTimeStamps -XX:+PrintGCCause  </span><br><span class="line">-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">10</span> -XX:GCLogFileSize=100M microservice-eureka-server.jar</span><br></pre></td></tr></table></figure>

<p>下图中是我截取的JVM刚启动的一部分GC日志 </p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812587264.png" alt="img"></p>
<p>我们可以看到图中第一行红框，是项目的配置参数。这里不仅配置了打印GC日志，还有相关的VM内存参数。 </p>
<p>第二行红框中的是在这个GC时间点发生GC之后相关GC情况。 </p>
<p>1、对于<strong>2.909：</strong>  这是从jvm启动开始计算到这次GC经过的时间，前面还有具体的发生时间日期。 </p>
<p>2、Full GC(Metadata GC Threshold)指这是一次full gc，括号里是gc的原因， PSYoungGen是年轻代的GC，ParOldGen是老年代的GC，Metaspace是元空间的GC</p>
<p>3、 6160K-&gt;0K(141824K)，这三个数字分别对应GC之前占用年轻代的大小，GC之后年轻代占用，以及整个年轻代的大小。 </p>
<p>4、112K-&gt;6056K(95744K)，这三个数字分别对应GC之前占用老年代的大小，GC之后老年代占用，以及整个老年代的大小。 </p>
<p>5、6272K-&gt;6056K(237568K)，这三个数字分别对应GC之前占用堆内存的大小，GC之后堆内存占用，以及整个堆内存的大小。 </p>
<p>6、20516K-&gt;20516K(1069056K)，这三个数字分别对应GC之前占用元空间内存的大小，GC之后元空间内存占用，以及整个元空间内存的大小。 </p>
<p>7、0.0209707是该时间点GC总耗费时间。 </p>
<p>从日志可以发现几次fullgc都是由于元空间不够导致的，所以我们可以将元空间调大点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar -Xloggc:./gc-adjust-%t.log -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps  </span><br><span class="line">-XX:+PrintGCTimeStamps -XX:+PrintGCCause  -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">10</span> -XX:GCLogFileSize=100M </span><br><span class="line">microservice-eureka-server.jar</span><br></pre></td></tr></table></figure>

<p>调整完我们再看下gc日志发现已经没有因为元空间不够导致的fullgc了</p>
<p>对于CMS和G1收集器的日志会有一点不一样，也可以试着打印下对应的gc日志分析下，可以发现gc日志里面的gc步骤跟我们之前讲过的步骤是类似的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">100</span>];  <span class="comment">//100KB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapTest&gt; heapTests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            heapTests.add(<span class="keyword">new</span> HeapTest());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CMS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xloggc:d:/gc-cms-%t.log -Xms50M -Xmx50M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps  </span><br><span class="line"> -XX:+PrintGCTimeStamps -XX:+PrintGCCause  -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">10</span> -XX:GCLogFileSize=100M </span><br><span class="line"> -XX:+UseParNewGC -XX:+UseConcMarkSweepGC   </span><br></pre></td></tr></table></figure>

<p><strong>G1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xloggc:d:/gc-g1-%t.log -Xms50M -Xmx50M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps  </span><br><span class="line"> -XX:+PrintGCTimeStamps -XX:+PrintGCCause  -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">10</span> -XX:GCLogFileSize=100M -XX:+UseG1GC </span><br></pre></td></tr></table></figure>

<p>上面的这些参数，能够帮我们查看分析GC的垃圾收集情况。但是如果GC日志很多很多，成千上万行。就算你一目十行，看完了，脑子也是一片空白。所以我们可以借助一些功能来帮助我们分析，这里推荐一个gceasy(<a href="https://gceasy.io/">https://gceasy.io</a>)，可以上传gc文件，然后他会利用可视化的界面来展现GC情况。具体下图所示 </p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812686019.png" alt="img"></p>
<p>上图我们可以看到年轻代，老年代，以及永久代的内存分配，和最大使用情况。 </p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812686020.png" alt="img"></p>
<p>上图我们可以看到堆内存在GC之前和之后的变化，以及其他信息。</p>
<p>这个工具还提供基于机器学习的JVM智能优化建议，当然现在这个功能需要付费</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812686020.png" alt="img"></p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812686020.png" alt="img"></p>
<p><strong>JVM参数汇总查看命令</strong></p>
<p>java -XX:+PrintFlagsInitial 表示打印出所有参数选项的默认值</p>
<p>java -XX:+PrintFlagsFinal 表示打印出所有参数选项在运行程序时生效的值</p>
<p><strong>Class常量池与运行时常量池</strong></p>
<p>Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是**常量池(constant pool table)<strong>，用于存放编译期生成的各种</strong>字面量(Literal)和符号引用(Symbolic References)**。</p>
<p>一个class文件的16进制大体结构如下图：</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812732149.png" alt="img"></p>
<p>对应的含义如下，细节可以查下oracle官方文档</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812739645.png" alt="img"></p>
<p>当然我们一般不会去人工解析这种16进制的字节码文件，我们一般可以通过javap命令生成更可读的JVM字节码指令文件：</p>
<p><strong>javap -v Math.class</strong></p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812715738.png" alt="img"></p>
<p>红框标出的就是class常量池信息，常量池中主要存放两大类常量：<strong>字面量和符号引用</strong>。</p>
<p><strong>字面量</strong></p>
<p><strong>字面量就是指由字母、数字等构成的字符串或者数值常量</strong></p>
<p>字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="string">&quot;abcdefg&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>符号引用</strong></p>
<p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：</p>
<ul>
<li>类和接口的全限定名 </li>
<li>字段的名称和描述符 </li>
<li>方法的名称和描述符</li>
</ul>
<p>上面的a，b就是字段名称，就是一种符号引用，还有Math类常量池里的 Lcom/tuling/jvm/Math 是类的全限定名，main和compute是方法名称，()是一种UTF8格式的描述符，这些都是符号引用。</p>
<p>这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装入内存就变成<strong>运行时常量池</strong>，对应的符号引用在程序加载或运行时会被转变为被加载到内存区域的代码的直接引用，也就是我们说的<strong>动态链接了。例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</strong></p>
<p><strong>字符串常量池</strong></p>
<p><strong>字符串常量池的设计思想</strong></p>
<ol>
<li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能</li>
<li>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化</li>
</ol>
<ul>
<li>为字符串开辟一个字符串常量池，类似于缓存区</li>
<li>创建字符串常量时，首先查询字符串常量池是否存在该字符串</li>
<li>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</li>
</ul>
<p><strong>三种字符串操作(Jdk1.7 及以上版本)</strong></p>
<ul>
<li>直接赋值字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;zhuge&quot;</span>;  <span class="comment">// s指向常量池中的引用</span></span><br></pre></td></tr></table></figure>

<p>这种方式创建的字符串对象，只会在常量池中。</p>
<p>因为有”zhuge”这个字面量，创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象</p>
<p>如果有，则直接返回该对象在常量池中的引用；</p>
<p>如果没有，则会在常量池中创建一个新对象，再返回引用。</p>
<ul>
<li>new String();</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;zhuge&quot;</span>);  <span class="comment">// s1指向内存中的对象引用</span></span><br></pre></td></tr></table></figure>

<p>这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。</p>
<p>步骤大致如下：</p>
<p>因为有”zhuge”这个字面量，所以会先检查字符串常量池中是否存在字符串”zhuge”</p>
<p>不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象”zhuge”；</p>
<p>存在的话，就直接去堆内存中创建一个字符串对象”zhuge”；</p>
<p>最后，将内存中的引用返回。</p>
<ul>
<li>intern方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;zhuge&quot;</span>);   </span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>String中的intern方法是一个 native 的方法，当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。<strong>否则，将intern返回的引用指向当前字符串 s1</strong>(<strong>jdk1.6版本需要将 s1 复制到字符串常量池里</strong>)。</p>
<p><strong>字符串常量池位置</strong></p>
<p>Jdk1.6及之前： 有永久代, 运行时常量池在永久代，运行时常量池包含字符串常量池</p>
<p>Jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里</p>
<p>Jdk1.8及之后： 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里</p>
<p>用一个程序证明下字符串常量池在哪里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6：-Xms6M -Xmx6M -XX:PermSize=6M -XX:MaxPermSize=6M  </span></span><br><span class="line"><span class="comment"> * jdk8：-Xms6M -Xmx6M -XX:MetaspaceSize=6M -XX:MaxMetaspaceSize=6M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            String str = String.valueOf(i).intern();</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">jdk7及以上：Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">jdk6：Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>

<p><strong>字符串常量池设计原理</strong></p>
<p>　　字符串常量池底层是hotspot的C++实现的，底层类似一个 HashTable， 保存的本质上是字符串对象的引用。</p>
<p>看一道比较常见的面试题，下面的代码创建了多少个 String 对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;he&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"> </span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">// 在 JDK 1.6 下输出是 false，创建了 6 个对象 s2指向的是永久代中字符串常量池的对象指针，s1是队中对象的指针，所以未false</span></span><br><span class="line"><span class="comment">// 在 JDK 1.7 及以上的版本输出是 true，创建了 5 个对象 s1指向的是队中的对象指针，由于jdk1.7 字符串常量池移到了堆中，故s2也是指向的堆中的对象的指针，所以为true;</span></span><br><span class="line"><span class="comment">// 当然我们这里没有考虑GC，但这些对象确实存在或存在过</span></span><br></pre></td></tr></table></figure>

<p>为什么输出会有这些变化呢？主要还是字符串池从永久代中脱离、移入堆区的原因， intern() 方法也相应发生了变化：</p>
<p>1、在 JDK 1.6 中，调用 intern() 首先会在字符串池中寻找 equal() 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用；假如字符串不存在，虚拟机会重新在永久代上创建一个实例，将 StringTable 的一个表项指向这个新创建的实例。</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812898896.png" alt="img"></p>
<p>JDK1.6，字符串常量池在永久代中， 执行new String(“he”) + new String(“llo”); 会在队中生成”hello”字符串，同时会在字符串常量池生成”hello”字符串，所以会有6个</p>
<p>字符串常量池底层类似是一个hashtable结构：key是引用，value是具体对象的值。</p>
<p>2、在 JDK 1.7 (及以上版本)中，由于字符串池不在永久代了，intern() 做了一些修改，更方便地利用堆中的对象。字符串存在时和 JDK 1.6一样，但是字符串不存在时不再需要重新创建实例，可以直接指向堆上的实例。</p>
<p><img src="/2022/04/24/00-00-08-Jvm%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/clipboard-1650812898896.png" alt="img"></p>
<p>　　由上面两个图，也不难理解为什么 JDK 1.6 字符串池溢出会抛出 OutOfMemoryError: PermGen space ，而在 JDK 1.7 及以上版本抛出 OutOfMemoryError: Java heap space 。</p>
<p><strong>String常量池问题的几个例子</strong></p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s0=<span class="string">&quot;zhuge&quot;</span>;</span><br><span class="line">String s1=<span class="string">&quot;zhuge&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;zhu&quot;</span> + <span class="string">&quot;ge&quot;</span>;</span><br><span class="line">System.out.println( s0==s1 ); <span class="comment">//true</span></span><br><span class="line">System.out.println( s0==s2 ); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>分析：因为例子中的 s0和s1中的”zhuge”都是字符串常量，它们在编译期就被确定了，所以s0 == s1为true；而”zhu”和”ge”也都是字符串常量，当一个字 符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被优化为一个字符串常量”zhuge”，所以s2也是常量池中” zhuge”的一个引用。所以我们得出s0== s1 ==s2；</p>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s0=<span class="string">&quot;zhuge&quot;</span>;</span><br><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">String s2=<span class="string">&quot;zhu&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;ge&quot;</span>);</span><br><span class="line">System.out.println( s0==s1 );　　<span class="comment">// false</span></span><br><span class="line">System.out.println( s0==s2 )；　 <span class="comment">// false</span></span><br><span class="line">System.out.println( s1==s2 );　　<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。</p>
<p>s0还是常量池 中”zhuge”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”zhuge”的引用，s2因为有后半部分 new String(”ge”)所以也无法在编译期确定，所以也是一个新创建对象”zhuge”的引用;明白了这些也就知道为何得出此结果了。</p>
<p>示例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a1&quot;</span>;</span><br><span class="line">  String b = <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;</span><br><span class="line">  System.out.println(a == b); <span class="comment">// true </span></span><br><span class="line">  </span><br><span class="line">  String a = <span class="string">&quot;atrue&quot;</span>;</span><br><span class="line">  String b = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;true&quot;</span>;</span><br><span class="line">  System.out.println(a == b); <span class="comment">// true </span></span><br><span class="line">  </span><br><span class="line">  String a = <span class="string">&quot;a3.4&quot;</span>;</span><br><span class="line">  String b = <span class="string">&quot;a&quot;</span> + <span class="number">3.4</span>;</span><br><span class="line">  System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>分析：JVM对于字符串常量的”+”号连接，将在程序编译期，JVM就将常量字符串的”+”连接优化为连接后的值，拿”a” + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。</p>
<p>示例4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String bb = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + bb; <span class="comment">//java 注意这个+号，java里面重载了+，</span></span><br><span class="line"><span class="comment">//其实调用了stringBuild，会new对象。</span></span><br><span class="line"></span><br><span class="line">System.out.println(a == b); <span class="comment">// false  </span></span><br></pre></td></tr></table></figure>

<p>分析：JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即”a” + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。</p>
<p>示例5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String bb = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + bb;</span><br><span class="line"></span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>分析：和示例4中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的”a” + bb和”a” + “b”效果是一样的。故上面程序的结果为true。</p>
<p>示例6：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String bb = getBB();</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + bb;</span><br><span class="line"></span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getBB</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和”a”来动态连接并分配地址为b，故上面 程序的结果为false。</p>
<p><strong>关于String是不可变的</strong></p>
<p>​    通过上面例子可以得出得知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String  s  =  <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;  <span class="comment">//就等价于String s = &quot;abc&quot;;</span></span><br><span class="line">String  a  =  <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String  b  =  <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String  c  =  <span class="string">&quot;c&quot;</span>;</span><br><span class="line">String  s1  =   a  +  b  +  c;</span><br></pre></td></tr></table></figure>

<p>s1 这个就不一样了，可以通过观察其<strong>JVM指令码</strong>发现s1的”+”操作会变成如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">temp.append(a).append(b).append(c);</span><br><span class="line">String s = temp.toString();</span><br></pre></td></tr></table></figure>

<p><strong>最后再看一个例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串常量池：&quot;计算机&quot;和&quot;技术&quot;     堆内存：str1引用的对象&quot;计算机技术&quot;  </span></span><br><span class="line"><span class="comment">//堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会new String()，这个String才是真正返回的对象引用</span></span><br><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;技术&quot;</span>).toString();   <span class="comment">//没有出现&quot;计算机技术&quot;字面量，所以不会在常量池里生成&quot;计算机技术&quot;对象</span></span><br><span class="line">System.out.println(str2 == str2.intern());  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//&quot;计算机技术&quot; 在池中没有，但是在heap中存在，则intern时，会直接返回该heap中的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串常量池：&quot;ja&quot;和&quot;va&quot;     堆内存：str1引用的对象&quot;java&quot;  </span></span><br><span class="line"><span class="comment">//堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会new String()，这个String才是真正返回的对象引用</span></span><br><span class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();    <span class="comment">//没有出现&quot;java&quot;字面量，所以不会在常量池里生成&quot;java&quot;对象</span></span><br><span class="line">System.out.println(str1 == str1.intern());  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//java是关键字，在JVM初始化的相关类里肯定早就放进字符串常量池了</span></span><br><span class="line"></span><br><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;test&quot;</span>);  </span><br><span class="line">System.out.println(s1==s1.intern());   <span class="comment">//false</span></span><br><span class="line"><span class="comment">//&quot;test&quot;作为字面量，放入了池中，而new时s1指向的是heap中新生成的string对象，s1.intern()指向的是&quot;test&quot;字面量之前在池中生成的字符串对象</span></span><br><span class="line"></span><br><span class="line">String s2=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>).toString();</span><br><span class="line">System.out.println(s2==s2.intern());  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<p><strong>八种基本类型的包装类和对象池</strong></p>
<p>java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫<strong>对象池，</strong>在堆上)，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，  </span></span><br><span class="line">        <span class="comment">//在值小于127时可以使用对象池  </span></span><br><span class="line">        Integer i1 = <span class="number">127</span>;  <span class="comment">//这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池</span></span><br><span class="line">        Integer i2 = <span class="number">127</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//输出true  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//值大于127时，不会从对象池中取对象  </span></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//输出false  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用new关键词新生成对象不会使用对象池</span></span><br><span class="line">        Integer i5 = <span class="keyword">new</span> Integer(<span class="number">127</span>);  </span><br><span class="line">        Integer i6 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//输出false </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean类也实现了对象池技术  </span></span><br><span class="line">        Boolean bool1 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean bool2 = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(bool1 == bool2);<span class="comment">//输出true  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//浮点类型的包装类没有实现对象池技术  </span></span><br><span class="line">        Double d1 = <span class="number">1.0</span>;</span><br><span class="line">        Double d2 = <span class="number">1.0</span>;</span><br><span class="line">        System.out.println(d1 == d2);<span class="comment">//输出false  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZGC深度剖析</title>
    <url>/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><strong>ZGC深度剖析</strong></p>
<p>JVM是虚拟机，能够识别字节码，就是class文件或者你打包的jar文件，运行在操作系统上。</p>
<p>JVM帮我们实现了跨平台，你只需要编译一次，就可以在不同的操作系统上运行，并且效果是一致的。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/09aca020f029.png" alt="img"></p>
<p>在Java中你使用对象，使用内存，不用担心回收，只管new对象就行了，不用管垃圾的回收。</p>
<p>因为Java当中是自动化的垃圾回收机制。JVM有专门的垃圾回收器，把垃圾回收这件事给干了。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/e14f43dd2baf.png" alt="img"></p>
<p><strong>ZGC出现背景</strong></p>
<p>但是对于Java的项目来说，JVM进行垃圾回收会有一个很大的问题，就是STW。</p>
<p>什么是STW，STW的全称是StopTheWorld。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/a502bd6f9329.png" alt="img"></p>
<p>Java项目中，如果JVM要进行垃圾回收，会暂停所有的业务线程，也就是项目中的线程，这样会导致业务系统暂停。</p>
<p><strong>STW带来的问题</strong></p>
<p><strong>手机系统(Android) 显示卡顿</strong></p>
<p>Google 主导的 Android 系统需要解决的一大问题就是显示卡顿问题，通过对 GC 算法的不断演进，停顿时间控制在几个ms 级别。</p>
<p>所以这也是Android与苹果IOS系统竞争的一大利器。</p>
<p><strong>证券交易系统实时性要求</strong></p>
<p>证券交易系统主要就是买入、卖出，现在都是使用系统完成自动下单，如果用Java系统来做，遇到了STW，假如STW的时间是3秒。</p>
<p>刚收到市场行情是比较低的买入的，但是因为STW卡顿了3秒，3秒后的市场行情可能完全不同。所以如果使用Java来做证券系统，一定是要求STW时间越短越好！</p>
<p><strong>大数据平台(Hadoop集群性能)</strong></p>
<p>同样，像58同城的大数据系统，单集群5000+的Hadoop集群，日万亿级实时数据分发。如果遇到STW也是不行的。</p>
<p><strong>垃圾回收器的发展</strong></p>
<p>为了满足不同的业务需求，Java 的 GC 算法也在不停迭代，对于特定的应用，选择其最适合的 GC 算法，才能更高效的帮助业务实现其业务目标。对于这些延迟敏感的应用来说，GC 停顿已经成为阻碍 Java 广泛应用的一大顽疾，需要更适合的 GC 算法以满足这些业务的需求。</p>
<p>近些年来，服务器的性能越来越强劲，各种应用可使用的堆内存也越来越大，常见的堆大小从 10G 到百 G 级别，部分机型甚至可以到达 TB 级别，在这类大堆应用上，传统的 GC，如 CMS、G1 的停顿时间也跟随着堆大小的增长而同步增加，即堆大小指数级增长时，停顿时间也会指数级增长。特别是当触发 Full GC 时，停顿可达分钟级别(百GB级别的堆)。当业务应用需要提供高服务级别协议（Service Level Agreement，SLA），例如 99.99% 的响应时间不能超过 100ms，此时 CMS、G1 等就无法满足业务的需求。</p>
<p>为满足当前应用对于超低停顿、并应对大堆和超大堆带来的挑战，伴随着 2018 年发布的 JDK 11，A Scalable Low-Latency Garbage Collector - ZGC 应运而生。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/4c4acef80cbe.png" alt="img"></p>
<p><strong>ZGC介绍</strong></p>
<p>ZGC（The Z Garbage Collector）是<a href="https://www.zhihu.com/search?q=JDK+11&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22364813270%22%7D">JDK 11</a>中推出的一款追求极致低延迟的垃圾收集器，它曾经设计目标包括：</p>
<ul>
<li><p><strong>停顿时间不超过10ms（JDK16已经达到不超过1ms）</strong>；</p>
</li>
<li><p>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</p>
</li>
<li><p>支持8MB~4TB级别的堆，JDK15后已经可以支持16TB。</p>
</li>
</ul>
<p>这么去想，如果使用ZGC来做Java项目，像对STW敏感的证券系统，游戏的系统都可以去用Java来做（以前都是C或者C++的市场），所以ZGC的出现就是为了抢占其他语言的市场（卷！）。</p>
<p><strong>ZGC中的内存布局</strong></p>
<p>为了细粒度地控制内存的分配，和G1一样，ZGC将内存划分成小的分区，在ZGC中称为页面（page）。</p>
<p><strong>ZGC中没有分代的概念（新生代、老年代）</strong></p>
<p>ZGC支持<strong>3种</strong>页面，分别为小页面、中页面和大页面。</p>
<p>其中小页面指的是2MB的页面空间，中页面指32MB的页面空间，大页面指受操作系统控制的大页。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/3aba9255dec8.png" alt="img"></p>
<p>当对象大小小于等于256KB时，对象分配在小页面。</p>
<p>当对象大小在256KB和4M之间，对象分配在中页面。</p>
<p>当对象大于4M，对象分配在大页面。</p>
<p>ZGC对于不同页面回收的策略也不同。<strong>简单地说，小页面优先回收；中页面和大页面则尽量不回收。</strong></p>
<p><strong>为什么这么设计？</strong></p>
<p><strong>这种分页模型垃圾回收的时候可以优先选择垃圾回收效率特别高的区域优先回收，从而提高垃圾回收效率。</strong></p>
<p>标准大页（huge page）是Linux Kernel 2.6引入的，目的是通过使用大页内存来取代传统的4KB内存页面，以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。</p>
<p>Huge pages 有两种格式大小： 2MB 和 1GB ， 2MB 页块大小适合用于 GB 大小的内存， 1GB 页块大小适合用于 TB 级别的内存； 2MB 是默认的页大小。</p>
<p>所以ZGC这么设置也是为了适应现代硬件架构的发展，提升性能。</p>
<p><strong>ZGC支持NUMA（了解即可）</strong></p>
<p>在过去，对于X86架构的计算机，内存控制器还没有整合进CPU，所有对内存的访问都需要通过北桥芯片来完成。X86系统中的所有内存都可以通过CPU进行同等访问。任何CPU访问任何内存的速度是一致的，不必考虑不同内存地址之间的差异，这称为“统一内存访问”（Uniform Memory Access，UMA）。UMA系统的架构示意图如图所示。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/5d0e48df526f.png" alt="img"></p>
<p>在UMA中，各处理器与内存单元通过互联总线进行连接，各个CPU之间没有主从关系。之后的X86平台经历了一场从“拼频率”到“拼核心数”的转变，越来越多的核心被尽可能地塞进了同一块芯片上，各个核心对于内存带宽的争抢访问成为瓶颈，所以人们希望能够把CPU和内存集成在一个单元上（称Socket），这就是非统一内存访问（Non-Uniform Memory Access，NUMA）。很明显，在NUMA下，CPU访问本地存储器的速度比访问非本地存储器快一些。下图所示是支持NUMA处理器架构示意图。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/f555399da3e6.png" alt="img"></p>
<p>ZGC是支持NUMA的，在进行小页面分配时会优先从本地内存分配，当不能分配时才会从远端的内存分配。对于中页面和大页面的分配，ZGC并没有要求从本地内存分配，而是直接交给操作系统，由操作系统找到一块能满足ZGC页面的空间。ZGC这样设计的目的在于，对于小页面，存放的都是小对象，从本地内存分配速度很快，且不会造成内存使用的不平衡，而中页面和大页面因为需要的空间大，如果也优先从本地内存分配，极易造成内存使用不均衡，反而影响性能。</p>
<p><strong>ZGC的核心概念</strong></p>
<p><strong>指针着色技术（Color Pointers）</strong></p>
<p>颜色指针可以说是ZGC的核心概念。因为他在指针中借了几个位出来做事情，所以它必须要求在64位的机器上才可以工作。并且因为要求64位的指针，也就不能支持压缩指针。</p>
<p>ZGC中低42位表示使用中的堆空间</p>
<p>ZGC借几位高位来做GC相关的事情(快速实现垃圾回收中的并发标记、转移和重定位等)</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/bc055bfc8e6a.png" alt="img"></p>
<p>我们通过一个例子演示Linux多视图映射。Linux中主要通过系统函数mmap完成视图映射。多个视图映射就是多次调用mmap函数，多次调用的返回结果就是不同的虚拟地址。示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个共享内存的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">shm_open</span>(<span class="string">&quot;/example&quot;</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//防止资源泄露,需要删除。执行之后共享对象仍然存活,但是不能通过名字访问</span></span><br><span class="line">    <span class="built_in">shm_unlink</span>(<span class="string">&quot;/example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将共享内存对象的大小设置为4字节</span></span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="built_in">ftruncate</span>(fd, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3次调用mmap,把一个共享内存对象映射到3个虚拟地址上</span></span><br><span class="line">    <span class="keyword">int</span> prot = PROT_READ | PROT_WRITE;</span><br><span class="line">    <span class="keyword">uint32_t</span> *remapped = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, prot, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> *m0 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, prot, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> *m1 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, prot, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试,通过一个虚拟地址设置数据,3个虚拟地址得到相同的数据</span></span><br><span class="line">    *remapped = <span class="number">0xdeafbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;48bit of remapped is: %p, value of 32bit is: 0x%x\n&quot;</span>, remapped, *remapped);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;48bit of m0 is: %p, value of 32bit is: 0x%x\n&quot;</span>, m0, *m0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;48bit of m1 is: %p, value of 32bit is: 0x%x\n&quot;</span>, m1, *m1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux上通过gcc编译后运行文件，得到的执行文件：</p>
<p>gcc -lrt -o mapping mapping.c</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/84e3c24fbb2a.png" alt="img"></p>
<p>然后执行下，我们来看下执行结果</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/6168a9be0dbb.png" alt="img"></p>
<p>从结果我们可以发现，3个变量对应3个不同的虚拟地址。</p>
<p><strong>实地址：（32位指针）</strong>是：0xdeafbeef &lt;一位16进制代表4位二进制&gt;</p>
<p><strong>虚地址：****（48位指针）</strong>:</p>
<p>0x7f93aef8e000&lt;虚地址remapped&gt;</p>
<p>0x7f93aef8d000&lt;虚地址m0&gt;</p>
<p>0x7f93aef8c000&lt;虚地址m1&gt;</p>
<p>但是因为它们都是通过mmap映射同一个内存共享对象，所以它们的物理地址是一样的，并且它们的值都是0xdeafbeef。</p>
<p><strong>ZGC流程</strong></p>
<p><strong>一次ZGC流程</strong></p>
<p>标记阶段(标识垃圾)</p>
<p>转移阶段(对象复制或移动)</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/8db56e2b2b5d.png" alt="img"></p>
<p><strong>根可达算法</strong></p>
<p>来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/49d50162cb40.png" alt="img"></p>
<p><strong>作为GC Roots的对象主要包括下面4种</strong></p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）：各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。</p>
</li>
<li><p>方法区中类静态变量：java类的引用类型静态变量。</p>
</li>
<li><p>方法区中常量：比如：字符串常量池里的引用。</p>
</li>
<li><p>本地方法栈中JNI指针：（即一般说的Native方法）。</p>
</li>
</ul>
<p><strong>ZGC中初始标记和并发标记</strong></p>
<p><strong>初始标记：</strong>从根集合(GC Roots)出发，找出根集合直接引用的活跃对象(根对象)</p>
<p><strong>并发标记：</strong>根据初始标记找到的根对象，使用深度优先遍历对象的成员变量进行标记</p>
<p><strong>ZGC基于指针着色的并发标记算法</strong></p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/38fc712d9763.png" alt="img"></p>
<p><strong>0．初始阶段</strong></p>
<p>在ZGC初始化之后，此时地址视图为Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动。</p>
<p><strong>1、初始标记</strong></p>
<p>这个阶段需要暂停（STW），初始标记只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，停顿时间不会随着堆的大小或者活跃对象的大小而增加。</p>
<p><strong>2、并发标记</strong></p>
<p>这个阶段不需要暂停（没有STW），扫描剩余的所有对象，这个处理时间比较长，所以走并发，业务线程与GC线程同时运行。但是这个阶段会产生漏标问题。</p>
<p><strong>3、再标记</strong></p>
<p>这个阶段需要暂停（没有STW），主要处理漏标对象，通过SATB算法解决（G1中的解决漏标的方案）。</p>
<p><strong>ZGC基于指针着色的并发转移算法</strong></p>
<p><strong>ZGC的转移阶段</strong></p>
<ul>
<li><p>并发转移准备(分析最有价值GC分页&lt;无STW &gt; )</p>
</li>
<li><p>初始转移（转移初始标记的存活对象同时做对象重定位&lt;有STW&gt; ）</p>
</li>
<li><p>并发转移（对转移并发标记的存活对象做转移&lt;无STW&gt;）</p>
</li>
</ul>
<p><strong>如何做到并发转移？</strong></p>
<p>转发表(类似于HashMap)</p>
<p>对象转移和插转发表做原子操作</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/280d64bc65d2.png" alt="img"></p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/5d2035bb5663.png" alt="img"></p>
<p><strong>ZGC基于指针着色的重定位算法</strong></p>
<p><strong>并发标记对象的重定位</strong></p>
<p>下次GC中的并发标记（同时做上次并发标记对象的重定位）</p>
<p>技术上：指针着色中M0和M1区分</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/121017230aa2.png" alt="img"></p>
<p><strong>ZGC中读屏障</strong></p>
<p><strong>ZGC中的读屏障</strong></p>
<p>涉及对象：并发转移但还没做对象重定位的对象（着色指针使用M0和M1可以区分）</p>
<p>触发时机：在两次GC之间业务线程访问这样的对象</p>
<p>触发操作：对象重定位+删除转发表记录（两个一起做原子操作）</p>
<p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。</p>
<p>需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/f33a4de39dfa.png" alt="img"></p>
<p><strong>ZGC中GC触发机制（JAVA16）</strong></p>
<p><strong>预热规则：</strong>服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”。</p>
<p>JVM启动预热，如果从来没有发生过GC，则在堆内存使用超过10%、20%、30%时，分别触发一次GC，以收集GC数据.</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/e1ee8c7e8a22.png" alt="img"></p>
<p><strong>基于分配速率的自适应算法：</strong>最主要的GC触发方式（默认方式），其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。日志中关键字是“Allocation Rate”。</p>
<p><img src="/2022/04/25/00-00-09-ZGC%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/9cff33c8be97.png" alt="img"></p>
<p><strong>基于固定时间间隔：</strong>通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景。</p>
<p><strong>主动触发规则：</strong>类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，我们的服务因为已经加了基于固定时间间隔的触发机制，所以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性。</p>
<p><strong>阻塞内存分配请求触发：</strong>当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation Stall”。</p>
<p><strong>外部触发：</strong>代码中显式调用System.gc()触发。 日志中关键字是“System.gc()”。</p>
<p><strong>元数据分配触发：</strong>元数据区不足时导致，一般不需要关注。 日志中关键字是“Metadata GC Threshold”。</p>
<p><strong>ZGC参数设置</strong></p>
<p>ZGC 优势不仅在于其超低的 STW 停顿，也在于其参数的简单，绝大部分生产场景都可以自适应。当然，极端情况下，还是有可能需要对 ZGC 个别参数做个调整，大致可以分为三类：</p>
<ul>
<li><p><strong>堆大小：</strong>Xmx。当分配速率过高，超过回收速率，造成堆内存不够时，会触发 Allocation Stall，这类 Stall 会减缓当前的用户线程。因此，当我们在 GC 日志中看到 Allocation Stall，通常可以认为堆空间偏小或者 concurrent gc threads 数偏小。</p>
</li>
<li><p><strong>GC 触发时机：</strong>ZAllocationSpikeTolerance, ZCollectionInterval。ZAllocationSpikeTolerance 用来估算当前的堆内存分配速率，在当前剩余的堆内存下，ZAllocationSpikeTolerance 越大，估算的达到 OOM 的时间越快，ZGC 就会更早地进行触发 GC。ZCollectionInterval 用来指定 GC 发生的间隔，以秒为单位触发 GC。</p>
</li>
<li><p><strong>GC 线程：</strong>ParallelGCThreads， ConcGCThreads。ParallelGCThreads 是设置 STW 任务的 GC 线程数目，默认为 CPU 个数的 60%；ConcGCThreads 是并发阶段 GC 线程的数目，默认为 CPU 个数的 12.5%。增加 GC 线程数目，可以加快 GC 完成任务，减少各个阶段的时间，但也会增加 CPU 的抢占开销，可根据生产情况调整。</p>
</li>
</ul>
<p>由上可以看出 ZGC 需要调整的参数十分简单，通常设置 Xmx 即可满足业务的需求，大大减轻 Java 开发者的负担。</p>
<p><strong>ZGC典型应用场景</strong></p>
<p>对于性能来说，不同的配置对性能的影响是不同的，如充足的内存下即大堆场景，ZGC 在各类 Benchmark 中能够超过 G1 大约 5% 到 20%，而在小堆情况下，则要低于 G1 大约 10%；不同的配置对于应用的影响不尽相同，开发者需要根据使用场景来合理判断。</p>
<p>当前 ZGC 不支持压缩指针和分代 GC，其内存占用相对于 G1 来说要稍大，在小堆情况下较为明显，而在大堆情况下，这些多占用的内存则显得不那么突出。<strong>因此，以下两类应用强烈建议使用 ZGC 来提升业务体验：</strong></p>
<ul>
<li>超大堆应用。超大堆（百 G 以上）下，CMS 或者 G1 如果发生 Full GC，停顿会在分钟级别，可能会造成业务的终端，强烈推荐使用 ZGC。</li>
<li>当业务应用需要提供高服务级别协议（Service Level Agreement，SLA），例如 99.99% 的响应时间不能超过 100ms，此类应用无论堆大小，均推荐采用低停顿的 ZGC。</li>
</ul>
<p><strong>ZGC生产注意事项</strong></p>
<p><strong>RSS 内存异常现象</strong></p>
<p>由前面 ZGC 原理可知，ZGC 采用多映射 multi-mapping 的方法实现了三份虚拟内存指向同一份物理内存。而 Linux 统计进程 RSS 内存占用的算法是比较脆弱的，这种多映射的方式并没有考虑完整，因此根据当前 Linux 采用大页和小页时，其统计的开启 ZGC 的 Java 进程的内存表现是不同的。在内核使用小页的 Linux 版本上，这种三映射的同一块物理内存会被 linux 的 RSS 占用算法统计 3 次，因此通常可以看到使用 ZGC 的 Java 进程的 RSS 内存膨胀了三倍左右，但是实际占用只有统计数据的三分之一，会对运维或者其他业务造成一定的困扰。而在内核使用大页的 Linux 版本上，这部分三映射的物理内存则会统计到 hugetlbfs inode 上，而不是当前 Java 进程上。</p>
<p><strong>共享内存调整</strong></p>
<p>ZGC 需要在 share memory 中建立一个内存文件来作为实际物理内存占用，因此当要使用的 Java 的堆大小大于 /dev/shm 的大小时，需要对 /dev/shm 的大小进行调整。通常来说，命令如下（下面是将 /dev/shm 调整为 64G）：</p>
<p>vi/etc/fstabtmpfs /dev/shm tmpfs defaults,size= 65536M00</p>
<p>首先修改 fstab 中 shm 配置的大小，size 的值根据需求进行修改，然后再进行 shm 的 mount 和 umount。</p>
<p>umount/dev/shmmount /dev/shm</p>
<p><strong>mmap 节点上限调整</strong></p>
<p>ZGC 的堆申请和传统的 GC 有所不同，需要占用的 memory mapping 数目更多，即每个 ZPage 需要 mmap 映射三次，这样系统中仅 Java Heap 所占用的 mmap 个数为 (Xmx / zpage_size) * 3，默认情况下 zpage_size 的大小为 2M。</p>
<p>为了给 JNI 等 native 模块中的 mmap 映射数目留出空间，内存映射的数目应该调整为 (Xmx / zpage_size) 3*1.2。</p>
<p>默认的系统 memory mapping 数目由文件 /proc/sys/vm/max_map_count 指定，通常数目为 65536，当给 JVM 配置一个很大的堆时，需要调整该文件的配置，使得其大于 (Xmx / zpage_size) 3*1.2。</p>
<p><strong>ZGC存在的问题及持续改进</strong></p>
<p>目前ZGC历代版本中存在的一些问题（阿里、腾讯、美团、华为等大厂在支持业务切换 ZGC 的出现的），基本上都已经将遇到的相关问题和修复积极向社区报告和回馈，很多问题在JDK16和JDK17已经修复完善。另外的话，问题相对来说不是非常严重，如果遇到类似的问题可以查看下JVM团队的历代修复日志，同时建议就是尽量使用比较新的版本来上线，以免重复掉坑里面。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
        <tag>ZGC</tag>
      </tags>
  </entry>
  <entry>
    <title>Explain详解与索引最佳实践</title>
    <url>/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Explain工具介绍"><a href="#一、Explain工具介绍" class="headerlink" title="一、Explain工具介绍"></a>一、Explain工具介绍</h2><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈 （:模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如</p>
<p>何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈）。在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返</p>
<p>回执行计划的信息，而不是 执行这条SQL 。注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。</p>
<p><strong>分析案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE</span><br><span class="line">IF EXISTS `actor`;</span><br><span class="line">CREATE TABLE `actor` (</span><br><span class="line">    `id` INT ( 11 ) NOT NULL, </span><br><span class="line">    `name` VARCHAR ( 45 ) DEFAULT NULL, </span><br><span class="line">    `update_time` datetime DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY ( `id` ) </span><br><span class="line">) ENGINE = INNODB DEFAULT CHARSET = utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `actor` ( `id`, `name`, `update_time` )</span><br><span class="line">VALUES</span><br><span class="line">	( 1, &#x27;a&#x27;, &#x27;2017‐12‐22 15:27:18&#x27; ),</span><br><span class="line">	( 2, &#x27;b&#x27;, &#x27;2017‐12‐22 15:27:18&#x27; ),</span><br><span class="line">	( 3, &#x27;c&#x27;, &#x27;2017‐12‐22 15:27:18&#x27; );</span><br><span class="line">DROP TABLE IF EXISTS `film`;</span><br><span class="line">CREATE TABLE `film` (</span><br><span class="line">	`id` INT ( 11 ) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	`name` VARCHAR ( 10 ) DEFAULT NULL,</span><br><span class="line">	PRIMARY KEY ( `id` ),</span><br><span class="line">	KEY `idx_name` ( `name` ) </span><br><span class="line">) ENGINE = INNODB DEFAULT CHARSET = utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `film` ( `id`, `name` )</span><br><span class="line">VALUES</span><br><span class="line">	( 3, &#x27;film0&#x27; ),(</span><br><span class="line">		1,</span><br><span class="line">		&#x27;film1&#x27; </span><br><span class="line">		),(</span><br><span class="line">		2,</span><br><span class="line">		&#x27;film2&#x27; </span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">DROP TABLE IF EXISTS `film_actor`;</span><br><span class="line">CREATE TABLE `film_actor` (</span><br><span class="line">	`id` INT ( 11 ) NOT NULL,</span><br><span class="line">	`film_id` INT ( 11 ) NOT NULL,</span><br><span class="line">	`actor_id` INT ( 11 ) NOT NULL,</span><br><span class="line">	`remark` VARCHAR ( 255 ) DEFAULT NULL,</span><br><span class="line">	PRIMARY KEY ( `id` ),</span><br><span class="line">	KEY `idx_film_actor_id` ( `film_id`, `actor_id` ) </span><br><span class="line">) ENGINE = INNODB DEFAULT CHARSET = utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `film_actor` ( `id`, `film_id`, `actor_id` )</span><br><span class="line">VALUES</span><br><span class="line">	( 1, 1, 1 ),</span><br><span class="line">	(2,1,2 ),</span><br><span class="line">	(3,2,1);</span><br></pre></td></tr></table></figure>

<h2 id="二、Explain的两个变种"><a href="#二、Explain的两个变种" class="headerlink" title="二、Explain的两个变种"></a>二、Explain的两个变种</h2><p>1）<s><strong>explain extended</strong></s>&gt;（5.7已被废弃） ：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器</p>
<p>优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以<strong>估算</strong>出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id</p>
<p>值比当前表id值小的 表）。</p>
<p>2）<strong>explain partitions</strong>：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h2 id="三、Explain中的列"><a href="#三、Explain中的列" class="headerlink" title="三、Explain中的列"></a>三、Explain中的列</h2><p><strong>1. id列</strong> </p>
<p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 </p>
<p>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p>
<p><strong>2. select_type列</strong> </p>
<p>select_type 表示对应行是简单还是复杂的查询。 </p>
<p>1）simple：简单查询。查询不包含子查询和union</p>
<p><strong>例子</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from film where id = 2;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184114992.png" alt="image-20220522184114992"></p>
<p>2）primary：复杂查询中最外层的 select </p>
<p>3）subquery：包含在 select 中的子查询（不在 from 子句中） </p>
<p>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p>
<p>用以下例子来了解 primary、subquery 和 derived 类型 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合 并优化 </span><br><span class="line">mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184247978.png" alt="image-20220522184247978"></p>
<p>5）union：在 union 中的第二个和随后的 select </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184346644.png" alt="image-20220522184346644"></p>
<p><strong>3. table列</strong> </p>
<p>这一列表示 explain 的一行正在访问哪个表。 </p>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</derivenN></p>
<p><strong>4. type列</strong> </p>
<p>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong> 一般来说，<strong>得保证查询达到range级别，最好达到ref</strong> </p>
<p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184518675.png" alt="image-20220522184518675"></p>
<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是</strong>const的特例**，表里只有一条元组匹配时为system 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;explain extended select * from (select * from film where id = 1) tmp;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184650603.png" alt="image-20220522184650603"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show warnings; ## 查询优化之后的sql语句，伪sql 可以执行/</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184835078.png" alt="image-20220522184835078"></p>
<p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522184938144.png" alt="image-20220522184938144"></p>
<p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。 </p>
<ol>
<li>简单 select 查询，name是普通索引（非唯一索引）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from film where name = &#x27;film1&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522185056124.png" alt="image-20220522185056124"></p>
<ol start="2">
<li>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522185156744.png" alt="image-20220522185156744"></p>
<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from actor where id &gt; 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522185251345.png" alt="image-20220522185251345"></p>
<p><strong>index</strong>：扫描全索引就能拿到结果，一般是<strong>扫描某个二级索引</strong>，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from film; // 默认能走二级索引和一级索引的情况下优先走二级索引，二级索引数据少，访问比较快</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522185344830.png" alt="image-20220522185344830"></p>
<p><strong>ALL</strong>：即<strong>全表扫描（扫描二级索引）</strong>，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522185635801.png" alt="image-20220522185635801"></p>
<p><strong>5. possible_keys列</strong> </p>
<p>这一列显示查询可能使用哪些索引来查找。 </p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。如果</p>
<p>该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。 </p>
<p><strong>6. key列</strong> </p>
<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。 </p>
<p><strong>7. key_len列</strong> </p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from film_actor where film_id = 2; // 用来分析使用索引部分所在大小 比如此例 使用了联合索引的film_id字段，占4字节</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522185758980.png" alt="image-20220522185758980"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from film_actor where film_id = 2 and actor_id = 8;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522190907609.png" alt="image-20220522190907609"></p>
<p>key_len计算规则如下： </p>
<ul>
<li>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数，</strong>如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节 <ul>
<li>char(n)：如果存汉字长度就是 3n 字节 </li>
<li>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为 </li>
</ul>
</li>
</ul>
<p>varchar是变长字符串 </p>
<ul>
<li><p>数值类型</p>
<ul>
<li><p>tinyint：1字节 </p>
</li>
<li><p>smallint：2字节 </p>
</li>
<li><p>int：4字节 </p>
</li>
<li><p>bigint：8字节 </p>
</li>
</ul>
</li>
<li><p>时间类型</p>
<ul>
<li><p>date：3字节timestamp：4字节 </p>
</li>
<li><p>datetime：8字节 </p>
</li>
</ul>
</li>
<li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL 。</p>
</li>
</ul>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<p><strong>8. ref列</strong> </p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </p>
<p>索引关联的哪个字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from film_actor where film_id = 2 and actor_id = 8;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522190907609.png" alt="image-20220522190907609"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select film_id from film left join film_actor on film.id = film_actor.film_id;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522191429423.png" alt="image-20220522191429423"></p>
<p><strong>9. rows列</strong> </p>
<p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<p><strong>10. Extra列</strong> </p>
<p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>1）<strong>Using index</strong>：使用覆盖索引 </p>
<p><strong>覆盖索引定义</strong>（查找sql的一种方式，查询的字段在key列索引中，不需要回表，速度较回表的方式要快）：mysql执行计划explain结果里的key有使用索引，如果</p>
<p>select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，</p>
<p>整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select film_id from film_actor where film_id = 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201222232.png" alt="image-20220522201222232"></p>
<p>2）<strong>Using where</strong>（查询的列没有使用索引，普通where语句）：使用 where 语句来处理结果，并且查询的列未被索引覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from actor where name = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201313580.png" alt="image-20220522201313580"></p>
<p>3）<strong>Using index condition</strong>（用到联合索引第一个列，并且不是覆盖索引）：查询的列不完全被索引覆盖，where条件中是一个前导列的范围； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201417833.png" alt="image-20220522201417833"></p>
<p>4）<strong>Using temporary</strong>（使用了临时表）：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。 </p>
<ol>
<li>actor.name没有索引，此时创建了张临时表来distinct </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select distinct name from actor;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201526607.png" alt="image-20220522201526607"></p>
<ol start="2">
<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select distinct name from film;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201655875.png" alt="image-20220522201655875"></p>
<p>5）<strong>Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。 </p>
<ol>
<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201804521.png" alt="image-20220522201804521"></p>
<ol start="2">
<li>film.name建立了idx_name索引,此时查询时extra是using index</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from film order by name;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201903182.png" alt="image-20220522201903182"></p>
<p>6）<strong>Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522201940986.png" alt="image-20220522201940986"></p>
<h2 id="四、索引最佳实践"><a href="#四、索引最佳实践" class="headerlink" title="四、索引最佳实践"></a>四、索引最佳实践</h2><p>示例表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `employees` (</span><br><span class="line">	 `id` INT ( 11 ) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	 `name` VARCHAR ( 24 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">	 `age` INT ( 11 ) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class="line">	 `position` VARCHAR ( 20 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class="line">	 `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,</span><br><span class="line">	 PRIMARY KEY ( `id` ),</span><br><span class="line">	 KEY `idx_name_age_position` ( `name`, `age`, `position` ) USING BTREE  </span><br><span class="line">) ENGINE = INNODB AUTO_INCREMENT = 4 DEFAULT CHARSET = utf8 COMMENT = &#x27;员工记录表&#x27;;</span><br><span class="line"> INSERT INTO employees ( NAME, age, position, hire_time )</span><br><span class="line">VALUES</span><br><span class="line">	(</span><br><span class="line">		&#x27;LiLei&#x27;,</span><br><span class="line">		22,</span><br><span class="line">		&#x27;manager&#x27;,</span><br><span class="line">	NOW());</span><br><span class="line"> INSERT INTO employees ( NAME, age, position, hire_time )</span><br><span class="line">VALUES</span><br><span class="line">	(</span><br><span class="line">		&#x27;HanMeimei&#x27;,</span><br><span class="line">		23,</span><br><span class="line">		&#x27;dev&#x27;,</span><br><span class="line">	NOW());</span><br><span class="line"> INSERT INTO employees ( NAME, age, position, hire_time )</span><br><span class="line">VALUES</span><br><span class="line">	(</span><br><span class="line">		&#x27;Lucy&#x27;,</span><br><span class="line">		23,</span><br><span class="line">	&#x27;dev&#x27;,</span><br><span class="line">	NOW());</span><br></pre></td></tr></table></figure>

<p><strong>1.全值匹配</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522204927957.png" alt="image-20220522204927957"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522205000007.png" alt="image-20220522205000007"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522205035354.png" alt="image-20220522205035354"></p>
<p><strong>2.最左前缀法则</strong> </p>
<p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name = &#x27;Bill&#x27; and age = 31;</span><br><span class="line">EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = &#x27;dev&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM employees WHERE position = &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522205224339.png" alt="image-20220522205224339"></p>
<p>给hire_time增加一个普通索引： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;</span><br><span class="line">EXPLAIN select * from employees where date(hire_time) =&#x27;2018‐09‐30&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522205640634.png" alt="image-20220522205640634"></p>
<p>转化为日期范围查询，有可能会走索引： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN select * from employees where hire_time &gt;=&#x27;2018‐09‐30 00:00:00&#x27; and hire_time &lt; =&#x27;2018‐09‐30 23:59:59&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522210215287.png" alt="image-20220522210215287"></p>
<p>还原最初索引状态 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `employees` DROP INDEX `idx_hire_time`;</span><br></pre></td></tr></table></figure>

<p><strong>4.存储引擎不能使用索引中范围条件右边的列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;; </span><br><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age &gt; 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522210438591.png" alt="image-20220522210438591"></p>
<p><strong>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,age FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211011515.png" alt="image-20220522211011515"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211047207.png" alt="image-20220522211047207"></p>
<p><strong>6.mysql在使用不等于（！=或者&lt;&gt;），****not in</strong> <strong>，****not exists</strong> <strong>的时候无法使用索引会导致全表扫描</strong> <strong>&lt;** **小于、** **&gt;</strong> <strong>大于、</strong> <strong>&lt;=****、****&gt;=</strong> <strong>这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name != &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211148886.png" alt="image-20220522211148886"></p>
<p><strong>7.is null,is not null 一般情况下也无法使用索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name is null</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211219913.png" alt="image-20220522211219913"></p>
<p><strong>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name like &#x27;%Lei&#x27; ## %在前说明可能有多个其它字符，无序</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211314423.png" alt="image-20220522211314423"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name like &#x27;Lei%&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211341070.png" alt="image-20220522211341070"></p>
<p><strong>问题：解决like’%字符串%’索引不被使用的方法？</strong> </p>
<p>a）使用覆盖索引，查询字段必须是建立覆盖索引字段 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,age,position FROM employees WHERE name like &#x27;%Lei%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211425742.png" alt="image-20220522211425742"></p>
<p>b）如果不能使用覆盖索引则可能需要借助搜索引擎 </p>
<p><strong>9.字符串不加单引号索引失效</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name = &#x27;1000&#x27;; </span><br><span class="line">EXPLAIN SELECT * FROM employees WHERE name = 1000;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211525507.png" alt="image-20220522211525507"></p>
<p><strong>10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评</strong> <strong>估是否使用索引，详见范围查询优化</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211616921.png" alt="image-20220522211616921"></p>
<p><strong>11.范围查询优化</strong> </p>
<p>给年龄添加单值索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ; </span><br><span class="line">explain select * from employees where age &gt;=1 and age &lt;=2000;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211729491.png" alt="image-20220522211729491"></p>
<p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是 由于单次数据量查询过大导致优化器最终选择不走索引 </p>
<p>优化方法：可以将大的范围拆分成多个小范围 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from employees where age &gt;=1 and age &lt;=1000;</span><br><span class="line">explain select * from employees where age &gt;=1001 and age &lt;=2000;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211845080.png" alt="image-20220522211845080"></p>
<p>还原最初索引状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `employees` DROP INDEX `idx_age`;</span><br></pre></td></tr></table></figure>

<p><strong>索引使用总结：</strong></p>
<p><img src="/2022/05/22/00-02-01-explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20220522211932508.png" alt="image-20220522211932508"></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>性能调优</category>
        <category>Explain</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>Explain</tag>
        <tag>执行计划</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU缓存架构&amp;缓存一致性协议</title>
    <url>/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、CPU高速缓存（Cache-Memory）"><a href="#一、CPU高速缓存（Cache-Memory）" class="headerlink" title="一、CPU高速缓存（Cache Memory）"></a>一、CPU高速缓存（Cache Memory）</h2><h3 id="1、CPU高速缓存"><a href="#1、CPU高速缓存" class="headerlink" title="1、CPU高速缓存"></a>1、CPU高速缓存</h3><p>CPU缓存即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,减少CPU的等待时间，提高了系统的效率。</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/27511.png" alt="img"></p>
<p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就是局部性原理。</p>
<p><strong>时间局部性（Temporal Locality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p>
<p>比如循环、递归、方法的反复调用等。</p>
<p><strong>空间局部性（Spatial Locality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p>
<p>比如顺序执行的代码、连续创建的两个对象、数组等。</p>
<h3 id="2、多CPU多核缓存架构"><a href="#2、多CPU多核缓存架构" class="headerlink" title="2、多CPU多核缓存架构"></a>2、多CPU多核缓存架构</h3><p><strong>物理CPU：</strong>物理CPU就是插在主机上的真实的CPU硬件，在Linux下可以数不同的physical id 来确认主机的物理CPU个数。 </p>
<p><strong>核心数</strong>：我们常常会听说多核处理器，其中的核指的就是核心数。在Linux下可以通过cores来确认主机的物理CPU的核心数。</p>
<p><strong>逻辑CPU</strong>：逻辑CPU跟超线程技术有联系，假如物理CPU不支持超线程的，那么逻辑CPU的数量等于核心数的数量；如果物理CPU支持超线程，那么逻辑CPU的数目是核心数数目的两倍。在Linux下可以通过 processors 的数目来确认逻辑CPU的数量。</p>
<p>现代CPU为了提升执行效率，减少CPU与内存的交互，一般在CPU上集成了多级缓存架构，常见的为三级缓存结构。</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/27504.png" alt="img"></p>
<h2 id="二、缓存一致性（Cache-coherence）"><a href="#二、缓存一致性（Cache-coherence）" class="headerlink" title="二、缓存一致性（Cache coherence）"></a>二、缓存一致性（Cache coherence）</h2><p>计算机体系结构中，缓存一致性是共享资源数据的一致性，这些数据最终存储在多个本地缓存中。当系统中的客户机维护公共内存资源的缓存时，可能会出现数据不一致的问题，这在多处理系统中的cpu中尤其如此。</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/27424.gif" alt="img"></p>
<p>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据可能有多个副本:一个副本在主内存中，一个副本在请求它的每个处理器的本地缓存中。当数据的一个副本发生更改时，其他副本必须反映该更改。缓存一致性是确保共享操作数(数据)值的变化能够及时地在整个系统中传播的规程。</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/27431.gif" alt="img"></p>
<h3 id="1、缓存一致性的要求"><a href="#1、缓存一致性的要求" class="headerlink" title="1、缓存一致性的要求"></a>1、缓存一致性的要求</h3><p><strong>写传播（Write Propagation）</strong></p>
<p>对任何缓存中的数据的更改都必须传播到对等缓存中的其他副本(该缓存行的副本)。</p>
<p><strong>事务串行化（Transaction Serialization）</strong></p>
<p>对单个内存位置的读/写必须被所有处理器以相同的顺序看到。理论上，一致性可以在加载/存储粒度上执行。然而，在实践中，它通常在缓存块的粒度上执行。</p>
<p><strong>一致性机制（Coherence mechanisms）</strong></p>
<p>确保一致性的两种最常见的机制是窥探机制（snooping ）和基于目录的机制（directory-based），这两种机制各有优缺点。如果有足够的带宽可用，基于协议的窥探往往会更快，因为所有事务都是所有处理器看到的请求/响应。其缺点是窥探是不可扩展的。每个请求都必须广播到系统中的所有节点，这意味着随着系统变大，(逻辑或物理)总线的大小及其提供的带宽也必须增加。另一方面，目录往往有更长的延迟(3跳 请求/转发/响应)，但使用更少的带宽，因为消息是点对点的，而不是广播的。由于这个原因，许多较大的系统(&gt;64核心处理器)使用这种类型的缓存一致性。</p>
<h3 id="2、总线仲裁机制"><a href="#2、总线仲裁机制" class="headerlink" title="2、总线仲裁机制"></a>2、总线仲裁机制</h3><p>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（Bus Transaction）。总线事务包括读事务（Read Transaction）和写事务（WriteTransaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/28363.png" alt="img"></p>
<p>假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（Bus Arbitration）会对竞争做出裁决，这里假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其他两个处理器则要等待处理器A的总线事务完成后才能再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的请求会被总线禁止。</p>
<p>总线的这种工作机制可以把所有处理器对内存的访问以串行化的方式来执行。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<p>原子操作是指不可被中断的一个或者一组操作。处理器会自动保证基本的内存操作的原子性，也就是一个处理器从内存中读取或者写入一个字节时，其他处理器是不能访问这个字节的内存地址。最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p><strong>总线锁定</strong></p>
<p>总线锁定就是使用处理器提供的一个 LOCK＃信号，当其中一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p>串行，回到了单核时代。LOCK前缀+LOCK#实现</p>
<p><strong>缓存锁定</strong></p>
<p>由于总线锁定阻止了被阻塞处理器和所有内存之间的通信，而输出LOCK#信号的CPU可能只需要锁住特定的一块内存区域，因此总线锁定开销较大。</p>
<p>缓存锁定是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不会在总线上声言LOCK＃信号（总线锁定信号），而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>缓存锁定不能使用的特殊情况：</p>
<ul>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。</li>
<li>有些处理器不支持缓存锁定。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">《64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf》中有如下描述：</span><br><span class="line"></span><br><span class="line">The 32-bit IA-32 processors support locked atomic operations on locations in system memory. These operations are typically used to manage shared data structures (such as semaphores, segment descriptors, system segments, or page tables) in which two or more processors may try simultaneously to modify the same field or flag. The processor uses three interdependent mechanisms for carrying out locked atomic operations: </span><br><span class="line"></span><br><span class="line">• Guaranteed atomic operations </span><br><span class="line"></span><br><span class="line">• Bus locking, using the LOCK# signal and the LOCK instruction prefix</span><br><span class="line"></span><br><span class="line">• Cache coherency protocols that ensure that atomic operations can be carried out on cached data structures (cache lock); this mechanism is present in the Pentium 4, Intel Xeon, and P6 family processors</span><br></pre></td></tr></table></figure>

<p>32位的IA-32处理器支持对系统内存中的位置进行锁定的原子操作。这些操作通常用于管理共享的数据结构(如信号量、段描述符、系统段或页表)，在这些结构中，两个或多个处理器可能同时试图修改相同的字段或标志。处理器使用三种相互依赖的机制来执行锁定的原子操作:</p>
<ul>
<li>有保证的原子操作</li>
<li>总线锁定，使用LOCK#信号和LOCK指令前缀</li>
<li>缓存一致性协议，确保原子操作可以在缓存的数据结构上执行(缓存锁);这种机制出现在Pentium 4、Intel Xeon和P6系列处理器中</li>
</ul>
<h3 id="3、总线窥探-Bus-Snooping"><a href="#3、总线窥探-Bus-Snooping" class="headerlink" title="3、总线窥探(Bus Snooping)"></a>3、总线窥探(Bus Snooping)</h3><p>总线窥探(Bus snooping)是缓存中的一致性控制器(snoopy cache)监视或窥探总线事务的一种方案，其目标是在分布式共享内存系统中维护缓存一致性。包含一致性控制器(snooper)的缓存称为snoopy缓存。该方案由Ravishankar和Goodman于1983年提出。</p>
<p><strong>工作原理</strong></p>
<p>当特定数据被多个缓存共享时，处理器修改了共享数据的值，更改必须传播到所有其他具有该数据副本的缓存中。这种更改传播可以防止系统违反缓存一致性。数据变更的通知可以通过总线窥探来完成。所有的窥探者都在监视总线上的每一个事务。如果一个修改共享缓存块的事务出现在总线上，所有的窥探者都会检查他们的缓存是否有共享块的相同副本。如果缓存中有共享块的副本，则相应的窥探者执行一个动作以确保缓存一致性。这个动作可以是刷新缓存块或使缓存块失效。它还涉及到缓存块状态的改变，这取决于缓存一致性协议（cache coherence protocol）。</p>
<p><strong>窥探协议类型</strong></p>
<p>根据管理写操作的本地副本的方式，有两种窥探协议:</p>
<p><strong>Write-invalidate</strong></p>
<p>当处理器写入一个共享缓存块时，其他缓存中的所有共享副本都会通过总线窥探失效。这种方法确保处理器只能读写一个数据的一个副本。其他缓存中的所有其他副本都无效。这是最常用的窥探协议。MSI、MESI、MOSI、MOESI和MESIF协议属于该类型。</p>
<p><strong>Write-update</strong></p>
<p>当处理器写入一个共享缓存块时，其他缓存的所有共享副本都会通过总线窥探更新。这个方法将写数据广播到总线上的所有缓存中。它比write-invalidate协议引起更大的总线流量。这就是为什么这种方法不常见。Dragon和firefly协议属于此类别。</p>
<h3 id="4、一致性协议（Coherence-protocol）"><a href="#4、一致性协议（Coherence-protocol）" class="headerlink" title="4、一致性协议（Coherence protocol）"></a>4、<strong>一致性协议（Coherence protocol）</strong></h3><p>一致性协议在多处理器系统中应用于高速缓存一致性。为了保持一致性，人们设计了各种模型和协议，如MSI、MESI(又名Illinois)、MOSI、MOESI、MERSI、MESIF、write-once、Synapse、Berkeley、Firefly和Dragon协议。</p>
<ul>
<li>MSI protocol, the basic protocol from which the MESI protocol is derived.</li>
<li>Write-once (cache coherency), an early form of the MESI protocol.</li>
<li>MESI protocol</li>
<li>MOSI protocol</li>
<li>MOESI protocol</li>
<li>MESIF protocol</li>
<li>MERSI protocol</li>
<li>Dragon protocol</li>
<li>Firefly protocol</li>
</ul>
<p><strong>MESI协议</strong></p>
<p><strong>MESI协议</strong>是一个基于写失效的缓存一致性协议，是支持回写（write-back）缓存的最常用协议。也称作<strong>伊利诺伊协议</strong> (Illinois protocol，因为是在伊利诺伊大学厄巴纳-香槟分校被发明的)。与写通过（write through）缓存相比，回写缓冲能节约大量带宽。总是有“脏”（dirty）状态表示缓存中的数据与主存中不同。MESI协议要求在缓存不命中（miss）且数据块在另一个缓存时，允许缓存到缓存的数据复制。与MSI协议相比，MESI协议减少了主存的事务数量。这极大改善了性能。</p>
<p><strong>状态</strong></p>
<p>缓存行有4种不同的状态:</p>
<p><strong>已修改Modified (M)</strong></p>
<p>缓存行是脏的（<em>dirty</em>），与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享(S).</p>
<p><strong>独占Exclusive (E)</strong></p>
<p>缓存行只在当前缓存中，但是干净的–缓存数据同于主存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。</p>
<p><strong>共享Shared (S)</strong></p>
<p>缓存行也存在于其它缓存中且是未修改的。缓存行可以在任意时刻抛弃。</p>
<p><strong>无效Invalid (I)</strong></p>
<p>缓存行是无效的</p>
<p>任意一对缓存，对应缓存行的相容关系:</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/27468.png" alt="img"></p>
<p>当块标记为 M (已修改), 在其他缓存中的数据副本被标记为I(无效).</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/27472.png" alt="img"></p>
<p>什么情况下缓存一致性保证不了：</p>
<p>1、跨缓存行</p>
<p>2、早期处理器没有实现缓存一致性协议</p>
<h3 id="5、伪共享的问题"><a href="#5、伪共享的问题" class="headerlink" title="5、伪共享的问题"></a>5、<strong>伪共享的问题</strong></h3><p>如果多个核的线程在操作同一个缓存行中的不同变量数据，那么就会出现频繁的缓存失效，即使在代码层面看这两个线程操作的数据之间完全没有关系。这种不合理的资源竞争情况就是伪共享（False Sharing）。</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/28388.png" alt="img"></p>
<p><strong>linux下查看Cache Line大小</strong></p>
<p>Cache Line大小是64Byte</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/28379.png" alt="img"></p>
<p>或者执行 cat /proc/cpuinfo  命令</p>
<p><img src="/2022/04/28/01-00-01-CPU%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/28382.png" alt="img"></p>
<p><strong>避免伪共享方案</strong> </p>
<p><strong>1.缓存行填充</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="comment">//避免伪共享： 缓存行填充</span></span><br><span class="line">    <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.使用 @sun.misc.Contended 注解（java8）</strong></p>
<p>注意需要配置jvm参数：-XX:-RestrictContended</p>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testPointer(<span class="keyword">new</span> Pointer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPointer</span><span class="params">(Pointer pointer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                pointer.x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                pointer.y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(pointer.x+<span class="string">&quot;,&quot;</span>+pointer.y);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免伪共享： @Contended +  jvm参数：-XX:-RestrictContended  jdk8支持</span></span><br><span class="line">    <span class="comment">//@Contended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="comment">//避免伪共享： 缓存行填充</span></span><br><span class="line">    <span class="comment">//long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、as-if-serial-amp-happens-before"><a href="#三、as-if-serial-amp-happens-before" class="headerlink" title="三、as-if-serial   &amp;  happens-before"></a>三、<strong>as-if-serial</strong>   &amp;  <strong>happens-before</strong></h3><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</strong>编译器、runtime和处理器都必须遵守as-if-serial语义。  </p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p><strong>happens-before原则定义如下：</strong></p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 </li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ol>
<p><strong>下面是happens-before原则规则：</strong></p>
<p>1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<p>2.锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</p>
<p>3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p>
<p>4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<p>5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</p>
<p>6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
<p>7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
<p>8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
<p><strong>=&gt;&gt;推导出其他满足happens-before的规则</strong></p>
<p>1.将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作</p>
<p>2.将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作</p>
<p>3.在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作</p>
<p>4.释放Semaphore许可的操作Happens-Before获得许可操作</p>
<p>5.Future表示的任务的所有操作Happens-Before Future#get()操作</p>
<p>6.向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之深入理解Java线程</title>
    <url>/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="并发编程之深入理解Java线程"><a href="#并发编程之深入理解Java线程" class="headerlink" title="并发编程之深入理解Java线程"></a>并发编程之深入理解Java线程</h2><h3 id="1-线程基础知识"><a href="#1-线程基础知识" class="headerlink" title="1. 线程基础知识"></a>1. 线程基础知识</h3><p><code>线程和进程</code></p>
<p><strong>进程</strong> </p>
<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中</li>
</ul>
<p>​              还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 。</p>
<ul>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只</li>
</ul>
<p>​               能启动一个实例进程（例如网易云音乐、360 安全卫士等）。</p>
<ul>
<li>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</li>
</ul>
<p><strong>线程</strong> </p>
<ul>
<li>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。 </li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</li>
</ul>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/29111.png" alt="img"></p>
<p><strong>进程与线程的区别</strong></p>
<ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p>
</li>
<li><p>进程间通信较为复杂</p>
</li>
<li><ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<p><strong>进程间通信的方式</strong></p>
<ol>
<li><strong>管道（pipe）及有名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</li>
<li><strong>信号（signal）</strong>：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</li>
<li><strong>消息队列（message queue）</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</li>
<li><strong>共享内存（shared memory）</strong>：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</li>
<li><strong>信号量（semaphore）</strong>：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</li>
<li><strong>套接字（socket）</strong>：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
</ol>
<p><code>线程的同步互斥</code></p>
<p><strong>线程同步</strong>是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p><strong>线程互斥</strong>是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<p><strong>四种线程同步互斥的控制方法</strong></p>
<ul>
<li><strong>临界区</strong>:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。（在一段时间内只允许一个线程访问的资源就称为临界资源）。</li>
<li><strong>互斥量</strong>:为协调共同对一个共享资源的单独访问而设计的。</li>
<li><strong>信号量</strong>:为控制一个具有有限数量用户资源而设计。</li>
<li><strong>事件</strong>:用来通知线程有一些事件已发生，从而启动后继任务的开始。</li>
</ul>
<p><code>上下文切换（Context switch）</code></p>
<p>上下文切换是指CPU(中央处理单元)从一个进程或线程到另一个进程或线程的切换。</p>
<p>上下文切换可以更详细地描述为内核(即操作系统的核心)对CPU上的进程(包括线程)执行以下活动:</p>
<ol>
<li>暂停一个进程的处理，并将该进程的CPU状态(即上下文)存储在内存中的某个地方</li>
<li>从内存中获取下一个进程的上下文，并在CPU的寄存器中恢复它</li>
<li>返回到程序计数器指示的位置(即返回到进程被中断的代码行)以恢复进程。</li>
</ol>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26506.png" alt="img"></p>
<p>上下文切换具有以下特性：</p>
<p><strong>上下文切换只能在内核模式下发生</strong>。内核模式是CPU的特权模式，其中只有内核运行，并提供对所有内存位置和所有其他系统资源的访问。其他程序(包括应用程序)最初在用户模式下运行，但它们可以通过系统调用运行部分内核代码。</p>
<p><a href="http://note.youdao.com/noteshare?id=a12216347600326ac714d4539db03585&sub=F8CDC14DC2424449A322F98B0182974E">内核模式（Kernel Mode）vs 用户模式（User Mode）</a></p>
<p><strong>上下文切换是多任务操作系统的一个基本特性</strong>。在多任务操作系统中，多个进程似乎同时在一个CPU上执行，彼此之间互不干扰。这种并发的错觉是通过快速连续发生的上下文切换(每秒数十次或数百次)来实现的。这些上下文切换发生的原因是进程自愿放弃它们在CPU中的时间，或者是调度器在进程耗尽其CPU时间片时进行切换的结果。</p>
<p><strong>上下文切换通常是计算密集型的</strong>。就CPU时间而言，上下文切换对系统来说是一个巨大的成本，实际上，它可能是操作系统上成本最高的操作。因此，操作系统设计中的一个主要焦点是尽可能地避免不必要的上下文切换。与其他操作系统(包括一些其他类unix系统)相比，Linux的众多优势之一是它的上下文切换和模式切换成本极低。</p>
<p><strong>通过命令查看CPU上下文切换情况</strong>：</p>
<p>linux系统可以通过命令统计CPU上下文切换数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmstat 1 （#可以看到整个操作系统每1秒CPU上下文切换的统计 ）</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26504.png" alt="img"></p>
<p>其中cs列就是CPU上下文切换的统计。当然，CPU上下文切换不等价于线程切换，很多操作会造成CPU上下文切换：</p>
<ul>
<li>线程、进程切换</li>
<li>系统调用</li>
<li>中断</li>
</ul>
<p><strong>查看某一个线程\进程的上下文切换</strong></p>
<ul>
<li> 1、<strong>使用pidstat命令</strong></li>
</ul>
<p>常用的参数：</p>
<p>-u 默认参数，显示各个进程的 CPU 统计信息</p>
<p>-r 显示各个进程的内存使用情况</p>
<p>-d 显示各个进程的 IO 使用</p>
<p>-w 显示各个进程的上下文切换</p>
<p>-p PID 指定 PID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示进程5598每一秒的切换情况</span><br><span class="line">pidstat -w -p 5598 1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26507.png" alt="img"></p>
<p>其中cswch表示主动切换，nvcswch表示被动切换。从统计数据中看到，该进程每秒主动切换次数达到将近500次，因此代码中存在大量的 睡眠\唤醒 操作。</p>
<ul>
<li>2、<strong>从进程的状态信息中查看</strong></li>
</ul>
<p>通过命令 cat /proc/5598/status 查看进程的状态信息</p>
<p>voluntary_ctxt_switches: 40469351</p>
<p>nonvoluntary_ctxt_switches: 2268</p>
<p>这2项就是该进程从启动到当前总的上下文切换情况。</p>
<p><code>操作系统层面线程生命周期</code></p>
<p>操作系统层面的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。</p>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26575.png" alt="img"></p>
<ol>
<li>初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li>
<li>可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</li>
<li>当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了运行状态。</li>
<li>运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li>
<li>线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</li>
</ol>
<p>这五种状态在不同编程语言里会有简化合并。例如，C 语言的 POSIX Threads 规范，就把初始状态和可运行状态合并了；Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。</p>
<p><strong>查看进程线程的方法</strong></p>
<table>
<thead>
<tr>
<th>环境</th>
<th align="left">查看进程的方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>windows</strong></td>
<td align="left">任务管理器可以查看进程和线程数，也可以用来杀死进程  <br>tasklist 查看进程 <br>taskkill 杀死进程</td>
</tr>
<tr>
<td><strong>linux</strong></td>
<td align="left">ps -fe 查看所有进程<br>ps -fT -p <PID> 查看某个进程（PID）的所有线程 <br>kill 杀死进程 <br>top 按大写 H 切换是否显示线程<br>top -H -p <PID> 查看某个进程（PID）的所有线程</PID></PID></td>
</tr>
<tr>
<td><strong>Java</strong></td>
<td align="left">jps 命令查看所有 Java 进程 <br>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态 <br>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</PID></td>
</tr>
</tbody></table>
<p> <strong>Linux系统中线程实现方式</strong></p>
<ul>
<li>LinuxThreads       linux/glibc包在2.3.2之前只实现了LinuxThreads</li>
<li>NPTL(Native POSIX Thread Library)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以通过以下命令查看系统是使用哪种线程实现 </span><br><span class="line">getconf GNU_LIBPTHREAD_VERSION </span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26557.png" alt="img"></p>
<h3 id="2、Java线程详解"><a href="#2、Java线程详解" class="headerlink" title="2、Java线程详解"></a>2、Java线程详解</h3><p><code> Java线程的实现方式</code></p>
<ul>
<li><p><strong>方式1：使用 Thread类或继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式2：实现 Runnable 接口配合Thread</strong></p>
<p>把【线程】和【任务】（要执行的代码）分开</p>
<ul>
<li>Thread 代表线程</li>
<li>Runnable 可运行的任务（线程要执行的代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式3：使用有返回值的 Callable</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> CallableTask());</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式4：使用 lambda</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结：</strong>本质上Java中实现线程只有一种方式【执行任务的方式有很多种】，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p>
<p><code>Java线程实现原理</code></p>
<p><strong>思考</strong>：Java线程执行为什么不能直接调用run()方法,而要调用start()方法？</p>
<p>调用start()方法底层操作系统会创建线程，Java Thread-&gt;Jvm Thread-&gt;os Thread   Jvm Thread 到os Thread之间会有用户态到内核态的切换，java层面的线程对象会和内核态线程建立绑定关系；</p>
<p>调用run()方法只是普通的方法调用。</p>
<p><strong>两种线程</strong></p>
<ul>
<li><p><strong>内核级线程（Kernel Level Thread ，KLT</strong>）：它们是依赖于内核的，即无论是用户进程中的线程，还是系统进程中的线程，它们的创建、撤消、切换都由内核实现。</p>
</li>
<li><p><strong>用户级线程（User Level Thread，ULT）</strong>：操作系统内核不知道应用线程的存在。</p>
</li>
</ul>
<p><strong>Java线程属于内核级线程</strong></p>
<p><strong>Java中的协程框架：</strong> kilim  quasar</p>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26621.png" alt="img"></p>
<p><strong>协程：</strong>英文Coroutines, 是一种基于线程之上，但又比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），具有对内核来说不可见的特性。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/29203.png" alt="img"></p>
<h3 id="3、Java线程的调度机制"><a href="#3、Java线程的调度机制" class="headerlink" title="3、Java线程的调度机制"></a>3、Java线程的调度机制</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式分两种，分别是协同式线程调度和抢占式线程调度</p>
<ul>
<li><strong>协同式线程调度</strong></li>
</ul>
<p><strong>线程执行时间由线程本身来控制</strong>，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。</p>
<ul>
<li><strong>抢占式线程调度</strong></li>
</ul>
<p><strong>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定</strong>（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。</p>
<ul>
<li><strong>Java线程调度就是抢占式调度</strong></li>
</ul>
<p>希望系统能给某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。Java语言一共10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。但优先级并不是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。</p>
<h3 id="4、Java线程的生命周期"><a href="#4、Java线程的生命周期" class="headerlink" title="4、Java线程的生命周期"></a>4、Java线程的生命周期</h3><p>Java 语言中线程共有六种状态，分别是：</p>
<ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行状态+运行状态）</li>
<li>BLOCKED（阻塞状态、只针对synchorinzed）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>
<p>在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/26544.png" alt="img"></p>
<p><strong>从JavaThread的角度，JVM定义了一些针对Java Thread对象的状态（jvm.h）</strong></p>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/27079.png" alt="img"></p>
<p><strong>从OSThread的角度，JVM还定义了一些线程状态给外部使用，比如用jstack输出的线程堆栈信息中线程的状态（osThread.hpp）</strong></p>
<p><img src="/2022/04/29/01-00-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/27086.png" alt="img"></p>
<h3 id="5、Thread常用方法"><a href="#5、Thread常用方法" class="headerlink" title="5、Thread常用方法"></a>5、<strong>Thread常用方法</strong></h3><p><strong>sleep方法</strong></p>
<ul>
<li>调用 sleep 会让当前线程从 <em>Running</em> 进入TIMED_WAITING状态，不会释放对象锁</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException，并且会清除中断标志</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>sleep当传入参数为0时，和yield相同</li>
</ul>
<p><strong>yield方法</strong></p>
<ul>
<li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li>
<li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ul>
<p><strong>join方法</strong>    </p>
<p>等待调用join方法的线程结束之后，程序再继续执行，一般用于等待异步线程执行完结果之后才能继续运行的场景。</p>
<p><strong>stop方法</strong></p>
<p>stop()方法已经被jdk废弃，原因就是stop()方法太过于暴力，强行把执行到一半的线程终止。</p>
<h3 id="6、Java线程的中断机制"><a href="#6、Java线程的中断机制" class="headerlink" title="6、Java线程的中断机制"></a>6、<strong>Java线程的中断机制</strong></h3><p>Java没有提供一种安全、直接的方法来停止某个线程，而是提供了中断机制。中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理。被中断的线程拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。</p>
<p><strong>API的使用</strong></p>
<ul>
<li>interrupt()： 将线程的中断标志位设置为true，不会停止线程</li>
<li>isInterrupted(): 判断当前线程的中断标志位是否为true，不会清除中断标志位</li>
<li>Thread.interrupted()：判断当前线程的中断标志位是否为true，并清除中断标志位，重置为fasle</li>
</ul>
<p>Thread.sleep()能够响应中断，并清除中断标志位。</p>
<p><strong>sleep 期间能否感受到中断</strong></p>
<p>修改上面的代码，线程执行任务期间有休眠需求</p>
<p>处于休眠中的线程被中断，线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。这样就会导致while条件Thread.currentThread().isInterrupted()为false，程序会在不满足count &lt; 1000这个条件时退出。如果不在catch中重新手动添加中断信号，不做任何处理，就会屏蔽中断请求，有可能导致线程无法正确停止。</p>
<h3 id="7、Java线程间通信"><a href="#7、Java线程间通信" class="headerlink" title="7、Java线程间通信"></a>7、<strong>Java线程间通信</strong></h3><ul>
<li><strong>volatile</strong></li>
</ul>
<p>volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。</p>
<ul>
<li><strong>等待唤醒(等待通知)机制</strong></li>
</ul>
<p>等待唤醒机制可以基于wait和notify方法来实现，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被唤醒。</p>
<p>LockSupport是JDK中用来实现线程阻塞和唤醒的工具，线程调用park则等待“许可”，调用unpark则为指定线程提供“许可”。使用它可以在任何场合使线程阻塞，可以指定任何线程进行唤醒，并且不用担心阻塞和唤醒操作的顺序，但要注意连续多次唤醒的效果和一次唤醒是一样的。</p>
<ul>
<li><strong>管道输入输出流</strong></li>
</ul>
<p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<ul>
<li><strong>Thread.join</strong></li>
</ul>
<p>join可以理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JMM</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发锁机制之深入理解synchronized</title>
    <url>/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="并发锁机制之深入理解synchronized"><a href="#并发锁机制之深入理解synchronized" class="headerlink" title="并发锁机制之深入理解synchronized"></a>并发锁机制之深入理解synchronized</h2><h3 id="1、Java共享内存模型带来的线程安全问题"><a href="#1、Java共享内存模型带来的线程安全问题" class="headerlink" title="1、Java共享内存模型带来的线程安全问题"></a>1、Java共享内存模型带来的线程安全问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思考： counter=？</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>思考： 两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>
<p>不是，变量++和–不是原子操作，现在执行会存在指令切换</p>
<h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><p>i++和i–对应的字节码指令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i++:</span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值 </span></span><br><span class="line">iconst_1 <span class="comment">// 将int常量1压入操作数栈</span></span><br><span class="line">iadd <span class="comment">// 自增 </span></span><br><span class="line"></span><br><span class="line">i--:</span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值 </span></span><br><span class="line">iconst_1 <span class="comment">// 将int常量1压入操作数栈</span></span><br><span class="line">isub <span class="comment">// 自减 </span></span><br></pre></td></tr></table></figure>

<p>执行情况如下图：</p>
<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501230026131.png" alt="image-20220501230026131"></p>
<p>可能出现：距离，比如i初始等于5，线程2执行i–，值变为4，但是还没有写回主内存，线程1执行了i++,值变为6，并且写入了主内存，主内存值为6；然后线程2在将值写回主内存，这个时候就覆盖了线程1的值，此时主内存的值为4。</p>
<h4 id="临界区（-Critical-Section）"><a href="#临界区（-Critical-Section）" class="headerlink" title="临界区（ Critical Section）"></a>临界区（ Critical Section）</h4><ul>
<li><p>一个程序运行多个线程本身是没有问题的</p>
</li>
<li><p>问题出在多个线程访问共享资源 </p>
</li>
<li><ul>
<li><ul>
<li>多个线程读共享资源其实也没有问题 </li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区，其共享资源为临界资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//临界资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="comment">//临界区</span></span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;<span class="comment">//临界区</span></span><br><span class="line">    counter--;</span><br></pre></td></tr></table></figure>

<h4 id="竞态条件（-Race-Condition-）"><a href="#竞态条件（-Race-Condition-）" class="headerlink" title="竞态条件（ Race Condition ）"></a>竞态条件（ Race Condition ）</h4><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock </li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p><strong>注意：</strong></p>
<p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： </p>
<ul>
<li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 </p>
</li>
<li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p>
</li>
</ul>
<h3 id="2、synchronized的使用"><a href="#2、synchronized的使用" class="headerlink" title="2、synchronized的使用"></a>2、synchronized的使用</h3><table>
<thead>
<tr>
<th>分类</th>
<th>具体方法</th>
<th>被锁对象</th>
</tr>
</thead>
<tbody><tr>
<td>方法</td>
<td>实例方法</td>
<td>类的实例对象</td>
</tr>
<tr>
<td></td>
<td>静态方法</td>
<td>类对象</td>
</tr>
<tr>
<td>代码块</td>
<td>实例对象</td>
<td>类的实例对象</td>
</tr>
<tr>
<td></td>
<td>class对象</td>
<td>类对象</td>
</tr>
<tr>
<td></td>
<td>任意实例对象Object</td>
<td>实例对象Object</td>
</tr>
</tbody></table>
<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501231055583.png"></p>
<p>synchronized 实际是用对象锁保证了临界区内代码的原子性</p>
<h3 id="3、synchronized底层原理"><a href="#3、synchronized底层原理" class="headerlink" title="3、synchronized底层原理"></a>3、synchronized底层原理</h3><p>​        synchronized是JVM内置锁，基于<strong>Monitor</strong>机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、自适应自旋（Adaptive Spinning）等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。</p>
<p>​        Java虚拟机通过一个同步结构支持方法和方法中的指令序列的同步：monitor。</p>
<p>同步方法是通过方法中的access_flags中设置ACC_SYNCHRONIZED标志来实现；同步代码块是通过monitorenter和monitorexit来实现。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
<h4 id="Monitor（管程-监视器）"><a href="#Monitor（管程-监视器）" class="headerlink" title="Monitor（管程/监视器）"></a>Monitor（管程/监视器）</h4><p>Monitor，直译为“监视器”，而操作系统领域一般翻译为“管程”。管程是指管理共享变量以及对共享变量操作的过程，让它们支持并发。在Java 1.5之前，Java语言提供的唯一并发语言就是管程，Java 1.5之后提供的SDK并发包也是以管程为基础的。除了Java之外，C/C++、C#等高级语言也都是支持管程的。synchronized关键字和wait()、notify()、notifyAll()这三个方法是Java中实现管程技术的组成部分。</p>
<h4 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h4><p>在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模型。现在正在广泛使用的是MESA模型。下面我们便介绍MESA模型：</p>
<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501231313735.png"></p>
<p>管程中引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。条件变量和等待队列的作用是解决线程之间的同步问题。</p>
<p><strong>wait()的正确使用姿势</strong></p>
<p>对于MESA管程来说，有一个编程范式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">  wait();</span><br></pre></td></tr></table></figure>

<p>唤醒的时间和获取到锁继续执行的时间是不一致的，被唤醒的线程再次执行时可能条件又不满足了，所以循环检验条件。MESA模型的wait()方法还有一个超时参数，为了避免线程进入等待队列永久阻塞。</p>
<p><strong>notify()和notifyAll()分别何时使用</strong></p>
<p>满足以下三个条件时，可以使用notify()，其余情况尽量使用notifyAll()：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
<h4 id="Java语言的内置管程synchronized"><a href="#Java语言的内置管程synchronized" class="headerlink" title="Java语言的内置管程synchronized"></a>Java语言的内置管程synchronized</h4><p>​        Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。模型如下图所示。</p>
<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501231459351.png" alt="image-20220501231459351"></p>
<p><strong>Monitor机制在Java中的实现</strong></p>
<p>​        java.lang.Object 类定义了 wait()，notify()，notifyAll() 方法，这些方法的具体实现，依赖于 ObjectMonitor 实现，这是 JVM 内部基于 C++ 实现的一套机制。</p>
<p>ObjectMonitor其主要数据结构如下（hotspot源码ObjectMonitor.hpp）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL; <span class="comment">//对象头  markOop</span></span><br><span class="line">    _count        = <span class="number">0</span>;  </span><br><span class="line">    _waiters      = <span class="number">0</span>,   </span><br><span class="line">    _recursions   = <span class="number">0</span>;   <span class="comment">// 锁的重入次数 </span></span><br><span class="line">    _object       = NULL;  <span class="comment">//存储锁对象</span></span><br><span class="line">    _owner        = NULL;  <span class="comment">// 标识拥有该monitor的线程（当前获取锁的线程） </span></span><br><span class="line">    _WaitSet      = NULL;  <span class="comment">// 等待线程（调用wait）组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;    </span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ; <span class="comment">// 入口等待队列 多线程竞争锁会先存到这个单向链表中 （FILO栈结构  先进后出 说明是非公平的）</span></span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//存放在进入或重新进入时被阻塞(blocked)的线程 (也是存竞争锁失败的线程) 存放之前wait 后被唤醒的线程，优先唤醒	</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501231531966.png"></p>
<p>在获取锁时，是将当前线程插入到cxq的头部，而释放锁时，默认策略（QMode=0）是：如果EntryList为空，则将cxq中的元素按原有顺序插入到EntryList，并唤醒第一个线程，也就是当EntryList为空时，是后来的线程先获取锁。_EntryList不为空，直接从_EntryList中唤醒线程。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncQModeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SyncQModeDemo demo = <span class="keyword">new</span> SyncQModeDemo();</span><br><span class="line"></span><br><span class="line">        demo.startThreadA();</span><br><span class="line">        <span class="comment">//控制线程执行时间</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        demo.startThreadB();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        demo.startThreadC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;A get lock&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    Thread.sleep(300);</span></span><br><span class="line">                    lock.wait(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;A release lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;B get lock&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;B release lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line">                log.debug(<span class="string">&quot;C get lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">结果<span class="number">1</span>、【执行<span class="number">24</span>行代码 lock.wait(<span class="number">300</span>); 时】：</span><br><span class="line"><span class="number">14</span>:<span class="number">29</span>:<span class="number">21.065</span> [thread-A] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - A get lock</span><br><span class="line"><span class="number">14</span>:<span class="number">29</span>:<span class="number">21.164</span> [thread-B] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - B get lock</span><br><span class="line"><span class="number">14</span>:<span class="number">29</span>:<span class="number">21.664</span> [thread-B] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - B release lock</span><br><span class="line"><span class="number">14</span>:<span class="number">29</span>:<span class="number">21.664</span> [thread-A] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - A release lock</span><br><span class="line"><span class="number">14</span>:<span class="number">29</span>:<span class="number">21.664</span> [thread-C] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - C get lock</span><br><span class="line">分析：</span><br><span class="line">首先线程A获得锁，然后线程A调用wait()方法，进入_waitSet()</span><br><span class="line">然后线程B竞争锁，获取锁，释放锁</span><br><span class="line">线程A唤醒时会被放入EntryList，线程C获取锁会被放入cxq队列</span><br><span class="line">根据上述默认策略，EntryList不为空，放入EntryList的会先被唤醒，因此A先唤醒，C后唤醒</span><br><span class="line"></span><br><span class="line">为什么是这个结果？</span><br><span class="line">自己的思考：因为执行wait()方法而释放锁进入waitSet中的线程，因为之前以及获得过锁，所以唤醒时优先唤醒这种线程，从设计的角度看，这种更合理</span><br><span class="line"></span><br><span class="line">结果<span class="number">2</span>、【执行<span class="number">23</span>行代码 Thread.sleep(<span class="number">300</span>); 时】：</span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">27.810</span> [thread-A] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - A get lock</span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">28.113</span> [thread-A] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - A release lock</span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">28.113</span> [thread-C] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - C get lock</span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">28.113</span> [thread-B] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - B get lock</span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">28.613</span> [thread-B] DEBUG com.tuling.jucdemo.sync.SyncQModeDemo - B release lock</span><br><span class="line">分析：</span><br><span class="line">当三个线程都竞争锁时，线程A先获取锁，线程B、线程C会依次进入cxq队列，EntryList为空，所以会复制cxq数据进入EntryList，根据后进先出，C会先被唤醒</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong>synchronized加锁加在对象上，锁对象是如何记录锁状态的？锁状态会被记录到锁的对象头markword中</p>
<p>new Object()在内存中占几个字节？占16个字节，分析如下：8个markword+4个Klass+4个对齐填充位</p>
<h3 id="4、对象的内存布局"><a href="#4、对象的内存布局" class="headerlink" title="4、对象的内存布局"></a>4、对象的内存布局</h3><p>Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<ul>
<li><p>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。</p>
</li>
<li><p>实例数据：存放类的属性数据信息，包括父类的属性信息；</p>
</li>
<li><p>对齐填充：由于虚拟机要求 <strong>对象起始地址必须是8字节的整数倍</strong>。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p> <img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501231816899.png"></p>
</li>
</ul>
<p>Mark word:8个字节</p>
<p>元数据指针:64位压缩成32为，占4个字节，32位占4个字节</p>
<p>数组长度：如果是数组类型，占4个字节</p>
<h4 id="对象头详解"><a href="#对象头详解" class="headerlink" title="对象头详解"></a>对象头详解</h4><p>HotSpot虚拟机的对象头包括：</p>
<ul>
<li>Mark Word </li>
</ul>
<p>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳【跟批量重偏向，批量撤销有关】等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。</p>
<ul>
<li> Klass Pointer</li>
</ul>
<p>对象指向的类元数据</p>
<p>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 32位4字节，64位开启指针压缩或最大堆内存&lt;32g时4字节，否则8字节。jdk1.8默认开启指针压缩后为4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。</p>
<ul>
<li>数组长度（只有数组对象有）</li>
</ul>
<p>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度。 4字节</p>
<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501231825472.png"></p>
<h4 id="Mark-Word是如何记录锁状态的"><a href="#Mark-Word是如何记录锁状态的" class="headerlink" title="Mark Word是如何记录锁状态的"></a>Mark Word是如何记录锁状态的</h4><p>Hotspot通过markOop类型实现Mark Word，具体实现位于markOop.hpp文件中。由于对象需要存储的运行时数据很多，考虑到虚拟机的内存使用，markOop被设计成一个非固定的数据结构，以便在极小的空间存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>
<p>简单点理解就是：MarkWord 结构搞得这么复杂，是因为需要节省内存，让同一个内存区域在不同阶段有不同的用处。</p>
<p><strong>Mark Word的结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br><span class="line"></span><br><span class="line">。。。。。。</span><br><span class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></span><br><span class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></span><br><span class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></span><br><span class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></span><br><span class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hash： 保存对象的哈希码。运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。</li>
<li>age： 保存对象的分代年龄。表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li>
<li>biased_lock： 偏向锁标识位。由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。</li>
<li>lock： 锁状态标识位。区分锁状态，比如11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。</li>
<li>JavaThread*： 保存持有偏向锁的线程ID。偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。这个线程ID并不是JVM分配的线程ID号，和Java Thread中的ID是两个概念。</li>
<li>epoch： 保存偏向时间戳。偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li>
</ul>
<p><strong>32位JVM下的对象结构描述</strong></p>
<p>​    <img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501232241221.png" alt="image-20220501232241221"></p>
<p><strong>64位JVM下的对象结构描述</strong></p>
<p>​    <img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501232246816.png" alt="image-20220501232246816"></p>
<ul>
<li>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争时，JVM使用原子操作而不是OS互斥，这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的Mark Word中设置指向锁记录的指针。</li>
<li>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针</li>
</ul>
<h4 id="Mark-Word中锁标记枚举"><a href="#Mark-Word中锁标记枚举" class="headerlink" title="Mark Word中锁标记枚举"></a>Mark Word中锁标记枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123; locked_value             = <span class="number">0</span>,    <span class="comment">//00 轻量级锁 </span></span><br><span class="line">         unlocked_value           = <span class="number">1</span>,   <span class="comment">//001 无锁</span></span><br><span class="line">         monitor_value            = <span class="number">2</span>,   <span class="comment">//10 监视器锁，也叫膨胀锁，也叫重量级锁</span></span><br><span class="line">         marked_value             = <span class="number">3</span>,   <span class="comment">//11 GC标记</span></span><br><span class="line">         biased_lock_pattern      = <span class="number">5</span>    <span class="comment">//101 偏向锁</span></span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501232732433.png"></p>
<h3 id="5、synchronized底层的锁"><a href="#5、synchronized底层的锁" class="headerlink" title="5、synchronized底层的锁"></a>5、synchronized底层的锁</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁加锁解锁不会做任何事情，解锁之后还是偏向锁</p>
<p>偏向锁是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了消除数据在无竞争情况下锁重入（CAS操作）的开销而引入偏向锁。对于没有锁竞争的场合，偏向锁有很好的优化效果。</p>
<p>详细介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	偏向锁是Java <span class="number">6</span>之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</span><br><span class="line">默认开启偏向锁</span><br><span class="line">开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br><span class="line">关闭偏向锁：-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***StringBuffer内部同步***/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> count; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//System.out.println 无意识的使用锁 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     print(x); newLine(); </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>当JVM启用了偏向锁模式（jdk6默认开启），新创建对象的Mark Word中的Thread Id为0，说明此时处于可偏向但未偏向任何线程，也叫做匿名偏向状态(anonymously biased)。</p>
<p><strong>偏向锁延迟偏向</strong></p>
<p>​        偏向锁模式存在偏向锁延迟机制：HotSpot 虚拟机在启动后有个 4s 的延迟才会对之后每个新建的对象开启偏向锁模式。JVM启动时会进行一系列的复杂活动，比如装载配置，系统类初始化等等。在这个过程中会使用大量synchronized关键字对对象加锁，且这些锁大多数都不是偏向锁。为了减少初始化时间，JVM默认延时加载偏向锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭延迟开启偏向锁</span></span><br><span class="line">-XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br><span class="line"><span class="comment">//禁止偏向锁</span></span><br><span class="line">-XX:-UseBiasedLocking </span><br><span class="line"><span class="comment">//启用偏向锁</span></span><br></pre></td></tr></table></figure>

<p><strong>偏向锁撤销之调用对象HashCode</strong></p>
<p>偏向锁撤销是会在安全点撤销（同GC中的安全点）</p>
<p>偏向锁撤销可能会变成：1、无锁状态2、轻量级锁3、重量级锁【具体看锁升级图】</p>
<p>调用锁对象的obj.hashCode()或System.identityHashCode(obj)方法会导致该对象的偏向锁被撤销。因为对于一个对象，其HashCode只会生成一次并保存，偏向锁是没有地方保存hashcode的。</p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode </li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
<p>当对象处于可偏向（也就是线程ID为0）和已偏向的状态下，调用HashCode计算将会使对象再也无法偏向：</p>
<ul>
<li>当对象可偏向时，MarkWord将变成未锁定状态，并只能升级成轻量锁；</li>
<li>当对象正处于偏向锁时，调用HashCode将使偏向锁强制升级成重量锁。</li>
</ul>
<p><strong>偏向锁撤销之调用wait/notify</strong></p>
<p> 偏向锁状态执行obj.notify() 会升级为轻量级锁，调用obj.wait(timeout) 会升级为重量级锁</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<h4 id="总结：锁对象状态转换"><a href="#总结：锁对象状态转换" class="headerlink" title="总结：锁对象状态转换"></a>总结：锁对象状态转换</h4><p><img src="/2022/05/01/01-00-04-%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/image-20220501233349943.png"></p>
<p>偏向锁撤销需要到达安全点才能撤销，撤销之后变为无锁才能升级位轻量级锁</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列BlockingQueue</title>
    <url>/2022/05/08/01-00-11-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><h3 id="1、阻塞队列顶层父类Queue接口"><a href="#1、阻塞队列顶层父类Queue接口" class="headerlink" title="1、阻塞队列顶层父类Queue接口"></a>1、阻塞队列顶层父类Queue接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常 底层调用 offer()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//添加一个元素，添加成功返回true, 如果队列满了，返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//返回并删除队首元素，队列为空则抛出异常</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回并删除队首元素，队列为空则返回null</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回队首元素，但不移除，队列为空则抛出异常</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取队首元素，但不移除，队列为空则返回null</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、BlockingQueue"><a href="#2、BlockingQueue" class="headerlink" title="2、BlockingQueue"></a>2、BlockingQueue</h3><p>BlockingQueue例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        addTest();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add 方法是往队列里添加一个元素，如果队列满了，就会抛出异常来提示队列已满。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">1</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * remove 方法的作用是删除元素并返回队列的头节点，如果删除的队列是空的， remove 方法就会抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.add(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * element 方法是返回队列的头部节点，但是并不删除。如果队列为空，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">elementTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.element();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * offer 方法用来插入一个元素。如果添加成功会返回 true，而如果队列已经满了，返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">offerTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">1</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * poll 方法作用也是移除并返回队列的头节点。 如果队列为空，返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pollTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.offer(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * peek 方法返回队列的头元素但并不删除。 如果队列为空，返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peekTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        System.out.println(blockingQueue.peek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * put 方法的作用是插入元素。如果队列已满就无法继续插入,阻塞插入线程，直至队列空出位置 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">            blockingQueue.put(<span class="number">2</span>);</span><br><span class="line">            blockingQueue.put(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * take 方法的作用是获取并移除队列的头结点。如果执队列里无数据，则阻塞，直到队列里有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java 5 中加入的。阻塞队列（BlockingQueue）是一个在队列基础上又支持了两个附加操作的队列，常用解耦。两个附加操作:</p>
<ul>
<li>支持阻塞的插入方法put: 队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法take: 队列空时，获取元素的线程会等待队列变为非空</li>
</ul>
<p>BlockingQueue和JDK集合包中的Queue接口兼容，同时在其基础上增加了阻塞功能。</p>
<p><strong>入队：</strong></p>
<p>（1）offer(E e)：如果队列没满，返回true，如果队列已满，返回false（不阻塞）</p>
<p>（2）offer(E e, long timeout, TimeUnit unit)：可以设置阻塞时间，如果队列已满，则进行阻塞。超过阻塞时间，则返回false</p>
<p>（3）put(E e)：队列没满的时候是正常的插入，如果队列已满，则阻塞，直至队列空出位置 </p>
<p><strong>出队：</strong></p>
<p>（1）poll()：如果有数据，出队，如果没有数据，返回null   （不阻塞）</p>
<p>（2）poll(long timeout, TimeUnit unit)：可以设置阻塞时间，如果没有数据，则阻塞，超过阻塞时间，则返回null</p>
<p>（3）take()：队列里有数据会正常取出数据并删除；但是如果队列里无数据，则阻塞，直到队列里有数据</p>
<p><strong>BlockingQueue常用方法示例</strong></p>
<p>当队列满了无法添加元素，或者是队列空了无法移除元素时：</p>
<ol>
<li>抛出异常：add、remove、element</li>
<li>返回结果但不抛出异常：offer、poll、peek</li>
<li>阻塞：put、take</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>抛出异常</th>
<th>返回特定值</th>
<th>阻塞</th>
<th>阻塞特定时间</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>出队</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>获取队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>不支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<pre><code>   ### 3、ArrayBlockingQueue的使用
</code></pre>
<p><code>基本数据结构</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下一个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下一个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair); <span class="comment">//公平，非公平</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>入队put方法【入队关键方法】</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">//检查是否为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁，如果线程中断抛出异常 </span></span><br><span class="line">    lock.lockInterruptibly();  <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//阻塞队列已满，则将生产者挂起，等待消费者唤醒</span></span><br><span class="line">       <span class="comment">//设计注意点： 用while不用if是为了防止虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await(); <span class="comment">//队列满了，使用notFull等待（生产者阻塞）</span></span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 唤醒消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//入队   使用的putIndex</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) </span><br><span class="line">        putIndex = <span class="number">0</span>;  <span class="comment">//设计的精髓： 环形数组，putIndex指针到数组尽头了，返回头部</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//notEmpty条件队列转同步队列，准备唤醒消费者线程，因为入队了一个元素，肯定不为空了</span></span><br><span class="line">    notEmpty.signal(); <span class="comment">// 条件队列转同步队列</span></span><br><span class="line">&#125;</span><br><span class="line">思考：入队代码为什么设计成环形数组</span><br><span class="line">非环形数组删除数据时间复杂度为O(N),设计成环形数组时间复杂度为O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code><strong>出队take方法</strong></code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">// 和插入操作是同一把锁，因此高并发下，性能不太行</span></span><br><span class="line">    <span class="comment">//加锁，如果线程中断抛出异常 </span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//如果队列为空，则消费者挂起</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 唤醒生产者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex]; <span class="comment">//取出takeIndex位置的元素</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>; <span class="comment">//设计的精髓： 环形数组，takeIndex 指针到数组尽头了，返回头部</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">//notFull条件队列转同步队列，准备唤醒生产者线程，此时队列有空位</span></span><br><span class="line">    notFull.signal(); <span class="comment">// 唤醒之前因为队列满而阻塞的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考： 为什么对数组操作要设计成双指针？</p>
<p>普通数组删除元素时间复杂度O(N)，环形数组删除元素时间复杂度O(1)</p>
<h3 id="4、LinkedBlockingQueue的使用"><a href="#4、LinkedBlockingQueue的使用" class="headerlink" title="4、LinkedBlockingQueue的使用"></a>4、<strong>LinkedBlockingQueue</strong>的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定队列的大小创建有界队列</span></span><br><span class="line">BlockingQueue&lt;Integer&gt; boundedQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//无界队列 也不是真正的无解 最大为Integer.MAX_VALUE</span></span><br><span class="line">BlockingQueue&lt;Integer&gt; unboundedQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>



<p><code>LinkedBlockingQueue数据结构</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 容量,指定容量就是有界队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">// 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 链表头  本身是不存储任何元素的，初始化时item指向null</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="comment">// 链表尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">// take锁   锁分离，提高效率</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// notEmpty条件</span></span><br><span class="line"><span class="comment">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="comment">// put锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// notFull条件</span></span><br><span class="line"><span class="comment">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//典型的单链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;  <span class="comment">//存储元素</span></span><br><span class="line">    Node&lt;E&gt; next;  <span class="comment">//后继节点    单链表结构</span></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没传容量，就使用最大int值初始化其容量</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 初始化head和last指针为空值节点</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>入队put方法 (从尾部入队)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    </span><br><span class="line">    <span class="comment">// 不允许null元素</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新建一个节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 使用put锁加锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列满了，就阻塞在notFull上等待被其它线程唤醒（阻塞生产者线程）</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 队列不满，就入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();<span class="comment">// 队列长度加1，返回原值</span></span><br><span class="line">        <span class="comment">// 如果现队列长度小于容量，notFull条件队列转同步队列，准备唤醒一个阻塞在notFull条件上的线程(可以继续入队) </span></span><br><span class="line">        <span class="comment">// 这里为啥要唤醒一下呢？</span></span><br><span class="line">        <span class="comment">// 因为可能有很多线程阻塞在notFull这个条件上,而取元素时只有取之前队列是满的才会唤醒notFull,此处不用等到取元素时才唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 之前队列满了，可能有很多线程在阻塞，此时队列长度小于容量，唤醒那些之前因队列满而阻塞的线程，让其继续插入队列 提高吞吐量</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock(); <span class="comment">// 真正唤醒生产者线程</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果原队列长度为0，现在加了一个元素后立即唤醒阻塞在notEmpty上的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 直接加到last后面,last指向入队元素</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock; </span><br><span class="line">    takeLock.lock();<span class="comment">// 加take锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        notEmpty.signal();<span class="comment">// notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();  <span class="comment">// 真正唤醒消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>出队take方法 (从头部出队)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 使用takeLock加锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列无元素，则阻塞在notEmpty条件上（消费者线程阻塞）</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();<span class="comment">//长度-1，返回原值</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">// 如果取之前队列长度大于1，notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程，原因与入队同理</span></span><br><span class="line">            notEmpty.signal(); <span class="comment">// 队列里面有数据 则唤醒之前因为没有数据阻塞的线程，提高吞吐量</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 真正唤醒消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为什么队列是满的才唤醒阻塞在notFull上的线程呢？</span></span><br><span class="line">    <span class="comment">// 因为唤醒是需要加putLock的，这是为了减少锁的次数,所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程,</span></span><br><span class="line">    <span class="comment">// 这也是锁分离带来的代价</span></span><br><span class="line">    <span class="comment">// 如果取之前队列长度等于容量（已满），则唤醒阻塞在notFull的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成头节点出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// head节点本身是不存储任何元素的</span></span><br><span class="line">    <span class="comment">// 这里把head删除，并把head下一个节点作为新的值</span></span><br><span class="line">    <span class="comment">// 并把其值置空，返回原来的值</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// 方便GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();<span class="comment">// notFull条件队列转同步队列，准备唤醒阻塞在notFull上的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock(); <span class="comment">// 解锁，这才会真正的唤醒生产者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：线程池为什么用LinkedBlockingQueue而不用ArrayBlockingQueue?</p>
<p>LinkedBlockingQueue出队入队分别用不同的锁，性能相对来说会更高些；ArrayBlockingQueue 出队入队都是用的同一个锁（数据存取互斥），高并发下性能不是很好</p>
<h3 id="5、LinkedBlockingQueue与ArrayBlockingQueue对比"><a href="#5、LinkedBlockingQueue与ArrayBlockingQueue对比" class="headerlink" title="5、LinkedBlockingQueue与ArrayBlockingQueue对比"></a>5、LinkedBlockingQueue与ArrayBlockingQueue对比</h3><p>LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：</p>
<ul>
<li>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</li>
<li>数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</li>
<li>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。</li>
<li>两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li>
</ul>
<h3 id="6、BlockingQueue总结"><a href="#6、BlockingQueue总结" class="headerlink" title="6、BlockingQueue总结"></a>6、BlockingQueue总结</h3><p><strong>阻塞队列特性</strong></p>
<p><strong>阻塞</strong></p>
<p>阻塞队列区别于其他类型的队列的最主要的特点就是“阻塞”这两个字，所以下面重点介绍阻塞功能：阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。实现阻塞最重要的两个方法是 take 方法和 put 方法。</p>
<p><strong>take 方法</strong></p>
<p>take 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 take 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据</p>
<p><strong>put 方法</strong></p>
<p>put 方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到队列中</p>
<p><strong>是否有界</strong></p>
<p>阻塞队列还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如 LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。但是有的阻塞队列是有界的，例如 ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。</p>
<p><strong>应用场景</strong></p>
<p>线程池里面大量使用到，线程池是生产者-消费者模式、利用线程工厂做线程复用，阻塞队列是线程安全的，阻塞队列可以解耦，生产者只管往队列里面添加数据，消费者只管消费数据</p>
<p>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了。</p>
<p>因为阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的，不会发生线程安全问题。生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开发的难度和工作量。</p>
<p>同时，队列它还能起到一个隔离的作用。比如说我们开发一个银行转账的程序，那么生产者线程不需要关心具体的转账逻辑，只需要把转账任务，如账户和金额等信息放到队列中就可以，而不需要去关心银行这个类如何实现具体的转账业务。而作为银行这个类来讲，它会去从队列里取出来将要执行的具体的任务，再去通过自己的各种方法来完成本次转账。这样就实现了具体任务与执行任务类之间的解耦，任务被放在了阻塞队列中，而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的，实现了隔离，提高了安全性。</p>
<p><strong>常见阻塞队列</strong></p>
<p>BlockingQueue 接口的实现类都被放在了 juc 包中，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>
<table>
<thead>
<tr>
<th><strong>队列</strong></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>基于数组结构实现的一个有界阻塞队列</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>基于链表结构实现的一个有界阻塞队列</td>
</tr>
<tr>
<td><strong>PriorityBlockingQueue</strong></td>
<td>支持按优先级排序的无界阻塞队列，例如需要插队的场景</td>
</tr>
<tr>
<td><strong>DelayQueue</strong></td>
<td>基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列，延时队列</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>不存储元素的阻塞队列，一个生产者对应一个消费者</td>
</tr>
<tr>
<td><strong>LinkedTransferQueue</strong></td>
<td>基于链表结构实现的一个无界阻塞队列</td>
</tr>
<tr>
<td><strong>LinkedBlockingDeque</strong></td>
<td>基于链表结构实现的一个双端阻塞队列</td>
</tr>
</tbody></table>
<h3 id="7、锁活跃性问题"><a href="#7、锁活跃性问题" class="headerlink" title="7、锁活跃性问题"></a>7、锁活跃性问题</h3><p><strong>死锁与活锁的区别，死锁与饥饿的区别？</strong></p>
<p><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<p>Java 中导致饥饿的原因：</p>
<p>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>
<p>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p>
<p>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>BlockingQueue</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Future&amp;CompletableFuture&amp;Disruptor</title>
    <url>/2022/05/11/01-00-15-Future-CompletableFuture-Disruptor/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="1、Future"><a href="#1、Future" class="headerlink" title="1、Future"></a>1、Future</h2><p><code>Callable和Runnable的区别</code></p>
<p>Runnable 的缺陷：</p>
<ul>
<li>不能返回一个返回值</li>
<li>不能抛出 checked Exception</li>
</ul>
<p>Callable的call方法可以有返回值，可以声明抛出异常。和 Callable 配合的有一个 Future 类，通过 Future 可以了解任务执行情况，或者取消任务的执行，还可获取任务执行的结果，这些功能都是 Runnable 做不到的，Callable 的功能要比 Runnable 强大。</p>
<p>参考如下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过Runnable方式执行任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">FutureTask task = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过Callable方式执行任务&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;返回任务结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br></pre></td></tr></table></figure>

<p><code>Future 的主要功能</code></p>
<p><strong>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。****必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</strong></p>
<ul>
<li>boolean cancel (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束</li>
<li>boolean isCancelled () 任务是否已经取消，任务正常完成前将其取消，则返回 true</li>
<li>boolean isDone () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</li>
<li>V get () throws InterruptedException, ExecutionException  等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException</li>
<li>V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException</li>
</ul>
<p>future例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">//构建futureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">        <span class="comment">//作为Runnable入参</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;task运行结果：&quot;</span>+futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正在计算&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>future总结：</p>
<p><strong>Future 注意事项</strong></p>
<ul>
<li>当 for 循环批量获取 Future 的结果时容易 block，get 方法调用时应使用 timeout 限制</li>
<li>Future 的生命周期不能后退。一旦完成了任务，它就永久停在了“已完成”的状态，不能从头再来</li>
</ul>
<p>思考：  使用Callable 和Future 产生新的线程了吗？</p>
<p>没有产生线程，它是任务相关的 </p>
<p><strong>Future的局限性</strong></p>
<p>从本质上说，<strong>Future表示一个异步计算的结果</strong>。它提供了isDone()来检测计算是否已经完成，并且在计算结束后，可以通过get()方法来获取计算结果。在异步计算中，Future确实是个非常优秀的接口。但是，它的本身也确实存在着许多限制：</p>
<ul>
<li><strong>并发执行多任务</strong>：Future只提供了get()方法来获取结果，并且是阻塞的。所以，除了等待你别无他法；</li>
<li><strong>无法对多个任务进行链式调用</strong>：如果你希望在计算任务完成后执行特定动作，比如发邮件，但Future却没有提供这样的能力；</li>
<li><strong>无法组合多个任务</strong>：如果你运行了10个任务，并期望在它们全部执行结束后执行特定动作，那么在Future中这是无能为力的；</li>
<li><strong>没有异常处理</strong>：Future接口中没有关于异常处理的方法；</li>
</ul>
<p><code>CompletionService</code></p>
<p>Callable+Future 可以实现多个task并行执行，但是如果遇到前面的task执行较慢时需要阻塞等待前面的task执行完后面task才能取得结果。而CompletionService的主要功能就是一边生成任务,一边获取任务的返回值。让两件事分开执行,任务之间不会互相阻塞，可以实现先执行完的先取结果，不再依赖任务顺序了。</p>
<p><strong>CompletionService原理</strong></p>
<p>内部通过阻塞队列+FutureTask，实现了任务先完成可优先获取到，即结果按照完成先后顺序排序，内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，通过调用它的take方法或poll方法可以获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果</p>
<p>案例：</p>
<p><strong>询价应用：向不同电商平台询价，并保存价格</strong></p>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>采用“ThreadPoolExecutor+Future”的方案：异步执行询价然后再保存</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    创建线程池 </span></span><br><span class="line">ExecutorService    executor = Executors.newFixedThreadPool(<span class="number">3</span>); </span><br><span class="line"><span class="comment">//    异步向电商S1询价 </span></span><br><span class="line">Future&lt;Integer&gt;    f1 = executor.submit(()-&gt;getPriceByS1()); </span><br><span class="line"><span class="comment">//    异步向电商S2询价 </span></span><br><span class="line">Future&lt;Integer&gt;    f2=    executor.submit(()-&gt;getPriceByS2());             </span><br><span class="line"><span class="comment">//    获取电商S1报价并异步保存 </span></span><br><span class="line">executor.execute(()-&gt;save(f1.get()));        </span><br><span class="line"><span class="comment">//    获取电商S2报价并异步保存 </span></span><br><span class="line">executor.execute(()-&gt;save(f2.get())   </span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">如果获取电商S1报价的耗时很长，那么即便获取电商S2报价的耗时很短，也无法让保存S2报价的操作先执行，因为这个主线程都阻塞 在了f1.get()操作上。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用CompletionService实现先获取的报价先保存到数据库</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//创建CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"><span class="comment">//异步向电商S1询价</span></span><br><span class="line">cs.submit(() -&gt; getPriceByS1());</span><br><span class="line"><span class="comment">//异步向电商S2询价</span></span><br><span class="line">cs.submit(() -&gt; getPriceByS2());</span><br><span class="line"><span class="comment">//异步向电商S3询价</span></span><br><span class="line">cs.submit(() -&gt; getPriceByS3());</span><br><span class="line"><span class="comment">//将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    Integer r = cs.take().get();</span><br><span class="line">    executor.execute(() -&gt; save(r));</span><br></pre></td></tr></table></figure>

<p><strong>应用场景总结</strong></p>
<ul>
<li>当需要批量提交异步任务的时候建议你使用CompletionService。CompletionService将线程池Executor和阻塞队列BlockingQueue的功能融合在了一起，能够让批量异步任务的管理更简单。</li>
<li>CompletionService能够让异步任务的执行结果有序化。先执行完的先进入阻塞队列，利用这个特性，你可以轻松实现后续处理的有序性，避免无谓的等待，同时还可以快速实现诸如Forking Cluster这样的需求。</li>
<li>线程池隔离。CompletionService支持自己创建线程池，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。</li>
</ul>
<h2 id="2、CompletableFuture"><a href="#2、CompletableFuture" class="headerlink" title="2、CompletableFuture"></a>2、CompletableFuture</h2><p>适用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">这四个方法区别在于：</span></span><br><span class="line"><span class="function">runAsync 方法以Runnable函数式接口类型为参数，没有返回结果，supplyAsync 方法Supplier函数式接口类型为参数，返回结果类型为U；Supplier 接口的 <span class="title">get</span><span class="params">()</span> 方法是有返回值的（会阻塞）</span></span><br><span class="line"><span class="function">没有指定Executor的方法会使用ForkJoinPool.<span class="title">commonPool</span><span class="params">()</span> 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。</span></span><br><span class="line"><span class="function">默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 JVM option:-Djava.util.concurrent.ForkJoinPool.common.parallelism 来设置 ForkJoinPool 线程池的线程数）。如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I/O 操作，就会导致线程池中所有线程都阻塞在 I/O 操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，强烈建议你要根据不同的业务类型创建不同的线程池，以避免互相干扰</span></span><br></pre></td></tr></table></figure>

<p><strong>CompletableFuture使用详解</strong></p>
<p>简单的任务，用Future获取结果还好，但我们并行提交的多个异步任务，往往并不是独立的，很多时候业务逻辑处理存在串行[依赖]、并行、聚合的关系。如果要我们手动用 Fueture 实现，是非常麻烦的。</p>
<p><strong>CompletableFuture是Future接口的扩展和增强</strong>。CompletableFuture实现了Future接口，并在此基础上进行了丰富地扩展，完美地弥补了Future上述的种种问题。更为重要的是，<strong>CompletableFuture实现了对任务的编排能力</strong>。借助这项能力，我们可以轻松地组织不同任务的运行顺序、规则以及方式。从某种程度上说，这项能力是它的核心能力。而在以往，虽然通过CountDownLatch等工具类也可以实现任务的编排，但需要复杂的逻辑处理，不仅耗费精力且难以维护。</p>
<p><strong>应用场景</strong></p>
<p><strong>描述依赖关系：</strong></p>
<ol>
<li>thenApply() 把前面异步任务的结果，交给后面的Function</li>
<li>thenCompose()用来连接两个有依赖关系的任务，结果由第二个任务返回</li>
</ol>
<p><strong>描述and聚合关系：</strong></p>
<ol>
<li>thenCombine:任务合并，有返回值</li>
<li>thenAccepetBoth:两个任务执行完成后，将结果交给thenAccepetBoth消耗，无返回值。</li>
<li>runAfterBoth:两个任务都执行完成后，执行下一步操作（Runnable）。</li>
</ol>
<p><strong>描述or聚合关系：</strong></p>
<ol>
<li>applyToEither:两个任务谁执行的快，就使用那一个结果，有返回值。</li>
<li>acceptEither: 两个任务谁执行的快，就消耗那一个结果，无返回值。</li>
<li>runAfterEither: 任意一个任务执行完成，进行下一步操作(Runnable)。</li>
</ol>
<p><strong>并行执行：</strong></p>
<p>CompletableFuture类自己也提供了anyOf()和allOf()用于支持多个CompletableFuture并行执行</p>
<p>适用总结：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建异步操作</strong></td>
<td><strong>runAsync&amp;supplyAsync</strong></td>
<td></td>
</tr>
<tr>
<td><strong>获取结果</strong></td>
<td><strong>join&amp;get</strong></td>
<td></td>
</tr>
<tr>
<td><strong>结果处理</strong></td>
<td><strong>whenComplete&amp;exceptionally</strong></td>
<td></td>
</tr>
<tr>
<td><strong>结果转换</strong></td>
<td><strong>thenApply</strong>   <strong>thenCompose</strong></td>
<td></td>
</tr>
<tr>
<td><strong>结果消费</strong></td>
<td><strong>thenAccept</strong>  <strong>thenAcceptBoth</strong>  <strong>thenRun</strong></td>
<td></td>
</tr>
<tr>
<td><strong>结果组合</strong></td>
<td><strong>thenCombine</strong></td>
<td></td>
</tr>
<tr>
<td><strong>任务交互</strong></td>
<td><strong>applyToEither</strong>  <strong>acceptEither</strong>  <strong>runAfterEither</strong>  <strong>runAfterBoth</strong>  <strong>anyOf</strong>  <strong>allOf</strong></td>
<td></td>
</tr>
</tbody></table>
<p><strong>CompletableFuture常用方法总结</strong></p>
<p><img src="/2022/05/11/01-00-15-Future-CompletableFuture-Disruptor/image-20220512001353695.png" alt="image-20220512001353695"></p>
<h2 id="3、Disruptor"><a href="#3、Disruptor" class="headerlink" title="3、Disruptor"></a>3、Disruptor</h2><p>Disruptor实现了队列的功能并且是一个有界队列，可以用于生产者-消费者模型。基于Disruptor开发的系统单线程能支撑每秒600万订单。</p>
<p><code>传统juc下队列存在的问题</code></p>
<ol>
<li><p>juc下的队列大部分采用加ReentrantLock锁方式保证线程安全。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。</p>
</li>
<li><p>加锁的方式通常会严重影响性能。线程会因为竞争不到锁而被挂起，等待其他线程释放锁而唤醒，这个过程存在很大的开销，而且存在死锁的隐患。</p>
</li>
<li><p>有界队列通常采用数组实现。但是采用数组实现又会引发另外一个问题false sharing(伪共享)。</p>
</li>
</ol>
<p><code>Disruptor的设计方案</code></p>
<p>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ul>
<li><strong>环形数组结构</strong></li>
</ul>
<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好（空间局部性原理）。</p>
<ul>
<li><strong>元素位置定位</strong></li>
</ul>
<p>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
<ul>
<li><strong>无锁设计</strong></li>
</ul>
<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
<ul>
<li><strong>利用缓存行填充解决了伪共享的问题</strong></li>
<li><strong>实现了基于事件驱动的生产者消费者模型（观察者模式）</strong>  </li>
</ul>
<p>消费者时刻关注着队列里有没有消息，一旦有新消息产生，消费者线程就会立刻把它消费</p>
<p><code>RingBuffer数据结构</code></p>
<p><img src="/2022/05/11/01-00-15-Future-CompletableFuture-Disruptor/image-20220522121934952.png" alt="image-20220522121934952"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注：</span><br><span class="line"><span class="number">1</span>、Disruptor要求设置数组长度为<span class="number">2</span>的n次幂，便于计算索引，同hashmap</span><br><span class="line"><span class="number">2</span>、当所有位置都放满了，再放下一个时，就会把<span class="number">0</span>号位置覆盖掉</span><br></pre></td></tr></table></figure>

<p><strong>能覆盖数据是否会导致数据丢失呢？</strong></p>
<p>当需要覆盖数据时，会执行一个策略，Disruptor给提供多种策略，比较常用的：</p>
<ul>
<li><strong>BlockingWaitStrategy策略</strong>，常见且默认的等待策略，当这个队列里满了，不执行覆盖，而是阻塞等待。使用ReentrantLock+Condition实现阻塞，最节省cpu，但高并发场景下性能最差。适合CPU资源紧缺，吞吐量和延迟并不重要的场景</li>
<li><strong>SleepingWaitStrategy策略</strong>，会在循环中不断等待数据。先进行自旋等待如果不成功，则使用Thread.yield()让出CPU,并最终使用LockSupport.parkNanos(1L)进行线程休眠，以确保不占用太多的CPU资源。因此这个策略会产生比较高的平均延时。典型的应用场景就是异步日志。 </li>
<li><strong>YieldingWaitStrategy策略</strong>，这个策略用于低延时的场合。消费者线程会不断循环监控缓冲区变化，在循环内部使用Thread.yield()让出CPU给别的线程执行时间。如果需要一个高性能的系统，并且对延时比较有严格的要求，可以考虑这种策略。</li>
<li><strong>BusySpinWaitStrategy策略</strong>: 采用死循环，消费者线程会尽最大努力监控缓冲区的变化。对延时非常苛刻的场景使用，cpu核数必须大于消费者线程数量。推荐在线程绑定到固定的CPU的场景下使用</li>
</ul>
<p><code><strong>一个生产者单线程写数据的流程</strong></code></p>
<ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以写入，则返回最大的序列号。这里主要判断是否会覆盖未读的元素；</li>
<li>若是返回的正确，则生产者开始写入元素。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 消息载体（事件）</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">## 事件工厂</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">OrderEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 消费者</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">OrderEvent</span>&gt;, <span class="title">WorkHandler</span>&lt;<span class="title">OrderEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(OrderEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 消费逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者&quot;</span>+ Thread.currentThread().getName()</span><br><span class="line">                +<span class="string">&quot;获取数据value:&quot;</span>+ event.getValue()+<span class="string">&quot;,name:&quot;</span>+event.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(OrderEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 消费逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者&quot;</span>+ Thread.currentThread().getName()</span><br><span class="line">                +<span class="string">&quot;获取数据value:&quot;</span>+ event.getValue()+<span class="string">&quot;,name:&quot;</span>+event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 生产者</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//事件队列</span></span><br><span class="line">    <span class="keyword">private</span> RingBuffer&lt;OrderEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderEventProducer</span><span class="params">(RingBuffer&lt;OrderEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">long</span> value,String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事件队列 的下一个槽</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取消息（事件）</span></span><br><span class="line">            OrderEvent orderEvent = ringBuffer.get(sequence);</span><br><span class="line">            <span class="comment">// 写入消息数据</span></span><br><span class="line">            orderEvent.setValue(value);</span><br><span class="line">            orderEvent.setName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO  异常处理</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者&quot;</span>+ Thread.currentThread().getName()</span><br><span class="line">                    +<span class="string">&quot;发送数据value:&quot;</span>+value+<span class="string">&quot;,name:&quot;</span>+name);</span><br><span class="line">            <span class="comment">//发布事件</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 运行示例</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建disruptor</span></span><br><span class="line">        Disruptor&lt;OrderEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">                OrderEvent::<span class="keyword">new</span>,</span><br><span class="line">                <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                ProducerType.SINGLE, <span class="comment">//单生产者</span></span><br><span class="line">                <span class="keyword">new</span> YieldingWaitStrategy()  <span class="comment">//等待策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消费者用于处理RingBuffer的事件</span></span><br><span class="line">        <span class="comment">//disruptor.handleEventsWith(new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//设置多消费者,消息会被重复消费</span></span><br><span class="line"><span class="comment">//        disruptor.handleEventsWith(new OrderEventHandler(),new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//设置多消费者,消费者要实现WorkHandler接口，一条消息只会被一个消费者消费</span></span><br><span class="line">        disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> OrderEventHandler(), <span class="keyword">new</span> OrderEventHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动disruptor</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ringbuffer容器</span></span><br><span class="line">        RingBuffer&lt;OrderEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        OrderEventProducer eventProducer = <span class="keyword">new</span> OrderEventProducer(ringBuffer);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            eventProducer.onData(i,<span class="string">&quot;Fox&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        disruptor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 结果</span><br><span class="line">## 执行<span class="number">80</span>行代码 即一个消费者消费</span><br><span class="line">生产者main发送数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者main发送数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">生产者main发送数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">生产者main发送数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">生产者main发送数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">    </span><br><span class="line">## 执行<span class="number">81</span>行代码 注释<span class="number">80</span>行 即多个消费者消费【会重复消费】</span><br><span class="line">生产者main发送数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者main发送数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者main发送数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">生产者main发送数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">生产者main发送数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>单生产者多消费者模式</code></p>
<p>注意：消费者要实现WorkHandler接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同上述执行<span class="number">81</span>行代码逻辑</span><br></pre></td></tr></table></figure>

<p><code>多生产者多消费者模式</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建disruptor</span></span><br><span class="line">        Disruptor&lt;OrderEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> OrderEventFactory(),</span><br><span class="line">                <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                ProducerType.MULTI, <span class="comment">//多生产者</span></span><br><span class="line">                <span class="keyword">new</span> YieldingWaitStrategy()  <span class="comment">//等待策略</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置消费者用于处理RingBuffer的事件</span></span><br><span class="line">        <span class="comment">//disruptor.handleEventsWith(new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//设置多消费者,消息会被重复消费</span></span><br><span class="line"><span class="comment">//        disruptor.handleEventsWith(new OrderEventHandler(),new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//设置多消费者,消费者要实现WorkHandler接口，一条消息只会被一个消费者消费</span></span><br><span class="line">        disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> OrderEventHandler(), <span class="keyword">new</span> OrderEventHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动disruptor</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ringbuffer容器</span></span><br><span class="line">        RingBuffer&lt;OrderEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//创建生产者</span></span><br><span class="line">            OrderEventProducer eventProducer = <span class="keyword">new</span> OrderEventProducer(ringBuffer);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                eventProducer.onData(i,<span class="string">&quot;Fox&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//创建生产者</span></span><br><span class="line">            OrderEventProducer eventProducer = <span class="keyword">new</span> OrderEventProducer(ringBuffer);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                eventProducer.onData(i,<span class="string">&quot;monkey&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//disruptor.shutdown();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 结果</span><br><span class="line">生产者producer1发送数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者producer2发送数据value:<span class="number">0</span>,name:monkey0</span><br><span class="line">生产者producer1发送数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">0</span>,name:monkey0</span><br><span class="line">生产者producer2发送数据value:<span class="number">1</span>,name:monkey1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者producer2发送数据value:<span class="number">2</span>,name:monkey2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">生产者producer1发送数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">生产者producer2发送数据value:<span class="number">3</span>,name:monkey3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">1</span>,name:monkey1</span><br><span class="line">生产者producer2发送数据value:<span class="number">4</span>,name:monkey4</span><br><span class="line">生产者producer1发送数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">生产者producer1发送数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">2</span>,name:monkey2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">3</span>,name:monkey3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">4</span>,name:monkey4</span><br></pre></td></tr></table></figure>

<p><code>消费者优先级模式</code></p>
<p>在实际场景中，我们通常会因为业务逻辑而形成一条消费链。比如一个消息必须由 消费者A -&gt; 消费者B -&gt; 消费者C 的顺序依次进行消费。在配置消费者时，可以通过 .then 方法去实现顺序消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> OrderEventHandler())</span><br><span class="line">         .then(<span class="keyword">new</span> OrderEventHandler())</span><br></pre></td></tr></table></figure>

<p>handleEventsWith 与 handleEventsWithWorkerPool 都是支持 .then 的，它们可以结合使用。比如可以按照 消费者A -&gt; (消费者B 消费者C) -&gt; 消费者D 的消费顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> OrderEventHandler())</span><br><span class="line">         .thenHandleEventsWithWorkerPool(<span class="keyword">new</span> OrderEventHandler(), <span class="keyword">new</span> OrderEventHandler())</span><br><span class="line">         .then(<span class="keyword">new</span> OrderEventHandler());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建disruptor</span></span><br><span class="line">        Disruptor&lt;OrderEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> OrderEventFactory(),</span><br><span class="line">                <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                ProducerType.MULTI, <span class="comment">//多生产者</span></span><br><span class="line">                <span class="keyword">new</span> YieldingWaitStrategy()  <span class="comment">//等待策略</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置消费者用于处理RingBuffer的事件</span></span><br><span class="line">        <span class="comment">//disruptor.handleEventsWith(new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//设置多消费者,消息会被重复消费</span></span><br><span class="line">        <span class="comment">//disruptor.handleEventsWith(new OrderEventHandler(),new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//设置多消费者,消费者要实现WorkHandler接口，一条消息只会被一个消费者消费</span></span><br><span class="line">        <span class="comment">//disruptor.handleEventsWithWorkerPool(new OrderEventHandler(), new OrderEventHandler());</span></span><br><span class="line">        <span class="comment">//按消费者优先级消费  消费者A -&gt; (消费者B 消费者C) -&gt; 消费者D</span></span><br><span class="line">        disruptor.handleEventsWith(<span class="keyword">new</span> OrderEventHandler())</span><br><span class="line">                .thenHandleEventsWithWorkerPool(<span class="keyword">new</span> OrderEventHandler(), <span class="keyword">new</span> OrderEventHandler())</span><br><span class="line">                .then(<span class="keyword">new</span> OrderEventHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动disruptor</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ringbuffer容器</span></span><br><span class="line">        RingBuffer&lt;OrderEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//创建生产者</span></span><br><span class="line">            OrderEventProducer eventProducer = <span class="keyword">new</span> OrderEventProducer(ringBuffer);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                eventProducer.onData(i,<span class="string">&quot;Fox&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            //创建生产者</span></span><br><span class="line"><span class="comment">//            OrderEventProducer eventProducer = new OrderEventProducer(ringBuffer);</span></span><br><span class="line"><span class="comment">//            // 发送消息</span></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;100;i++)&#123;</span></span><br><span class="line"><span class="comment">//                eventProducer.onData(i,&quot;monkey&quot;+i);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;,&quot;producer2&quot;).start();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//disruptor.shutdown();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 结果</span><br><span class="line">生产者producer1发送数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者producer1发送数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">生产者producer1发送数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">4</span>获取数据value:<span class="number">0</span>,name:Fox0</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">3</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">生产者producer1发送数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">4</span>获取数据value:<span class="number">1</span>,name:Fox1</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">生产者producer1发送数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">3</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">1</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">4</span>获取数据value:<span class="number">2</span>,name:Fox2</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">2</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">4</span>获取数据value:<span class="number">3</span>,name:Fox3</span><br><span class="line">消费者pool-<span class="number">1</span>-thread-<span class="number">4</span>获取数据value:<span class="number">4</span>,name:Fox4</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Future</tag>
        <tag>CompletableFuture</tag>
        <tag>Disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>并发设计模式</title>
    <url>/2022/05/15/01-00-18-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="常用并发设计模式"><a href="#常用并发设计模式" class="headerlink" title="常用并发设计模式"></a>常用并发设计模式</h2><h3 id="1、终止线程的设计模式"><a href="#1、终止线程的设计模式" class="headerlink" title="1、终止线程的设计模式"></a>1、终止线程的设计模式</h3><p>思考：在一个线程 T1 中如何正确安全的终止线程 T2？</p>
<ul>
<li>错误思路1：使用线程对象的 stop() 方法停止线程 </li>
</ul>
<p>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁 。</p>
<ul>
<li>错误思路2：使用 System.exit(int) 方法停止线程 </li>
</ul>
<p>目的仅是停止一个线程，但这种做法会让整个程序都停止</p>
<p><strong>正确思路：利用Java线程的中断机制</strong></p>
<p>以下是两个示例代码：</p>
<p>示例一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//采集线程</span></span><br><span class="line">    Thread rptThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动采集功能</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        rptThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="comment">//省略采集、回传实现</span></span><br><span class="line">                report();</span><br><span class="line">                <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//重新设置线程中断状态</span></span><br><span class="line">                   <span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">            started = <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        rptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;采集数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止采集功能</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rptThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonitorProxy monitor = <span class="keyword">new</span> MonitorProxy();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">## 使用中断标志位终止线程</span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorProxy2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//采集线程</span></span><br><span class="line">    Thread rptThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程终止标志位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动采集功能</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        rptThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp;!terminated) &#123;</span><br><span class="line">                <span class="comment">//省略采集、回传实现</span></span><br><span class="line">                report();</span><br><span class="line">                <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//重新设置线程中断状态</span></span><br><span class="line">                    <span class="comment">//Thread.currentThread().interrupt();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">            started = <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        rptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;采集数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止采集功能</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置中断标志位</span></span><br><span class="line">        terminated = <span class="keyword">true</span>;</span><br><span class="line">        rptThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonitorProxy2 monitor = <span class="keyword">new</span> MonitorProxy2();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">### 中断标志位 + 自定义标识</span><br></pre></td></tr></table></figure>

<p><strong>Two-phase Termination（两阶段终止）模式——优雅的终止线程</strong></p>
<p>将终止过程分成两个阶段，其中第一个阶段主要是线程 T1 向线程 T2发送终止指令，而第二阶段则是线程 T2响应终止指令。</p>
<p>Java 线程进入终止状态的前提是线程进入 RUNNABLE 状态，而利用java线程中断机制的interrupt() 方法，可以让线程从休眠状态转换到RUNNABLE 状态。RUNNABLE 状态转换到终止状态，优雅的方式是让 Java 线程自己执行完 run() 方法，所以一般我们采用的方法是设置一个标志位，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出 run() 方法。</p>
<p>两阶段终止模式是一种应用很广泛的并发设计模式，在 Java 语言中使用两阶段终止模式来优雅地终止线程，需要注意两个关键点：一个是仅检查终止标志位是不够的，因为线程的状态可能处于休眠态；另一个是仅检查线程的中断状态也是不够的，因为我们依赖的第三方类库很可能没有正确处理中断异常，例如第三方类库在捕获到 Thread.sleep() 方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以我们可以自定义线程的终止标志位用于终止线程。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>安全地终止线程，比如释放该释放的资源；</li>
<li>要确保终止处理逻辑在线程结束之前一定会执行时，可使用该方法；</li>
</ol>
<h3 id="2、避免共享的设计模式"><a href="#2、避免共享的设计模式" class="headerlink" title="2、避免共享的设计模式"></a>2、避免共享的设计模式</h3><p>Immutability模式，Copy-on-Write模式，Thread-Specific Storage模式本质上都是为了避免共享。</p>
<ul>
<li>使用时需要注意Immutability模式的属性的不可变性【光类不变是没用的】</li>
<li>Copy-on-Write模式需要注意拷贝的性能问题</li>
<li>Thread-Specific Storage模式需要注意异步执行问题。</li>
</ul>
<p><code>分类</code></p>
<ul>
<li><p><strong>Immutability模式</strong></p>
<p>“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</p>
<p><strong>如何实现</strong></p>
<p>将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了。更严格的做法是这个类本身也是 final 的，也就是不允许继承。</p>
<p>jdk中很多类都具备不可变性，例如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。它们都严格遵守了不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。</p>
<p><strong>使用 Immutability 模式的注意事项</strong></p>
<p>在使用 Immutability 模式的时候，需要注意以下两点：</p>
<ul>
<li>对象的所有属性都是 final 的，并不能保证不可变性；</li>
<li>不可变对象也需要正确发布。</li>
</ul>
<p>在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。</p>
</li>
<li><p><strong>Copy-on-Write模式</strong></p>
<p>Java 里 String 在实现 replace() 方法的时候，并没有更改原字符串里面 value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。它本质上是一种 Copy-on-Write 方法。所谓 Copy-on-Write，经常被缩写为 COW 或者 CoW，顾名思义就是写时复制。</p>
<p>不可变对象的写操作往往都是使用 Copy-on-Write 方法解决的，当然 Copy-on-Write 的应用领域并不局限于 Immutability 模式。</p>
<p>Copy-on-Write 才是最简单的并发解决方案，很多人都在无意中把它忽视了。它是如此简单，以至于 Java 中的基本数据类型 String、Integer、Long 等都是基于 Copy-on-Write 方案实现的。</p>
<p>Copy-on-Write 缺点就是消耗内存，每次修改都需要复制一个新的对象出来，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实际工作中，如果写操作非常少（读多写少的场景），可以尝试使用 Copy-on-Write。</p>
<p><strong>应用场景</strong></p>
<p>在Java中，<strong>CopyOnWriteArrayList</strong> 和 <strong>CopyOnWriteArraySet</strong> 这两个 Copy-on-Write 容器，它们背后的设计思想就是 Copy-on-Write；通过 Copy-on-Write 这两个容器实现的读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。</p>
<p>Copy-on-Write 在操作系统领域也有广泛的应用。类 Unix 的操作系统中创建进程的 API 是 fork()，传统的 fork() 函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G 的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G 内存）给子进程，这个过程是很耗时的。而 Linux 中fork() 子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。</p>
<p>Copy-on-Write 最大的应用领域还是在函数式编程领域。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决。</p>
<p>像一些RPC框架还有服务注册中心，也会利用Copy-on-Write设计思想维护服务路由表。路由表是典型的读多写少，而且路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有 5 秒钟延迟，很多时候也都是能接受的。</p>
</li>
<li><p><strong>Thread-Specific Storage 模式——没有共享就没有伤害</strong></p>
<p>Thread-Specific Storage（线程本地存储） 模式是一种即使只有一个入口，也会在内部为每个线程分配特有的存储空间的模式。在 Java 标准类库中，ThreadLocal 类实现了该模式。</p>
<p>线程本地存储模式本质上是一种避免共享的方案，由于没有共享，所以自然也就没有并发问题。如果你需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。</p>
<p><strong>应用场景</strong></p>
<p>SimpleDateFormat 不是线程安全的，那如果需要在并发场景下使用它，有一个办法就是用 ThreadLocal 来解决。</p>
</li>
</ul>
<h3 id="3、多线程版本的if模式"><a href="#3、多线程版本的if模式" class="headerlink" title="3、多线程版本的if模式"></a>3、多线程版本的if模式</h3><p>Guarded Suspension模式和Balking模式属于多线程版本的if模式</p>
<ul>
<li>Guarded Suspension模式需要注意性能。</li>
<li>Balking模式需要注意竞态问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//没有结果等待   防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span> (obj==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//获取到结果，给obj赋值</span></span><br><span class="line">            <span class="keyword">this</span>.obj = obj;</span><br><span class="line">            <span class="comment">//唤醒等待结果的线程</span></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Guarded Suspension模式——等我准备好哦</strong></p>
<p>Guarded Suspension 模式是通过让线程等待来保护实例的安全性，即守护-挂起模式。在多线程开发中，常常为了提高应用程序的并发性，会将一个任务分解为多个子任务交给多个线程并行执行，而多个线程之间相互协作时，仍然会存在一个线程需要等待另外的线程完成后继续下一步操作。而Guarded Suspension模式可以帮助我们解决上述的等待问题。</p>
<p>Guarded Suspension 模式允许多个线程对实例资源进行访问，但是实例资源需要对资源的分配做出管理。</p>
<p>Guarded Suspension 模式也常被称作 Guarded Wait 模式、Spin Lock 模式（因为使用了 while 循环去等待），它还有一个更形象的非官方名字：多线程版本的 if。</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject </li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式 </li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
<li>等待唤醒机制的规范实现。此模式依赖于Java线程的阻塞唤醒机制：</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ul>
<li>sychronized+wait/notify/notifyAll</li>
<li>reentrantLock+Condition(await/singal/singalAll)</li>
<li>cas+park/unpark     </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Balking模式——不需要就算了</strong></p>
<p>Balking是“退缩不前”的意思。如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回。当流程的执行顺序依赖于某个共享变量的场景，可以归纳为<strong>多线程if模式</strong>。Balking 模式常用于一个线程发现另一个线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。</p>
<p>Balking模式是一种多个线程执行同一操作A时可以考虑的模式；在某一个线程B被阻塞或者执行其他操作时，其他线程同样可以完成操作A，而当线程B恢复执行或者要执行操作A时，因A已被执行，而无需线程B再执行，从而提高了B的执行效率。</p>
<p>Balking模式和Guarded Suspension模式一样，存在守护条件，如果守护条件不满足，则中断处理；这与Guarded Suspension模式不同，Guarded Suspension模式在守护条件不满足的时候会一直等待至可以运行。</p>
<p><strong>常见的应用场景</strong></p>
<ul>
<li>sychronized轻量级锁膨胀逻辑， 只需要一个线程膨胀获取monitor对象    </li>
<li>DCL单例实现</li>
</ul>
</li>
</ul>
<h3 id="4、多线程分工模式"><a href="#4、多线程分工模式" class="headerlink" title="4、多线程分工模式"></a>4、多线程分工模式</h3><ul>
<li><p><strong>Thread-Per-Message 模式——****最简单实用的分工方法</strong></p>
<ul>
<li>Thread-Per-Message 模式需要注意线程的创建，销毁以及是否会导致OOM。</li>
<li>Worker Thread 模式需要注意死锁问题，提交的任务之间不要有依赖性。</li>
<li>生产者 - 消费者模式可以直接使用线程池来实现</li>
</ul>
<p><strong>应用场景</strong></p>
<p>Thread-Per-Message 模式的一个最经典的应用场景是<strong>网络编程里服务端的实现</strong>，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。</p>
</li>
<li><p><strong>Worker Thread模式——如何避免重复创建线程</strong></p>
<p>要想有效避免线程的频繁创建、销毁以及 OOM 问题，就不得不提 Java 领域使用最多的 Worker Thread 模式。Worker Thread 模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。Worker Thread 模式中 Worker Thread 对应到现实世界里，其实指的就是车间里的工人。</p>
<p><strong>应用场景</strong></p>
<p>Worker Thread 模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。Java 语言里可以直接使用线程池来实现 Worker Thread 模式，线程池是一个非常基础和优秀的工具类，甚至有些大厂的编码规范都不允许用 new Thread() 来创建线程，必须使用线程池。</p>
</li>
<li><p><strong>生产者 - 消费者模式——用流水线的思想提高效率</strong></p>
<p>Worker Thread 模式类比的是工厂里车间工人的工作模式。但其实在现实世界，工厂里还有一种流水线的工作模式，类比到编程领域，就是生产者 - 消费者模式。</p>
<p>生产者 - 消费者模式的核心是一个任务队列，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。</p>
<p><strong>生产者 - 消费者模式的优点</strong></p>
<p><strong>支持异步处理</strong></p>
<p>场景：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式</p>
<p><strong>解耦</strong></p>
<p>场景：用户下单后，订单系统需要通知库存系统扣减库存。</p>
<p><strong>可以消除生产者生产与消费者消费之间速度差异</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>并发设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor&amp;ForkJoin&amp;CompletableFuture总结</title>
    <url>/2022/05/18/01-00-21-ThreadPoolExecutor-ForkJoin-CompletableFuture%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="1、ThreadPoolExecutor"><a href="#1、ThreadPoolExecutor" class="headerlink" title="1、ThreadPoolExecutor"></a>1、ThreadPoolExecutor</h2><p><code>线程和协程</code></p>
<p><strong>线程</strong>是调度CPU资源的最小单位，线程模型分为KLT模型与ULT模型，JVM使用的KLT模型，Java线程与OS线程保持1:1的映射关系，也就是说有一个java线程也会在操作系统里有一个对应的线程。</p>
<p><strong>协程</strong>    (纤程，用户级线程)，目的是为了追求最大力度的发挥硬件性能和提升软件的速度，协程基本原理是:在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来的栈信息并继续执行(整个过程线程不需要上下文切换)。</p>
<p>只有一个线程，但是虚拟出来了很多线程栈空间，是在一个cpu的一个核上执行。不需要上下文切换，也不需要内核态和用户态的切换，不会去调用操作系统库函数创建操作系统线程</p>
<blockquote>
<p>Java原生不支持协程，在纯java代码里需要使用协程的话需要引入第三方包,如：quasar</p>
</blockquote>
<p><code>线程池</code></p>
<p><strong>为什么使用线程池</strong></p>
<p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p>
<p><strong>什么时候使用线程池？</strong></p>
<ul>
<li>单个任务处理时间比较短</li>
<li>需要处理的任务数量很大</li>
</ul>
<p><strong>线程池优势</strong></p>
<ul>
<li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p><strong>ExecutorService关键方法</strong></p>
<p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p>
<p>1，<strong>execute</strong>（Runnable command）：履行Ruannable类型的任务,</p>
<p>2，<strong>submit</strong>（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future对象</p>
<p>3，<strong>shutdown</strong>（）：在完成已提交的任务后封闭办事，不再接管新任务,</p>
<p>4，<strong>shutdownNow</strong>（）：停止所有正在履行的任务并封闭办事。</p>
<p>5，<strong>isTerminated</strong>（）：测试是否所有任务都履行完毕了。</p>
<p>6，<strong>isShutdown</strong>（）：测试是否该ExecutorService已被关闭。</p>
<p><strong>线程池的五种状态</strong></p>
<p>1、RUNNING</p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 </p>
<p>(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！</p>
<p>2、 SHUTDOWN</p>
<p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </p>
<p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP</p>
<p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </p>
<p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING</p>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </p>
<p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED</p>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 </p>
<p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>workerCount为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
<p><img src="/2022/05/18/01-00-21-ThreadPoolExecutor-ForkJoin-CompletableFuture%E6%80%BB%E7%BB%93/image-20220518234838806.png" alt="image-20220518234838806"></p>
<p><code>线程池的核心参数</code></p>
<p><strong>corePoolSize</strong></p>
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<p><strong>maximumPoolSize【核心线程数+非核心线程数】</strong></p>
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；</p>
<p><strong>keepAliveTime</strong></p>
<p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p>
<p><strong>unit</strong></p>
<p>keepAliveTime的单位；</p>
<p><strong>workQueue</strong></p>
<p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p>
<ul>
<li>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</li>
<li>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</li>
<li>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</li>
</ul>
<p><strong>threadFactory</strong></p>
<p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</p>
<p><strong>handler</strong></p>
<p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<ul>
<li>1、AbortPolicy：直接抛出异常，默认策略；</li>
<li>2、CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>4、DiscardPolicy：直接丢弃任务；</li>
</ul>
<p>上面的4种策略都是ThreadPoolExecutor的内部类。</p>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<p>拒绝策略也可以自己制定，比如说任务是不能丢弃的，那么可以将任务放到redis中间间，然后在拒绝策略里面实现监控线程池的队列中任务个数，比如少于50%就从redis中取任务放入队列中</p>
<p><strong>原理</strong></p>
<p><img src="/2022/05/18/01-00-21-ThreadPoolExecutor-ForkJoin-CompletableFuture%E6%80%BB%E7%BB%93/image-20220518234928826.png" alt="image-20220518234928826"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当线程池来一个任务时，此时核心线程数为<span class="number">0</span>，会创建线程，这个线程执行完后。又来一个任务，此时核心线程数少于设置的核心线程数，虽然第一个线程已经执行完了，但是还是会新建一个核心线程。</span><br><span class="line">等核心线程数满了。在来任务，会往队列里面存放。队列满了，会创建非核心线程，最大非核心线程数是maximumPoolSize - corePoolSize。线程池满了，并且核心和非核心线程数都用完了，会执行拒绝策略。</span><br></pre></td></tr></table></figure>

<h2 id="2、ForkJoin"><a href="#2、ForkJoin" class="headerlink" title="2、ForkJoin"></a>2、ForkJoin</h2><p><code>Fork/Join框架介绍</code>&gt;</p>
<p>传统线程池ThreadPoolExecutor有两个明显的缺点：一是无法对大任务进行拆分，对于某个任务只能由单线程执行；二是工作线程从队列中获取任务时存在竞争情况。这两个缺点都会影响任务的执行效率。为了解决传统线程池的缺陷，Java7中引入Fork/Join框架，并在Java8中得到广泛应用。Fork/Join框架的核心是ForkJoinPool类，它是对AbstractExecutorService类的扩展。ForkJoinPool允许其他线程向它提交任务，并根据设定将这些任务拆分为粒度更细的子任务，这些子任务将由ForkJoinPool内部的工作线程来并行执行，并且工作线程之间可以窃取彼此之间的任务。</p>
<p><code>>ForkJoinPool</code></p>
<p>ForkJoinPool中有四个核心参数，用于控制线程池的并行数、工作线程的创建、异常处理和模式指定等。各参数解释如下：</p>
<ul>
<li>int parallelism：指定并行级别（parallelism level）。ForkJoinPool将根据这个设定，决定工作线程的数量。如果未设置的话，将使用Runtime.getRuntime().availableProcessors()来设置并行级别；</li>
<li>ForkJoinWorkerThreadFactory factory：ForkJoinPool在创建线程时，会通过factory来创建。注意，这里需要实现的是ForkJoinWorkerThreadFactory，而不是ThreadFactory。如果你不指定factory，那么将由默认的DefaultForkJoinWorkerThreadFactory负责线程的创建工作；</li>
<li>UncaughtExceptionHandler handler：指定异常处理器，当任务在运行中出错时，将由设定的处理器处理；</li>
<li>boolean asyncMode：设置队列的工作模式：asyncMode ? FIFO_QUEUE : LIFO_QUEUE。当asyncMode为true时，将使用先进先出队列，而为false时则使用后进先出的模式。</li>
</ul>
<p><code><strong>ForkJoinTask</strong></code></p>
<p>ForkJoinTask是ForkJoinPool的核心之一，它是任务的实际载体，定义了任务执行时的具体逻辑和拆分逻辑。ForkJoinTask继承了Future接口，所以也可以将其看作是轻量级的Future。</p>
<p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，承载着主要的任务协调作用，一个用于任务提交，一个用于结果获取。</p>
<ul>
<li><strong>fork()——提交任务</strong></li>
</ul>
<p>fork()方法用于向当前任务所运行的线程池中提交任务。如果当前线程是ForkJoinWorkerThread类型，将会放入该线程的工作队列，否则放入common线程池的工作队列中。</p>
<ul>
<li><strong>join()——获取任务执行结果</strong></li>
</ul>
<p>join()方法用于获取任务的执行结果。调用join()时，将阻塞当前线程直到对应的子任务完成运行并返回结果。</p>
<p>通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下三个子类：</p>
<ul>
<li><strong>RecursiveAction</strong>：用于递归执行但不需要返回结果的任务。</li>
<li><strong>RecursiveTask</strong> ：用于递归执行需要返回结果的任务。</li>
<li>CountedCompleter ：在任务完成执行后会触发执行一个自定义的钩子函数</li>
</ul>
<p><code>ForkJoinTask使用限制</code></p>
<p>ForkJoinTask最适合用于纯粹的计算任务，也就是纯函数计算，计算过程中的对象都是独立的，对外部没有依赖。提交到ForkJoinPool中的任务应避免执行阻塞I/O。</p>
<p><code>工作窃取</code></p>
<p><img src="/2022/05/18/01-00-21-ThreadPoolExecutor-ForkJoin-CompletableFuture%E6%80%BB%E7%BB%93/image-20220519000816530.png" alt="image-20220519000816530"></p>
<ul>
<li>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争;</li>
<li>工作窃取算法缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。 </li>
</ul>
<h2 id="3、CompletableFuture"><a href="#3、CompletableFuture" class="headerlink" title="3、CompletableFuture"></a>3、CompletableFuture</h2><p><code>Callable和Runnable的区别</code></p>
<p>Runnable 的缺陷：</p>
<ul>
<li>不能返回一个返回值</li>
<li>不能抛出 checked Exception</li>
</ul>
<p><code>Future 的主要功能</code></p>
<p><strong>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。****必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</strong></p>
<ul>
<li>boolean cancel (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束</li>
<li>boolean isCancelled () 任务是否已经取消，任务正常完成前将其取消，则返回 true</li>
<li>boolean isDone () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</li>
<li>V get () throws InterruptedException, ExecutionException  等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException</li>
<li>V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException</li>
</ul>
<p><code>Future 注意事项</code>&gt;</p>
<ul>
<li>当 for 循环批量获取 Future 的结果时容易 block，get 方法调用时应使用 timeout 限制</li>
<li>Future 的生命周期不能后退。一旦完成了任务，它就永久停在了“已完成”的状态，不能从头再来</li>
</ul>
<p><code>Future的局限性</code>&gt;</p>
<p>从本质上说，<strong>Future表示一个异步计算的结果</strong>。它提供了isDone()来检测计算是否已经完成，并且在计算结束后，可以通过get()方法来获取计算结果。在异步计算中，Future确实是个非常优秀的接口。但是，它的本身也确实存在着许多限制：</p>
<ul>
<li><strong>并发执行多任务</strong>：Future只提供了get()方法来获取结果，并且是阻塞的。所以，除了等待你别无他法；</li>
<li><strong>无法对多个任务进行链式调用</strong>：如果你希望在计算任务完成后执行特定动作，比如发邮件，但Future却没有提供这样的能力；</li>
<li><strong>无法组合多个任务</strong>：如果你运行了10个任务，并期望在它们全部执行结束后执行特定动作，那么在Future中这是无能为力的；</li>
<li><strong>没有异常处理</strong>：Future接口中没有关于异常处理的方法；</li>
</ul>
<p><code>CompletionService</code></p>
<p>内部通过阻塞队列+FutureTask，实现了任务先完成可优先获取到，即结果按照完成先后顺序排序，内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，通过调用它的take方法或poll方法可以获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果</p>
<p><strong>应用场景总结</strong></p>
<ul>
<li>当需要批量提交异步任务的时候建议你使用CompletionService。CompletionService将线程池Executor和阻塞队列BlockingQueue的功能融合在了一起，能够让批量异步任务的管理更简单。</li>
<li>CompletionService能够让异步任务的执行结果有序化。先执行完的先进入阻塞队列，利用这个特性，你可以轻松实现后续处理的有序性，避免无谓的等待，同时还可以快速实现诸如Forking Cluster这样的需求。</li>
<li>线程池隔离。CompletionService支持自己创建线程池，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。</li>
</ul>
<p><code>CompletableFuture使用详解</code></p>
<p><strong>应用场景</strong></p>
<p><strong>描述依赖关系：</strong></p>
<ol>
<li>thenApply() 把前面异步任务的结果，交给后面的Function</li>
<li>thenCompose()用来连接两个有依赖关系的任务，结果由第二个任务返回</li>
</ol>
<p><strong>描述and聚合关系：</strong></p>
<ol>
<li>thenCombine:任务合并，有返回值</li>
<li>thenAccepetBoth:两个任务执行完成后，将结果交给thenAccepetBoth消耗，无返回值。</li>
<li>runAfterBoth:两个任务都执行完成后，执行下一步操作（Runnable）。</li>
</ol>
<p><strong>描述or聚合关系：</strong></p>
<ol>
<li>applyToEither:两个任务谁执行的快，就使用那一个结果，有返回值。</li>
<li>acceptEither: 两个任务谁执行的快，就消耗那一个结果，无返回值。</li>
<li>runAfterEither: 任意一个任务执行完成，进行下一步操作(Runnable)。</li>
</ol>
<p><strong>并行执行：</strong></p>
<p>CompletableFuture类自己也提供了anyOf()和allOf()用于支持多个CompletableFuture并行执行</p>
<p><code>CompletableFuture总结</code></p>
<p>CompletableFuture这块主要是api的使用，它的api由以下几种类型：</p>
<ul>
<li><strong>创建异步操作</strong></li>
<li><strong>获取结果</strong></li>
<li><strong>结果处理</strong></li>
<li><strong>结果转换</strong></li>
<li><strong>结果消费</strong></li>
<li><strong>结果组合</strong></li>
<li><strong>任务交互</strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ForkJoin</tag>
        <tag>ThreadPoolExecutor</tag>
        <tag>CompletableFuture</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之底层架构核心概念</title>
    <url>/2022/06/18/02-00-01-Spring%E4%B9%8B%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><h3 id="1、BeanDefinition"><a href="#1、BeanDefinition" class="headerlink" title="1、BeanDefinition"></a>1、BeanDefinition</h3><blockquote>
<p>BeanDefinition即bean定义，相当于bean的元数据，其地位类比如下：BeanDefinition之于bean就像java  Class类至于java对象。【个人理解】</p>
<p>BeanDefinition表示Bean定义，BeanDefinition中存在很多属性用来描述一个Bean的特点。比如：</p>
<ul>
<li>class，表示Bean类型</li>
<li>scope，表示Bean作用域，单例或原型等</li>
<li>lazyInit：表示Bean是否是懒加载</li>
<li>initMethodName：表示Bean初始化时要执行的方法</li>
<li>destroyMethodName：表示Bean销毁时要执行的方法</li>
<li>还有很多…</li>
</ul>
<p><strong>声明式的bean</strong>:</p>
<ol>
<li>&lt; bean /&gt;</li>
<li>@Bean</li>
<li>@Component(@Service,@Controller)</li>
</ol>
<p><strong>编程式的bean:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"><span class="comment">// 生成一个BeanDefinition对象，并设置beanClass为User.class，并注册到ApplicationContext中</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">beanDefinition.setBeanClass(User.class);</span><br><span class="line">context.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>给BeanDefinition设置bean属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanDefinition.setScope(<span class="string">&quot;prototype&quot;</span>); <span class="comment">// 设置作用域</span></span><br><span class="line">beanDefinition.setInitMethodName(<span class="string">&quot;init&quot;</span>); <span class="comment">// 设置初始化方法</span></span><br><span class="line">beanDefinition.setLazyInit(<span class="keyword">true</span>); <span class="comment">// 设置懒加载</span></span><br></pre></td></tr></table></figure>

<p>和申明式事务、编程式事务类似，通过，@Bean，@Component等申明式方式所定义的Bean，最终都会被Spring解析为对应的BeanDefinition对象，并放入Spring容器中。</p>
</blockquote>
<h3 id="2、BeanDefinitionReader"><a href="#2、BeanDefinitionReader" class="headerlink" title="2、BeanDefinitionReader"></a>2、BeanDefinitionReader</h3><p>即Bean定义读取器。</p>
<p><strong>AnnotatedBeanDefinitionReader</strong>：可以直接把某个类转换为BeanDefinition，并且会解析该类上的注解，如下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(context);</span><br><span class="line"><span class="comment">// 将User.class解析为BeanDefinition</span></span><br><span class="line">annotatedBeanDefinitionReader.register(User.class);</span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>并且它能解析的注解是：@Conditional，**@Scope**、@Lazy、@Primary、@DependsOn、@Role、@Description</p>
<p><strong>XmlBeanDefinitionReader</strong>：可以解析标签，如下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(context);</span><br><span class="line"><span class="keyword">int</span> i = xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>ClassPathBeanDefinitionScanner</strong>：BeanDefinition的扫描器</p>
<blockquote>
<p>ClassPathBeanDefinitionScanner是扫描器，但是它的作用和BeanDefinitionReader类似，它可以进行扫描，扫描某个包路径，对扫描到的类进行解析，比如，扫描到的类上如果存在@Component注解，那么就会把这个类解析为一个BeanDefinition，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">context.refresh();</span><br><span class="line">ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(context);</span><br><span class="line">scanner.scan(<span class="string">&quot;com.zhouyu&quot;</span>);</span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;userService&quot;</span>));</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3、BeanFactory"><a href="#3、BeanFactory" class="headerlink" title="3、BeanFactory"></a>3、BeanFactory</h3><blockquote>
<p>BeanFactory表示Bean<strong>工厂</strong>，所以很明显，BeanFactory会负责创建Bean，并且提供获取Bean的API。而ApplicationContext是BeanFactory的一种，在Spring源码中，是这么定义的：ApplicationContext就是一个beanFactory，但是实现了更多的接口，比BeanFactory功能更丰富。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>（环境变量）, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">		<span class="title">MessageSource</span>（国际化）, <span class="title">ApplicationEventPublisher</span>（事件发布器）, <span class="title">ResourcePatternResolver</span>（解析某些资源） </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承了多个接口，说明有其它额外的功能。</p>
</blockquote>
<p><strong>DefaultListableBeanFactory</strong>：BeanFactory接口存在一个非常重要的实现类。<strong>也是非常核心的。具体重要性，随着后续课程会感受更深。所以，我们可以直接来使用DefaultListableBeanFactory</strong>，而不用使用ApplicationContext的某个实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">beanDefinition.setBeanClass(User.class);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line">System.out.println(beanFactory.getBean(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>DefaultListableBeanFactory的类继承实现结构</strong>：</p>
<p>   <img src="/2022/06/18/02-00-01-Spring%E4%B9%8B%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/stickPicture.png"></p>
<blockquote>
<ol>
<li>AliasRegistry：支持别名功能，一个名字可以对应多个别名</li>
<li>BeanDefinitionRegistry：可以注册、保存、移除、获取某个BeanDefinition</li>
<li>BeanFactory：Bean工厂，可以根据某个bean的名字、或类型、或别名获取某个Bean对象</li>
<li>SingletonBeanRegistry：可以直接注册、获取某个<strong>单例</strong>Bean</li>
<li>SimpleAliasRegistry：它是一个类，实现了AliasRegistry接口中所定义的功能，支持别名功能</li>
<li>ListableBeanFactory：在BeanFactory的基础上，增加了其他功能，可以获取所有BeanDefinition的beanNames，可以根据某个类型获取对应的beanNames，可以根据某个类型获取{类型：对应的Bean}的映射关系</li>
<li>HierarchicalBeanFactory：在BeanFactory的基础上，添加了获取父BeanFactory的功能</li>
<li>DefaultSingletonBeanRegistry：它是一个类，实现了SingletonBeanRegistry接口，拥有了直接注册、获取某个<strong>单例</strong>Bean的功能</li>
<li>ConfigurableBeanFactory：在HierarchicalBeanFactory和SingletonBeanRegistry的基础上，添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL表达式解析器（表示该BeanFactory可以解析EL表达式）、设置类型转化服务（表示该BeanFactory可以进行类型转化）、可以添加BeanPostProcessor（表示该BeanFactory支持Bean的后置处理器），可以合并BeanDefinition，可以销毁某个Bean等等功能</li>
<li>FactoryBeanRegistrySupport：支持了FactoryBean的功能</li>
<li>AutowireCapableBeanFactory：是直接继承了BeanFactory，在BeanFactory的基础上，支持在创建Bean的过程中能对Bean进行自动装配</li>
<li>AbstractBeanFactory：实现了ConfigurableBeanFactory接口，继承了FactoryBeanRegistrySupport，这个BeanFactory的功能已经很全面了，但是不能自动装配和获取beanNames</li>
<li>ConfigurableListableBeanFactory：继承了ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory</li>
<li>AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory，拥有了自动装配的功能</li>
<li>DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口，所以DefaultListableBeanFactory的功能很强大</li>
</ol>
</blockquote>
<h3 id="4、ApplicationContext"><a href="#4、ApplicationContext" class="headerlink" title="4、ApplicationContext"></a>4、ApplicationContext</h3><p>ApplicationContext是个接口，实际上也是一个BeanFactory，不过比BeanFactory更加强大，比如：</p>
<ol>
<li>HierarchicalBeanFactory：拥有获取父BeanFactory的功能</li>
<li>ListableBeanFactory：拥有获取beanNames的功能</li>
<li>ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）</li>
<li>EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</li>
<li>ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</li>
<li>MessageSource：拥有国际化功能</li>
</ol>
<p><strong>AnnotationConfigApplicationContext</strong></p>
<p><strong>ClassPathXmlApplicationContext</strong></p>
<h3 id="5、国际化"><a href="#5、国际化" class="headerlink" title="5、国际化"></a>5、国际化</h3><ul>
<li>先定义一个MessageSource:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">	messageSource.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新建messages.properties、messages_en.properties文件</p>
<p><img src="/2022/06/18/02-00-01-Spring%E4%B9%8B%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image-20220618235156151.png" alt="image-20220618235156151"></p>
</li>
<li><p>通过ApplicationContext 使用国际化功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getMessage(<span class="string">&quot;test&quot;</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Locale(<span class="string">&quot;en_CN&quot;</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、资源加载"><a href="#6、资源加载" class="headerlink" title="6、资源加载"></a>6、资源加载</h3><p>ApplicationContext还拥有资源加载的功能，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"><span class="comment">// 要加 file:// 前缀</span></span><br><span class="line">Resource resource = context.getResource(<span class="string">&quot;file://D:\\IdeaProjects\\spring-framework\\luban\\src\\main\\java\\com\\luban\\entity\\User.java&quot;</span>);</span><br><span class="line">System.out.println(resource.contentLength());</span><br><span class="line">resource.getFile();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">Resource resource = context.getResource(<span class="string">&quot;file://D:\\IdeaProjects\\spring-framework-5.3.10\\tuling\\src\\main\\java\\com\\zhouyu\\service\\UserService.java&quot;</span>);</span><br><span class="line">System.out.println(resource.contentLength()); <span class="comment">// 字符个数</span></span><br><span class="line">System.out.println(resource.getFilename());</span><br><span class="line">Resource resource1 = context.getResource(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(resource1.contentLength());</span><br><span class="line">System.out.println(resource1.getURL());</span><br><span class="line">Resource resource2 = context.getResource(<span class="string">&quot;classpath:spring.xml&quot;</span>);</span><br><span class="line">System.out.println(resource2.contentLength());</span><br><span class="line">System.out.println(resource2.getURL());</span><br><span class="line"></span><br><span class="line">### 还可以一次性获取多个</span><br><span class="line">Resource[] resources = context.getResources(<span class="string">&quot;classpath:com/zhouyu/*.class&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">	System.out.println(resource.contentLength());</span><br><span class="line">	System.out.println(resource.getFilename());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、获取运行时环境"><a href="#7、获取运行时环境" class="headerlink" title="7、获取运行时环境"></a>7、<strong>获取运行时环境</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">Map&lt;String, Object&gt; systemEnvironment = context.getEnvironment().getSystemEnvironment(); <span class="comment">// 获得的是操作系统的环境变量</span></span><br><span class="line">System.out.println(systemEnvironment);</span><br><span class="line">System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; systemProperties = context.getEnvironment().getSystemProperties();</span><br><span class="line">System.out.println(systemProperties);</span><br><span class="line">System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">MutablePropertySources propertySources = context.getEnvironment().getPropertySources(); <span class="comment">//包含所有的环境变量值    获取当前运行时 -D指定的变量</span></span><br><span class="line">System.out.println(propertySources);</span><br><span class="line">System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;NO_PROXY&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;sun.jnu.encoding&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;zhouyu&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>可以利用 <code>@PropertySource("classpath:spring.properties")</code>来使得某个properties文件中的参数添加到运行时环境中</p>
<h3 id="8、事件发布"><a href="#8、事件发布" class="headerlink" title="8、事件发布"></a>8、<strong>事件发布</strong></h3><ul>
<li><p>先定义一个事件监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationListener <span class="title">applicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ApplicationListener() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;接收到了一个事件&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后发布一个事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以定义一个事件发布器</span></span><br><span class="line">ApplicationEventPublisher publisher</span><br><span class="line"><span class="comment">// 也可以使用ApplicationContext </span></span><br><span class="line">context.publishEvent(<span class="string">&quot;kkk&quot;</span>);</span><br><span class="line"></span><br><span class="line">## 结果：</span><br><span class="line">接收到了一个事件org.springframework.context.annotation.AnnotationConfigApplicationContext@5305068a, started on Sat Jun <span class="number">18</span> <span class="number">18</span>:<span class="number">49</span>:<span class="number">28</span> CST <span class="number">2022</span></span><br><span class="line">接收到了一个事件org.springframework.context.annotation.AnnotationConfigApplicationContext@5305068a, started on Sat Jun <span class="number">18</span> <span class="number">18</span>:<span class="number">49</span>:<span class="number">28</span> CST <span class="number">2022</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9、类型转化"><a href="#9、类型转化" class="headerlink" title="9、类型转化"></a>9、类型转化</h3><p>例子，比如如下代码要进行属性注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;zhouyu&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> User user;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为user是对象，配置的是string，所以需要类型转换</p>
<ul>
<li><p><strong>PropertyEditor</strong></p>
<ul>
<li><p>jdk提供的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		user.setName(text);</span><br><span class="line">		<span class="keyword">this</span>.setValue(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##使用如下：</span><br><span class="line">StringToUserPropertyEditor propertyEditor = <span class="keyword">new</span> StringToUserPropertyEditor();</span><br><span class="line">propertyEditor.setAsText(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">User value = (User) propertyEditor.getValue();</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>

<ul>
<li> Spring中注册PropertyEditor</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomEditorConfigurer <span class="title">customEditorConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CustomEditorConfigurer customEditorConfigurer = <span class="keyword">new</span> CustomEditorConfigurer();</span><br><span class="line">	Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; propertyEditorMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示StringToUserPropertyEditor可以将String转化成User类型，在Spring源码中，如果发现当前对象是String，而需要的类型是User，就会使用该PropertyEditor来做类型转化</span></span><br><span class="line">	propertyEditorMap.put(User.class, StringToUserPropertyEditor.class);</span><br><span class="line">	customEditorConfigurer.setCustomEditors(propertyEditorMap);</span><br><span class="line">	<span class="keyword">return</span> customEditorConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>ConversionService</strong></p>
<ul>
<li><p>spring 提供的，它比PropertyEditor更强大</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// 适配的类型  比如这个表示 String  转 User  符合条件才会转化</span></span><br><span class="line">		<span class="keyword">return</span> sourceType.getType().equals(String.class) &amp;&amp; targetType.getType().equals(User.class);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(String.class, User.class));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		user.setName((String)source);</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 具体使用：</span><br><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToUserConverter());</span><br><span class="line">User value = conversionService.convert(<span class="string">&quot;1&quot;</span>, User.class);</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure></li>
<li><p>如何向Spring中注册ConversionService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">	conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="keyword">new</span> StringToUserConverter()));</span><br><span class="line">	<span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>TypeConverter整合</strong></p>
<p>整合了PropertyEditor和ConversionService的功能，是Spring内部用的【上述两种方式的整合】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleTypeConverter typeConverter = <span class="keyword">new</span> SimpleTypeConverter();</span><br><span class="line">typeConverter.registerCustomEditor(User.class, <span class="keyword">new</span> StringToUserPropertyEditor());<span class="comment">// 【jdk的方式】</span></span><br><span class="line"><span class="comment">//typeConverter.setConversionService(conversionService); // 【spring提供的方式】</span></span><br><span class="line">User value = typeConverter.convertIfNecessary(<span class="string">&quot;1&quot;</span>, User.class);</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10、OrderComparator"><a href="#10、OrderComparator" class="headerlink" title="10、OrderComparator"></a>10、<strong>OrderComparator</strong></h2><blockquote>
<p>OrderComparator是Spring所提供的一种比较器，可以用来根据@Order注解或实现Ordered接口来执行值进行笔记，从而可以进行排序。</p>
</blockquote>
<p>如以下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 使用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A(); <span class="comment">// order=3</span></span><br><span class="line">		B b = <span class="keyword">new</span> B(); <span class="comment">// order=2</span></span><br><span class="line">		OrderComparator comparator = <span class="keyword">new</span> OrderComparator();</span><br><span class="line">		System.out.println(comparator.compare(a, b));  <span class="comment">// 1</span></span><br><span class="line">		List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list.add(a);</span><br><span class="line">		list.add(b);</span><br><span class="line">		<span class="comment">// 按order值升序排序</span></span><br><span class="line">		list.sort(comparator);</span><br><span class="line">		System.out.println(list);  <span class="comment">// B，A</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，Spring中还提供了一个OrderComparator的子类：<strong>AnnotationAwareOrderComparator</strong>，它支持用@Order来指定order值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 具体使用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A(); <span class="comment">// order=3</span></span><br><span class="line">		B b = <span class="keyword">new</span> B(); <span class="comment">// order=2</span></span><br><span class="line">		AnnotationAwareOrderComparator comparator = <span class="keyword">new</span> AnnotationAwareOrderComparator();</span><br><span class="line">		System.out.println(comparator.compare(a, b)); <span class="comment">// 1</span></span><br><span class="line">		List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list.add(a);</span><br><span class="line">		list.add(b);</span><br><span class="line">		<span class="comment">// 按order值升序排序</span></span><br><span class="line">		list.sort(comparator);</span><br><span class="line">		System.out.println(list); <span class="comment">// B，A</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11、BeanPostProcessor"><a href="#11、BeanPostProcessor" class="headerlink" title="11、BeanPostProcessor"></a>11、<strong>BeanPostProcessor</strong></h3><blockquote>
<p>BeanPostProcess表示Bean的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p>
</blockquote>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;userService&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;初始化前&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;userService&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;初始化后&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个BeanPostProcessor可以在<strong>任意一个Bean</strong>的<strong>初始化之前</strong>以及<strong>初始化之后</strong>去额外的做一些用户自定义的逻辑，当然，我们可以通过判断beanName来进行针对性处理（针对某个Bean，或某部分Bean）。</p>
<p>我们可以通过定义BeanPostProcessor来干涉Spring创建Bean的过程。</p>
</blockquote>
<h3 id="12、BeanFactoryPostProcessor"><a href="#12、BeanFactoryPostProcessor" class="headerlink" title="12、BeanFactoryPostProcessor"></a>12、<strong>BeanFactoryPostProcessor</strong></h3><blockquote>
<p>BeanFactoryPostProcessor表示Bean工厂的后置处理器，其实和BeanPostProcessor类似，BeanPostProcessor是干涉Bean的创建过程，BeanFactoryPostProcessor是干涉BeanFactory的创建过程。</p>
</blockquote>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;加工beanFactory&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在postProcessBeanFactory()方法中对BeanFactory进行加工</p>
</blockquote>
<h3 id="13、FactoryBean"><a href="#13、FactoryBean" class="headerlink" title="13、FactoryBean"></a>13、<strong>FactoryBean</strong></h3><p>我们可以通过BeanPostPorcessor来干涉Spring创建Bean的过程，但是如果我们想一个Bean完完全全由我们来创造，也是可以的，比如通过FactoryBean。</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">		<span class="keyword">return</span> userService;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> UserService.class;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">注：获取bean的时候 通过加在beanName之前加&amp;可以获取FactoryBean类的 容器中的bean</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上面这段代码，我们自己创造了一个UserService对象，并且它将成为Bean。但是通过这种方式创造出来的UserService的Bean，<strong>只会经过初始化后</strong>，其他Spring的生命周期步骤是不会经过的，比如依赖注入。</p>
<p>可能会有疑问？通过@Bean也可以自己生成一个对象作为Bean，那么和FactoryBean的区别是什么呢？其实在很多场景下他俩是可以替换的，但是站在原理层面来说的，区别很明显，@Bean定义的Bean是会经过完整的Bean生命周期的。</p>
</blockquote>
<h3 id="14、ExcludeFilter和IncludeFilter"><a href="#14、ExcludeFilter和IncludeFilter" class="headerlink" title="14、ExcludeFilter和IncludeFilter"></a>14、<strong>ExcludeFilter和IncludeFilter</strong></h3><blockquote>
<p>这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示<strong>排除过滤器</strong>，IncludeFilter表示<strong>包含过滤器</strong>。</p>
</blockquote>
<ul>
<li><p><strong>ExcludeFilter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.zhouyu&quot;,</span></span><br><span class="line"><span class="meta">		excludeFilters = &#123;@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">            	type = FilterType.ASSIGNABLE_TYPE, </span></span><br><span class="line"><span class="meta">            	classes = UserService.class)&#125;.)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">## 注：以下配置，表示扫描com.zhouyu这个包下面的所有类，但是排除UserService类，也就是就算它上面有<span class="meta">@Component</span>注解也不会成为Bean</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IncludeFilter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.zhouyu&quot;,</span></span><br><span class="line"><span class="meta">		includeFilters = &#123;@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">            	type = FilterType.ASSIGNABLE_TYPE, </span></span><br><span class="line"><span class="meta">            	classes = UserService.class)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">## 注：以下配置，就算UserService类上没有<span class="meta">@Component</span>注解，它也会被扫描成为一个Bean</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FilterType分为：</p>
<ol>
<li>ANNOTATION：表示是否包含某个注解</li>
<li>ASSIGNABLE_TYPE：表示是否是某个类</li>
<li>ASPECTJ：表示否是符合某个Aspectj表达式</li>
<li>REGEX：表示是否符合某个正则表达式</li>
<li>CUSTOM：自定义</li>
</ol>
<p>在Spring的扫描逻辑中，默认会添加一个AnnotationTypeFilter给includeFilters，表示默认情况下Spring扫描过程中会认为类上有@Component注解的就是Bean。</p>
</blockquote>
</li>
</ul>
<h3 id="15、MetadataReader【元数据读取器】、ClassMetadata【类的元数据】、AnnotationMetadata【注解元数据，一个类上面有哪些注解】"><a href="#15、MetadataReader【元数据读取器】、ClassMetadata【类的元数据】、AnnotationMetadata【注解元数据，一个类上面有哪些注解】" class="headerlink" title="15、MetadataReader【元数据读取器】、ClassMetadata【类的元数据】、AnnotationMetadata【注解元数据，一个类上面有哪些注解】"></a>15、<strong>MetadataReader【元数据读取器】、ClassMetadata【类的元数据】、AnnotationMetadata【注解元数据，一个类上面有哪些注解】</strong></h3><blockquote>
<p>在Spring中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数据，所以Spring中对类的元数据做了抽象，并提供了一些工具类。</p>
<p>MetadataReader表示类的元数据读取器，默认实现类为<strong>SimpleMetadataReader</strong>。</p>
</blockquote>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   SimpleMetadataReaderFactory simpleMetadataReaderFactory = <span class="keyword">new</span> SimpleMetadataReaderFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造一个MetadataReader</span></span><br><span class="line">   MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(<span class="string">&quot;com.zhouyu.service.UserService&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 得到一个ClassMetadata，并获取了类名</span></span><br><span class="line">   ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line"></span><br><span class="line">   System.out.println(classMetadata.getClassName());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取一个AnnotationMetadata，并获取类上的注解信息</span></span><br><span class="line">   AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">   System.out.println(annotationMetadata.hasMetaAnnotation(Component.class.getName())); <span class="comment">// true  可以看到@service注解里面有没有使用@Component注解</span></span><br><span class="line">   System.out.println(annotationMetadata.hasAnnotation(Component.class.getName())); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String annotationType : annotationMetadata.getAnnotationTypes()) &#123;</span><br><span class="line">      System.out.println(annotationType);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## UserService</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Value(&quot;zhouyu&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">public</span> OrderService orderService;</span><br><span class="line"><span class="comment">// @Autowired</span></span><br><span class="line"><span class="comment">// private JdbcTemplate jdbcTemplate;</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    jdbcTemplate.execute(&quot;INSERT INTO `mysql_test`.`product`(`id`, `product_name`, `stock`, `version`) VALUES (3, &#x27;元旦大礼包&#x27;, 5, 0);&quot;);</span></span><br><span class="line"><span class="comment">//    throw new NullPointerException();</span></span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      a();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      context = applicationContext;</span><br><span class="line">      System.out.println(context.getMessage(<span class="string">&quot;test&quot;</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Locale(<span class="string">&quot;en&quot;</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 几个类</span><br><span class="line">## 读取器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment">    * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 类元数据</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the underlying class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class represents an interface.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class represents an annotation.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class is marked as abstract.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class represents a concrete class,</span></span><br><span class="line"><span class="comment">    * i.e. neither an interface nor an abstract class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isConcrete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class is marked as &#x27;final&#x27;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isFinal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether the underlying class is independent, i.e. whether</span></span><br><span class="line"><span class="comment">    * it is a top-level class or a nested class (static inner class) that</span></span><br><span class="line"><span class="comment">    * can be constructed independently from an enclosing class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isIndependent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class is declared within an enclosing</span></span><br><span class="line"><span class="comment">    * class (i.e. the underlying class is an inner/nested class or a</span></span><br><span class="line"><span class="comment">    * local class within a method).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this method returns &#123;<span class="doctag">@code</span> false&#125;, then the underlying</span></span><br><span class="line"><span class="comment">    * class is a top-level class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasEnclosingClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the enclosing class of the underlying class,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; if the underlying class is a top-level class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getEnclosingClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether the underlying class has a super class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasSuperClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the super class of the underlying class,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; if there is no super class defined.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getSuperClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the names of all interfaces that the underlying class</span></span><br><span class="line"><span class="comment">    * implements, or an empty array if there are none.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] getInterfaceNames();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the names of all classes declared as members of the class represented by</span></span><br><span class="line"><span class="comment">    * this ClassMetadata object. This includes public, protected, default (package)</span></span><br><span class="line"><span class="comment">    * access, and private classes and interfaces declared by the class, but excludes</span></span><br><span class="line"><span class="comment">    * inherited classes and interfaces. An empty array is returned if no member classes</span></span><br><span class="line"><span class="comment">    * or interfaces exist.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] getMemberClassNames();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，SimpleMetadataReader去解析类时，使用的<strong>ASM技术【解析字节码】</strong>。</p>
<p>为什么要使用ASM技术，Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，那如果在Spring启动时就把这些类全部加载进JVM了，这样不太好，所以使用了ASM技术。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring核心概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之启动过程源码解析</title>
    <url>/2022/06/30/02-00-06-Spring%E4%B9%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="一、Spring之启动过程"><a href="#一、Spring之启动过程" class="headerlink" title="一、Spring之启动过程"></a>一、Spring之启动过程</h1><blockquote>
<p>spring 启动主要经过以下几个方法，以AnnotationConfigApplicationContext 容器类为例</p>
<ul>
<li><p>AnnotationConfigApplicationContext构造方法</p>
</li>
<li><p>register(annotatedClasses)</p>
</li>
<li><p>refresh()</p>
<ul>
<li><p>prepareRefresh()</p>
<blockquote>
<p>做一些准备/检查工作</p>
</blockquote>
</li>
<li><p>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); </p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获得刷新的beanFactory</span><br><span class="line">对于AnnotationConfigApplicationContext，作用：</span><br><span class="line">1.调用org.springframework.context.support.GenericApplicationContext.refreshBeanFactory，</span><br><span class="line">只是指定了SerializationId</span><br><span class="line">2.直接返回beanFactory(不用创建，容器中已存在)</span><br><span class="line"> 对于ClassPathXmlApplicationContext，作用：</span><br><span class="line">1.调用AbstractRefreshableApplicationContext.refreshBeanFactory</span><br><span class="line">2.如果存在beanFactory，先销毁单例bean，关闭beanFactory，再创建beanFactory</span><br><span class="line">3.注册传入的spring的xml配置文件中配置的bean，注册到beanFactory</span><br><span class="line">4.将beanFactory赋值给容器，返回beanFactory</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>prepareBeanFactory(beanFactory)</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">准备bean工厂： 指定beanFactory的类加载器， 添加后置处理器，注册缺省环境bean等</span><br><span class="line">beanFactory添加了2个后置处理器 ApplicationContextAwareProcessor, ApplicationListenerDetector (new )</span><br><span class="line">准备BeanFactory</span><br><span class="line">1. 设置BeanFactory的类加载器、SpringEL表达式解析器、类型转化注册器</span><br><span class="line">2. 添加三个BeanPostProcessor，注意是具体的BeanPostProcessor实例对象</span><br><span class="line">3. 记录ignoreDependencyInterface</span><br><span class="line">4. 记录ResolvableDependency</span><br><span class="line">5. 添加三个单例Bean</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>postProcessBeanFactory(beanFactory)</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空方法</span><br><span class="line">允许在上下文的子类中对beanFactory进行后处理</span><br><span class="line">比如 AbstractRefreshableWebApplicationContext.postProcessBeanFactory</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>invokeBeanFactoryPostProcessors(beanFactory)</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.通过beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)</span><br><span class="line">  拿到ConfigurationClassPostProcessor</span><br><span class="line">2.通过ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry，注册所有注解配置的bean</span><br><span class="line">注册的顺序： @ComponentScan&gt;实现ImportSelector&gt;方法bean&gt;@ImportResource(&quot;spring.xml&quot;)</span><br><span class="line"> &gt; 实现 ImportBeanDefinitionRegistrar  (相对的顺序，都在同一个配置类上配置)</span><br><span class="line">3. 调用ConfigurationClassPostProcessor#postProcessBeanFactory</span><br><span class="line"> 增强@Configuration修饰的配置类  AppConfig---&gt;AppConfig$$EnhancerBySpringCGLIB</span><br><span class="line">(可以处理内部方法bean之间的调用，防止多例)</span><br><span class="line"> 添加了后置处理器 ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor (new)</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>registerBeanPostProcessors(beanFactory)</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注册拦截bean创建的后置处理器：</span><br><span class="line">1.添加Spring自身的：  BeanPostProcessorChecker （new）  以及注册了beanDefinition的两个</span><br><span class="line"> CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor</span><br><span class="line"> 重新添加ApplicationListenerDetector(new ) ，删除旧的，移到处理器链末尾</span><br><span class="line">2.用户自定义的后置处理器</span><br><span class="line">注册了beanDefinition的会通过 beanFactory.getBean(ppName, BeanPostProcessor.class) 获取后置处理器</span><br><span class="line">将扫描到的BeanPostProcessors实例化并排序，并添加到BeanFactory的beanPostProcessors属性中去</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>initMessageSource()</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置ApplicationContext的MessageSource，要么是用户设置的，要么是DelegatingMessageSource</span><br><span class="line">支持国际化</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>initApplicationEventMulticaster()</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化事件多播器</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>onRefresh()</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空方法   子类实现： springboot  内嵌容器  ioc启动带动tomcat启动</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>registerListeners()</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把定义的ApplicationListener的Bean对象，设置到ApplicationContext中去，并执行在此之前所发布的事件</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>finishBeanFactoryInitialization(beanFactory)</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实例化所有剩余的(非懒加载)单例。</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>finishRefresh()</p>
<blockquote>
<p>完成refresh方法</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="1-1-BeanFactoryPostProcessor"><a href="#1-1-BeanFactoryPostProcessor" class="headerlink" title="1.1 BeanFactoryPostProcessor"></a>1.1 BeanFactoryPostProcessor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">  beanDefinition.setAutowireCandidate(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码，就利用了BeanFactoryPostProcessor来拿到BeanFactory，然后获取BeanFactory内的某个BeanDefinition对象并进行修改，注意这一步是发生在Spring启动时，创建单例Bean之前的，所以此时对BeanDefinition就行修改是会生效的。<br>​</p>
<p>注意：在ApplicationContext内部有一个核心的DefaultListableBeanFactory，它实现了ConfigurableListableBeanFactory和BeanDefinitionRegistry接口，所以ApplicationContext和DefaultListableBeanFactory是可以注册BeanDefinition的，但是ConfigurableListableBeanFactory是不能注册BeanDefinition的，只能获取BeanDefinition，然后做修改。</p>
<p>所以Spring还提供了一个BeanFactoryPostProcessor的子接口：<strong>BeanDefinitionRegistryPostProcessor</strong></p>
</blockquote>
<h2 id="1-2BeanDefinitionRegistryPostProcessor"><a href="#1-2BeanDefinitionRegistryPostProcessor" class="headerlink" title="1.2BeanDefinitionRegistryPostProcessor"></a>1.2BeanDefinitionRegistryPostProcessor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">  beanDefinition.setBeanClass(User.class);</span><br><span class="line">  registry.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">  beanDefinition.setAutowireCandidate(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以看到BeanDefinitionRegistryPostProcessor继承了BeanFactoryPostProcessor接口，并新增了一个方法，注意方法的参数为BeanDefinitionRegistry，所以如果我们提供一个类来实现BeanDefinitionRegistryPostProcessor，那么在postProcessBeanDefinitionRegistry()方法中就可以注册BeanDefinition了</p>
</blockquote>
<h2 id="1-3-refresh-底层原理流程"><a href="#1-3-refresh-底层原理流程" class="headerlink" title="1.3 refresh()底层原理流程"></a>1.3 refresh()底层原理流程</h2><blockquote>
<p>下面以AnnotationConfigApplicationContext为例子，来介绍refresh的底层原理。</p>
<ol>
<li><p>在调用AnnotationConfigApplicationContext的构造方法之前，会调用父类GenericApplicationContext的无参构造方法，会构造一个BeanFactory，为<strong>DefaultListableBeanFactory</strong>。</p>
</li>
<li><p>构造AnnotatedBeanDefinitionReader（</p>
<p>主要作用添加一些基础的PostProcessor，同时可以通过reader进行BeanDefinition的注册</p>
<p>），同时对BeanFactory进行设置和添加</p>
<p>PostProcessor</p>
<p>（后置处理器）</p>
<ol>
<li>设置dependencyComparator：AnnotationAwareOrderComparator，它是一个Comparator，是用来进行排序的，会获取某个对象上的<strong>Order注解</strong>或者通过实现<strong>Ordered接口</strong>所定义的值进行排序，在日常开发中可以利用这个类来进行排序。</li>
<li>设置autowireCandidateResolver：ContextAnnotationAutowireCandidateResolver，用来解析某个Bean能不能进行自动注入，比如某个Bean的autowireCandidate属性是否等于true</li>
<li>向BeanFactory中添加<strong>ConfigurationClassPostProcessor</strong>对应的BeanDefinition，它是一个BeanDefinitionRegistryPostProcessor，并且实现了PriorityOrdered接口</li>
<li>向BeanFactory中添加<strong>AutowiredAnnotationBeanPostProcessor</strong>对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessorAdapter，MergedBeanDefinitionPostProcessor</li>
<li>向BeanFactory中添加CommonAnnotationBeanPostProcessor对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessor，InitDestroyAnnotationBeanPostProcessor</li>
<li>向BeanFactory中添加EventListenerMethodProcessor对应的BeanDefinition，它是一个BeanFactoryPostProcessor，SmartInitializingSingleton</li>
<li>向BeanFactory中添加DefaultEventListenerFactory对应的BeanDefinition，它是一个EventListenerFactory</li>
</ol>
</li>
<li><p>构造ClassPathBeanDefinitionScanner（</p>
<p>主要作用可以用来扫描得到并注册BeanDefinition</p>
<p>），同时进行设置：</p>
<ol>
<li>设置<strong>this.includeFilters = AnnotationTypeFilter(Component.class)</strong></li>
<li>设置environment</li>
<li>设置resourceLoader</li>
</ol>
</li>
<li><p>利用reader注册AppConfig为BeanDefinition，类型为AnnotatedGenericBeanDefinition</p>
</li>
<li><p><strong>接下来就是调用refresh方法</strong></p>
</li>
<li><p>prepareRefresh()：</p>
<ol>
<li>记录启动时间</li>
<li>可以允许子容器设置一些内容到Environment中</li>
<li>验证Environment中是否包括了必须要有的属性</li>
</ol>
</li>
<li><p>obtainFreshBeanFactory()：进行BeanFactory的refresh，在这里会去调用子类的refreshBeanFactory方法，具体子类是怎么刷新的得看子类，然后再调用子类的getBeanFactory方法，重新得到一个BeanFactory</p>
</li>
<li><p>prepareBeanFactory(beanFactory)：</p>
<ol>
<li><p>设置beanFactory的类加载器</p>
</li>
<li><p>设置表达式解析器：StandardBeanExpressionResolver，用来解析Spring中的表达式</p>
</li>
<li><p>添加PropertyEditorRegistrar：ResourceEditorRegistrar，PropertyEditor类型转化器注册器，用来注册一些默认的PropertyEditor</p>
</li>
<li><p>添加一个Bean的后置处理器：ApplicationContextAwareProcessor，是一个BeanPostProcessor，用来执行EnvironmentAware、ApplicationEventPublisherAware等回调方法</p>
</li>
<li><p>添加</p>
<p>ignoredDependencyInterface</p>
<p>：可以向这个属性中添加一些接口，如果某个类实现了这个接口，并且这个类中的某些set方法在接口中也存在，那么这个set方法在自动注入的时候是不会执行的，比如EnvironmentAware这个接口，如果某个类实现了这个接口，那么就必须实现它的setEnvironment方法，而这是一个set方法，和Spring中的autowire是冲突的，那么Spring在自动注入时是不会调用setEnvironment方法的，而是等到回调Aware接口时再来调用（注意，这个功能仅限于xml的autowire，@Autowired注解是忽略这个属性的）</p>
<ol>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationContextAware</li>
<li>另外其实在构造BeanFactory的时候就已经提前添加了另外三个：</li>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
</ol>
</li>
<li><p>添加</p>
<p>resolvableDependencies</p>
<p>：在byType进行依赖注入时，会先从这个属性中根据类型找bean</p>
<ol>
<li>BeanFactory.class：当前BeanFactory对象</li>
<li>ResourceLoader.class：当前ApplicationContext对象</li>
<li>ApplicationEventPublisher.class：当前ApplicationContext对象</li>
<li>ApplicationContext.class：当前ApplicationContext对象</li>
</ol>
</li>
<li><p>添加一个Bean的后置处理器：ApplicationListenerDetector，是一个BeanPostProcessor，用来判断某个Bean是不是ApplicationListener，如果是则把这个Bean添加到ApplicationContext中去，注意一个ApplicationListener只能是单例的</p>
</li>
<li><p>添加一个Bean的后置处理器：LoadTimeWeaverAwareProcessor，是一个BeanPostProcessor，用来判断某个Bean是不是实现了LoadTimeWeaverAware接口，如果实现了则把ApplicationContext中的loadTimeWeaver回调setLoadTimeWeaver方法设置给该Bean。</p>
</li>
<li><p>添加一些单例bean到单例池：</p>
<ol>
<li>“environment”：Environment对象</li>
<li>“systemProperties”：System.getProperties()返回的Map对象</li>
<li>“systemEnvironment”：System.getenv()返回的Map对象</li>
</ol>
</li>
</ol>
</li>
<li><p>postProcessBeanFactory(beanFactory) ： 提供给AbstractApplicationContext的子类进行扩展，具体的子类，可以继续向BeanFactory中再添加一些东西</p>
</li>
<li><p>invokeBeanFactoryPostProcessors(beanFactory)：</p>
<p>执行BeanFactoryPostProcessor</p>
<ol>
<li>此时在BeanFactory中会存在一个BeanFactoryPostProcessor：<strong>ConfigurationClassPostProcessor</strong>，它也是一个<strong>BeanDefinitionRegistryPostProcessor</strong></li>
<li><strong>第一阶段</strong></li>
<li>从BeanFactory中找到类型为BeanDefinitionRegistryPostProcessor的beanName，也就是<strong>ConfigurationClassPostProcessor</strong>， 然后调用BeanFactory的getBean方法得到实例对象</li>
<li>执行**ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()**方法:<ol>
<li>解析AppConfig类</li>
<li>扫描得到BeanDefinition并注册</li>
<li>解析@Import，@Bean等注解得到BeanDefinition并注册</li>
<li>详细的看另外的笔记，专门分析了<strong>ConfigurationClassPostProcessor是如何工作的</strong></li>
<li>在这里，我们只需要知道在这一步会去得到BeanDefinition，而这些BeanDefinition中可能存在BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor，所以执行完ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()方法后，还需要继续执行其他BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
</ol>
</li>
<li>执行其他BeanDefinitionRegistryPostProcessor的**postProcessBeanDefinitionRegistry()**方法</li>
<li>执行所有BeanDefinitionRegistryPostProcessor的**postProcessBeanFactory()**方法</li>
<li><strong>第二阶段</strong></li>
<li>从BeanFactory中找到类型为BeanFactoryPostProcessor的beanName，而这些BeanFactoryPostProcessor包括了上面的BeanDefinitionRegistryPostProcessor</li>
<li>执行还没有执行过的BeanFactoryPostProcessor的**postProcessBeanFactory()**方法</li>
</ol>
</li>
<li><p>到此，所有的BeanFactoryPostProcessor的逻辑都执行完了，主要做的事情就是得到BeanDefinition并注册到BeanFactory中</p>
</li>
<li><p>registerBeanPostProcessors(beanFactory)：因为上面的步骤完成了扫描，这个过程中程序员可能自己定义了一些BeanPostProcessor，在这一步就会把BeanFactory中所有的BeanPostProcessor找出来并实例化得到一个对象，并添加到BeanFactory中去（属性<strong>beanPostProcessors</strong>），最后再重新添加一个ApplicationListenerDetector对象（之前其实就添加了过，这里是为了把ApplicationListenerDetector移动到最后）</p>
</li>
<li><p>initMessageSource()：如果BeanFactory中存在一个叫做”<strong>messageSource</strong>“的BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的messageSource属性，让ApplicationContext拥有<strong>国际化</strong>的功能</p>
</li>
<li><p>initApplicationEventMulticaster()：如果BeanFactory中存在一个叫做”<strong>applicationEventMulticaster</strong>“的BeanDefinition，那么就会把这个Bean对象创建出来并赋值给ApplicationContext的applicationEventMulticaster属性，让ApplicationContext拥有<strong>事件发布</strong>的功能</p>
</li>
<li><p>onRefresh()：提供给AbstractApplicationContext的子类进行扩展，没用</p>
</li>
<li><p>registerListeners()：从BeanFactory中获取ApplicationListener类型的beanName，然后添加到ApplicationContext中的事件广播器<strong>applicationEventMulticaster</strong>中去，到这一步因为FactoryBean还没有调用getObject()方法生成Bean对象，所以这里要在根据类型找一下ApplicationListener，记录一下对应的beanName</p>
</li>
<li><p>finishBeanFactoryInitialization(beanFactory)：完成BeanFactory的初始化，主要就是<strong>实例化非懒加载的单例Bean</strong>，单独的笔记去讲。</p>
</li>
<li><p>finishRefresh()：BeanFactory的初始化完后，就到了Spring启动的最后一步了</p>
</li>
<li><p>设置ApplicationContext的lifecycleProcessor，默认情况下设置的是DefaultLifecycleProcessor</p>
</li>
<li><p>调用lifecycleProcessor的onRefresh()方法，如果是DefaultLifecycleProcessor，那么会获取所有类型为Lifecycle的Bean对象，然后调用它的start()方法，这就是ApplicationContext的生命周期扩展机制</p>
</li>
<li><p>发布<strong>ContextRefreshedEvent</strong>事件</p>
</li>
</ol>
</blockquote>
<h2 id="1-4执行BeanFactoryPostProcessor"><a href="#1-4执行BeanFactoryPostProcessor" class="headerlink" title="1.4执行BeanFactoryPostProcessor"></a>1.4执行BeanFactoryPostProcessor</h2><p>过程如下：</p>
<blockquote>
<ol>
<li>执行通过ApplicationContext添加进来的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行BeanFactory中实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行BeanFactory中实现了Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行BeanFactory中其他的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li>
<li>执行上面所有的BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行通过ApplicationContext添加进来的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行BeanFactory中实现了PriorityOrdered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行BeanFactory中实现了Ordered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
<li>执行BeanFactory中其他的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li>
</ol>
</blockquote>
<h2 id="1-5Lifecycle的使用"><a href="#1-5Lifecycle的使用" class="headerlink" title="1.5Lifecycle的使用"></a>1.5Lifecycle的使用</h2><blockquote>
<p>作用 主要用在ioc容器生命周期内</p>
</blockquote>
<p>代码示例如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuLifecycle</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">  isRunning = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要触发stop()，要调用context.close()，或者注册关闭钩子（context.registerShutdownHook();）</span></span><br><span class="line">  System.out.println(<span class="string">&quot;停止&quot;</span>);</span><br><span class="line">  isRunning = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之AOP底层源码解析</title>
    <url>/2022/08/14/02-00-08-Spring%E4%B9%8BAOP%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Spring-AOP底层逻辑"><a href="#Spring-AOP底层逻辑" class="headerlink" title="Spring AOP底层逻辑"></a>Spring AOP底层逻辑</h1><h2 id="1、动态代理"><a href="#1、动态代理" class="headerlink" title="1、动态代理"></a>1、动态代理</h2><blockquote>
<p>代理模式的解释：为<strong>其他对象</strong>提供一种<strong>代理</strong>以控制对这个对象的访问，增强一个类中的某个方法，对程序进行扩展。比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span>  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cglib动态代理</li>
</ul>
<p><strong>不修改UserService类的源码</strong>前提下，给test()增加额外逻辑，那么就可以使用动态代理机制来创建UserService对象</p>
<blockquote>
<p>得到的都是UserService对象，但是执行test()方法时的效果却不一样了，这就是代理所带来的效果。</p>
<p>上面是通过cglib来实现的代理对象的创建，是基于<strong>父子类</strong>的，被代理类（UserService）是父类，代理类是子类，代理对象就是代理类的实例对象，代理类是由cglib创建的，对于程序员来说不用关心。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line"><span class="comment">// 通过cglib技术</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(UserService.class);</span><br><span class="line"><span class="comment">// 定义额外逻辑，也就是代理逻辑</span></span><br><span class="line">enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o<span class="comment">/**代理后的对象*/</span>, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">		Object result = methodProxy.invoke(target, objects);</span><br><span class="line">  		<span class="comment">// Object result = methodProxy.invokeSuper(target, objects); // 调用父类，也可以达到目的</span></span><br><span class="line">		System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,NoOp.INSTANCE&#125;);<span class="comment">/** 可以指定多个callback方法NoOp.INSTANCE表示不做任何事情 */</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>( <span class="string">&quot;test&quot;</span>.equals(method.getName()) )&#123; <span class="comment">// 表示如果方法名称是test，则指向第一个callback</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 动态代理所创建出来的UserService对象</span></span><br><span class="line">UserService userService = (UserService) enhancer.create();</span><br><span class="line"><span class="comment">// 执行这个userService的test方法时，就会额外会执行一些其他逻辑</span></span><br><span class="line">userService.test();</span><br><span class="line">userService.a();</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">执行<span class="number">28</span>行：</span><br><span class="line">before...</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">after...</span><br><span class="line"></span><br><span class="line">执行<span class="number">29</span>行：</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JDK 动态代理</p>
<blockquote>
<p>除开cglib技术，jdk本身也提供了一种创建代理对象的动态代理机制，但是它只能代理接口，也就是UserService得先有一个接口才能利用jdk动态代理机制来生成一个代理对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## jdk 动态代理</span><br><span class="line">UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line"><span class="comment">// UserInterface接口的代理对象</span></span><br><span class="line">Object proxy = Proxy.newProxyInstance(UserService.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;UserInterface.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">		Object result = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserInterface userService = (UserInterface) proxy;</span><br><span class="line">userService.test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你把new Class[]{UserInterface.class}，替换成new Class[]{UserService.class}，允许代码会直接报错：</p>
<p>Exception in thread “main” java.lang.IllegalArgumentException: com.zhouyu.service.UserService is not an interface</p>
<p>表示一定要是个接口。</p>
<p>由于这个限制，所以产生的代理对象的类型是UserInterface，而不是UserService，这是需要注意的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="2、ProxyFactory"><a href="#2、ProxyFactory" class="headerlink" title="2、ProxyFactory"></a>2、<strong>ProxyFactory</strong></h2><blockquote>
<p>上面我们介绍了两种动态代理技术，那么在Spring中进行了封装，封装出来的类叫做ProxyFactory，表示是创建代理对象的一个工厂，使用起来会比上面的更加方便，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(target);</span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">		Object result = invocation.proceed();</span><br><span class="line">		System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserInterface userService = (UserInterface) proxyFactory.getProxy();</span><br><span class="line">userService.test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过ProxyFactory，我们可以不再关系到底是用cglib还是jdk动态代理了，ProxyFactory会帮我们去判断，如果UserService实现了接口，那么ProxyFactory底层就会用jdk动态代理，如果没有实现接口，就会用cglib技术，上面的代码，就是由于UserService实现了UserInterface接口，所以最后产生的代理对象是UserInterface类型。</p>
</blockquote>
</blockquote>
<h2 id="3、Advice的使用"><a href="#3、Advice的使用" class="headerlink" title="3、Advice的使用"></a>3、Advice的使用</h2><ul>
<li><strong>Advice的分类</strong></li>
</ul>
<ol>
<li>Before Advice：方法之前执行</li>
<li>After returning advice：方法return后执行</li>
<li>After throwing advice：方法抛异常后执行</li>
<li>After (finally) advice：方法执行完finally之后执行，这是最后的，比return更后</li>
<li>Around advice：这是功能最强大的Advice，可以自定义执行顺序</li>
</ol>
<ul>
<li><p><strong>Advice的使用(底层使用)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 方法返回后</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAfterReturnAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;方法return后执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 方法执行前</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;方法执行前执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 方法抛出异常后执行</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThrowAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, NullPointerException ex)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;方法抛出异常后执行&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 方法执行前后执行</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;方法执行around前&quot;</span>);</span><br><span class="line">      Object proceed = invocation.proceed();</span><br><span class="line">      System.out.println(<span class="string">&quot;方法执行around后&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> proceed;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## UserService</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      <span class="comment">//     throw new NullPointerException();</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 测试类</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">()</span></span>&#123;</span><br><span class="line">   UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line">   ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">   factory.setTarget(target);</span><br><span class="line">   <span class="comment">// advice表示一段代理逻辑</span></span><br><span class="line">   factory.addAdvice(<span class="keyword">new</span> TestBeforeAdvice());</span><br><span class="line">   factory.addAdvice(<span class="keyword">new</span> TestAfterReturnAdvice());</span><br><span class="line">   factory.addAdvice(<span class="keyword">new</span> TestThrowAdvice());</span><br><span class="line">   factory.addAdvice(<span class="keyword">new</span> TestAroundAdvice());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// advisor  Advisor = Pointcut + Advice</span></span><br><span class="line">   factory.addAdvisor(<span class="keyword">new</span> PointcutAdvisor() &#123;</span><br><span class="line">      <span class="comment">// 切点  决定代理逻辑作用于何处</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> StaticMethodMatcherPointcut() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> method.getName().equals(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一段代理逻辑</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> TestBeforeAdvice();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无用的方法</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   UserService proxy = (UserService)factory.getProxy();</span><br><span class="line">   proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 结果</span><br><span class="line">方法执行前执行</span><br><span class="line">方法执行around前</span><br><span class="line">方法执行前执行</span><br><span class="line">test</span><br><span class="line">方法执行around后</span><br><span class="line">方法<span class="keyword">return</span>后执行</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Advice的使用（上层使用）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;bat.ke.qq.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ProxyFactoryBean <span class="title">userService</span><span class="params">()</span></span>&#123;</span><br><span class="line">      UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">      ProxyFactoryBean proxyFactoryBean = <span class="keyword">new</span> ProxyFactoryBean();</span><br><span class="line">      proxyFactoryBean.addAdvice(<span class="keyword">new</span> TestBeforeAdvice());</span><br><span class="line">      proxyFactoryBean.setTarget(userService);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> proxyFactoryBean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 测试</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adviceUpperUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">   UserService userService = (UserService)context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">   userService.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Advisor的理解</strong></p>
<blockquote>
<p>Advisro = Advice（before/afterreturn/afterthrow…） + pointcut（切点）</p>
</blockquote>
<blockquote>
<p>跟Advice类似的还有一个Advisor的概念，一个Advisor是有一个Pointcut和一个Advice组成的，通过Pointcut可以指定要需要被代理的逻辑，比如一个UserService类中有两个方法，按上面的例子，这两个方法都会被代理，被增强，那么我们现在可以通过Advisor，来控制到具体代理哪一个方法</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService target = <span class="keyword">new</span> UserService();</span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(target);</span><br><span class="line">proxyFactory.addAdvisor(<span class="keyword">new</span> PointcutAdvisor() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StaticMethodMatcherPointcut() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> method.getName().equals(<span class="string">&quot;testAbc&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">				Object result = invocation.proceed();</span><br><span class="line">				System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserInterface userService = (UserInterface) proxyFactory.getProxy();</span><br><span class="line">userService.test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码表示，产生的代理对象，只有在执行testAbc这个方法时才会被增强，会执行额外的逻辑，而在执行其他方法时是不会增强的</p>
</blockquote>
</li>
</ul>
<h2 id="4、创建代理对象的方式"><a href="#4、创建代理对象的方式" class="headerlink" title="4、创建代理对象的方式"></a>4、<strong>创建代理对象的方式</strong></h2><blockquote>
<p>上面介绍了Spring中所提供了ProxyFactory、Advisor、Advice、PointCut等技术来实现代理对象的创建，但是我们在使用Spring时，我们并不会直接这么去使用ProxyFactory，比如说，我们希望ProxyFactory所产生的代理对象能直接就是Bean，能直接从Spring容器中得到UserSerivce的代理对象，而这些，Spring都是支持的，只不过，作为开发者的我们肯定得告诉Spring，那些类需要被代理，代理逻辑是什么。</p>
</blockquote>
<ul>
<li><p><strong>ProxyFactoryBean</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProxyFactoryBean <span class="title">userServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">	UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">	ProxyFactoryBean proxyFactoryBean = <span class="keyword">new</span> ProxyFactoryBean();</span><br><span class="line">	proxyFactoryBean.setTarget(userService);</span><br><span class="line">	proxyFactoryBean.addAdvice(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">			Object result = invocation.proceed();</span><br><span class="line">			System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> proxyFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方法来定义一个UserService的Bean，并且是经过了AOP的。但是这种方式<strong>只能针对某一个Bean</strong>。它是一个FactoryBean，所以利用的就是FactoryBean技术，间接的将UserService的代理对象作为了Bean。</p>
<p>ProxyFactoryBean还有额外的功能，比如可以把某个Advise或Advisor定义成为Bean，然后在ProxyFactoryBean中进行设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">zhouyuAroundAdvise</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">			Object result = invocation.proceed();</span><br><span class="line">			System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProxyFactoryBean <span class="title">userService</span><span class="params">()</span></span>&#123;</span><br><span class="line">	UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">	</span><br><span class="line">    ProxyFactoryBean proxyFactoryBean = <span class="keyword">new</span> ProxyFactoryBean();</span><br><span class="line">	proxyFactoryBean.setTarget(userService);</span><br><span class="line">	proxyFactoryBean.setInterceptorNames(<span class="string">&quot;zhouyuAroundAdvise&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> proxyFactoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="5、BeanNameAutoProxyCreator"><a href="#5、BeanNameAutoProxyCreator" class="headerlink" title="5、BeanNameAutoProxyCreator"></a>5、<strong>BeanNameAutoProxyCreator</strong></h2><blockquote>
<p>ProxyFactoryBean得自己指定被代理的对象，那么我们可以通过BeanNameAutoProxyCreator来通过指定某个bean的名字，来对该bean进行代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanNameAutoProxyCreator <span class="title">beanNameAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BeanNameAutoProxyCreator beanNameAutoProxyCreator = <span class="keyword">new</span> BeanNameAutoProxyCreator();</span><br><span class="line">	beanNameAutoProxyCreator.setBeanNames(<span class="string">&quot;userSe*&quot;</span>);</span><br><span class="line">	beanNameAutoProxyCreator.setInterceptorNames(<span class="string">&quot;zhouyuAroundAdvise&quot;</span>);</span><br><span class="line">	beanNameAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> beanNameAutoProxyCreator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过BeanNameAutoProxyCreator可以对批量的Bean进行AOP，并且指定了代理逻辑，指定了一个InterceptorName，也就是一个Advise，前提条件是这个Advise也得是一个Bean，这样Spring才能找到的，但是BeanNameAutoProxyCreator的缺点很明显，它只能根据beanName来指定想要代理的Bean。</p>
</blockquote>
<h2 id="6、BeanNameAutoProxyCreator（是一个BeanPostProcessor，可以对bean进行加工）使用"><a href="#6、BeanNameAutoProxyCreator（是一个BeanPostProcessor，可以对bean进行加工）使用" class="headerlink" title="6、BeanNameAutoProxyCreator（是一个BeanPostProcessor，可以对bean进行加工）使用"></a>6、<strong>BeanNameAutoProxyCreator（是一个BeanPostProcessor，可以对bean进行加工）使用</strong></h2><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;方法执行around前&quot;</span>);</span><br><span class="line">      Object proceed = invocation.proceed();</span><br><span class="line">      System.out.println(<span class="string">&quot;方法执行around后&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> proceed;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;bat.ke.qq.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BeanNameAutoProxyCreator <span class="title">beanNameAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      BeanNameAutoProxyCreator beanNameAutoProxyCreator = <span class="keyword">new</span> BeanNameAutoProxyCreator();</span><br><span class="line">      beanNameAutoProxyCreator.setBeanNames(<span class="string">&quot;userSe*&quot;</span>);</span><br><span class="line">      beanNameAutoProxyCreator.setInterceptorNames(<span class="string">&quot;testAroundAdvice&quot;</span>);</span><br><span class="line"><span class="comment">//    beanNameAutoProxyCreator.setProxyTargetClass(true);</span></span><br><span class="line">      <span class="keyword">return</span> beanNameAutoProxyCreator;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//    throw new NullPointerException();</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## test测试类</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanNameAutoProxyCreator</span><span class="params">()</span></span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">   UserService userService = (UserService)context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">   userService.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##结果</span><br><span class="line">方法执行around前</span><br><span class="line">test</span><br><span class="line">方法执行around后</span><br></pre></td></tr></table></figure>

<h2 id="7、DefaultAdvisorAutoProxyCreator"><a href="#7、DefaultAdvisorAutoProxyCreator" class="headerlink" title="7、DefaultAdvisorAutoProxyCreator"></a>7、<strong>DefaultAdvisorAutoProxyCreator</strong></h2><blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultPointcutAdvisor <span class="title">defaultPointcutAdvisor</span><span class="params">()</span></span>&#123;</span><br><span class="line">	NameMatchMethodPointcut pointcut = <span class="keyword">new</span> NameMatchMethodPointcut();</span><br><span class="line">	pointcut.addMethodName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    DefaultPointcutAdvisor defaultPointcutAdvisor = <span class="keyword">new</span> DefaultPointcutAdvisor();</span><br><span class="line">	defaultPointcutAdvisor.setPointcut(pointcut);</span><br><span class="line">	defaultPointcutAdvisor.setAdvice(<span class="keyword">new</span> ZhouyuAfterReturningAdvise());</span><br><span class="line">    <span class="keyword">return</span> defaultPointcutAdvisor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">	<span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanNameAutoProxyCreator</span><span class="params">()</span></span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">   UserService userService = (UserService)context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">   userService.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##结果</span><br><span class="line">test</span><br><span class="line">方法<span class="keyword">return</span>后执行</span><br></pre></td></tr></table></figure>

<p>通过DefaultAdvisorAutoProxyCreator会直接去找所有Advisor类型的Bean，根据Advisor中的PointCut和Advice信息，确定要代理的Bean以及代理逻辑。</p>
<p>但是，我们发现，通过这种方式，我们得依靠某一个类来实现定义我们的Advisor，或者Advise，或者Pointcut，那么这个步骤能不能更加简化一点呢？</p>
</blockquote>
<h2 id="8、注解方式"><a href="#8、注解方式" class="headerlink" title="8、注解方式"></a>8、注解方式</h2><blockquote>
<p>比如我们能不能只定义一个类，然后通过在类中的方法上通过某些注解，来定义PointCut以及Advice，可以的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuAspect</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Before(&quot;execution(public void com.zhouyu.service.UserService.test())&quot;)</span> <span class="comment">// pointcut ---&gt;表面代理逻辑生效的地方 @Before是advice</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zhouyuBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;zhouyuBefore&quot;</span>); <span class="comment">// ---&gt;代理逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这个类，我们就直接定义好了所要代理的方法(通过一个表达式)，以及代理逻辑（被@Before修饰的方法），简单明了，这样对于Spring来说，它要做的就是来解析这些注解了，解析之后得到对应的Pointcut对象、Advice对象，生成Advisor对象，扔进ProxyFactory中，进而产生对应的代理对象，具体怎么解析这些注解就是**@EnableAspectJAutoProxy注解**所要做的事情了，后面详细分析。</p>
</blockquote>
<h2 id="9、AOP中的概念"><a href="#9、AOP中的概念" class="headerlink" title="9、AOP中的概念"></a>9、<strong>AOP中的概念</strong></h2><ul>
<li>基本概念</li>
</ul>
<blockquote>
<ol>
<li>Aspect：表示切面，比如被@Aspect注解的类就是切面，可以在切面中去定义Pointcut、Advice等等</li>
<li>Join point：表示连接点，表示一个程序在执行过程中的一个点，比如一个方法的执行，比如一个异常的处理，在Spring AOP中，一个连接点通常表示一个方法的执行。【当前被代理的方法】</li>
<li>Advice：表示通知，表示在一个特定连接点上所采取的动作。Advice分为不同的类型，后面详细讨论，在很多AOP框架中，包括Spring，会用Interceptor拦截器来实现Advice，并且在连接点周围维护一个Interceptor链</li>
<li>Pointcut：表示切点，用来匹配一个或多个连接点，Advice与切点表达式是关联在一起的，Advice将会执行在和切点表达式所匹配的连接点上</li>
<li>Introduction：可以使用@DeclareParents来给所匹配的类添加一个接口，并指定一个默认实现</li>
<li>Target object：目标对象，被代理对象</li>
<li>AOP proxy：表示代理工厂，用来创建代理对象的，在Spring Framework中，要么是JDK动态代理，要么是CGLIB代理</li>
<li>Weaving：表示织入，表示创建代理对象的动作，这个动作可以发生在编译时期（比如Aspejctj），或者运行时，比如Spring AOP</li>
</ol>
</blockquote>
<ul>
<li><p><strong>Advice在Spring AOP中对应API</strong></p>
<p>上面说到的Aspject中的注解，其中有五个是用来定义Advice的，表示代理逻辑，以及执行时机：</p>
<ol>
<li>@Before</li>
<li>@AfterReturning</li>
<li>@AfterThrowing</li>
<li>@After</li>
<li>@Around</li>
</ol>
<p>我们前面也提到过，Spring自己也提供了类似的执行实际的实现类：</p>
<ol>
<li>接口MethodBeforeAdvice，继承了接口BeforeAdvice</li>
<li>接口AfterReturningAdvice</li>
<li>接口ThrowsAdvice</li>
<li>接口AfterAdvice</li>
<li>接口MethodInterceptor</li>
</ol>
<p>Spring会把五个注解解析为对应的Advice类：</p>
<ol>
<li>@Before：AspectJMethodBeforeAdvice，实际上就是一个MethodBeforeAdvice</li>
<li>@AfterReturning：AspectJAfterReturningAdvice，实际上就是一个AfterReturningAdvice</li>
<li>@AfterThrowing：AspectJAfterThrowingAdvice，实际上就是一个MethodInterceptor</li>
<li>@After：AspectJAfterAdvice，实际上就是一个MethodInterceptor</li>
<li>@Around：AspectJAroundAdvice，实际上就是一个MethodInterceptor</li>
</ol>
</li>
<li><p><strong>TargetSource的使用</strong></p>
<blockquote>
<p>在我们日常的AOP中，被代理对象就是Bean对象，是由BeanFactory给我们创建出来的，但是Spring AOP中提供了TargetSource机制，可以让我们用来自定义逻辑来创建<strong>被代理对象</strong>。</p>
<p>比如之前所提到的@Lazy注解，当加在属性上时，会产生一个代理对象赋值给这个属性，产生代理对象的代码为：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, <span class="keyword">final</span> <span class="meta">@Nullable</span> String beanName)</span> </span>&#123;</span><br><span class="line">		BeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		Assert.state(beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory,</span><br><span class="line">				<span class="string">&quot;BeanFactory needs to be a DefaultListableBeanFactory&quot;</span>);</span><br><span class="line">		<span class="keyword">final</span> DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line">		TargetSource ts = <span class="keyword">new</span> TargetSource() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">				<span class="keyword">return</span> descriptor.getDependencyType();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				Set&lt;String&gt; autowiredBeanNames = (beanName != <span class="keyword">null</span> ? <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>) : <span class="keyword">null</span>);</span><br><span class="line">				Object target = dlbf.doResolveDependency(descriptor, beanName, autowiredBeanNames, <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">					Class&lt;?&gt; type = getTargetClass();</span><br><span class="line">					<span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">						<span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (List.class == type) &#123;</span><br><span class="line">						<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (Set.class == type || Collection.class == type) &#123;</span><br><span class="line">						<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),</span><br><span class="line">							<span class="string">&quot;Optional dependency not present for lazy injection point&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">						<span class="keyword">if</span> (dlbf.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">							dlbf.registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> target;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">		pf.setTargetSource(ts);</span><br><span class="line">		Class&lt;?&gt; dependencyType = descriptor.getDependencyType();</span><br><span class="line">		<span class="keyword">if</span> (dependencyType.isInterface()) &#123;</span><br><span class="line">			pf.addInterface(dependencyType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码就利用了ProxyFactory来生成代理对象，以及使用了TargetSource，以达到代理对象在执行某个方法时，调用TargetSource的getTarget()方法实时得到一个<strong>被代理对象</strong>。</p>
</blockquote>
</li>
</ul>
<p><a href="https://www.processon.com/view/link/62f69b2d0e3e740754f8bb69">AOP思维导图</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC整体流程分析</title>
    <url>/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Spring-MVC整体流程"><a href="#Spring-MVC整体流程" class="headerlink" title="Spring MVC整体流程"></a>Spring MVC整体流程</h1><h2 id="1、MVC模型的由来"><a href="#1、MVC模型的由来" class="headerlink" title="1、MVC模型的由来"></a>1、MVC模型的由来</h2><h3 id="1-1、Model1-模型"><a href="#1-1、Model1-模型" class="headerlink" title="1.1、Model1 模型"></a><strong>1.1、Model1</strong> <strong>模型</strong></h3><p>Model1 模型是很早以前项目开发的一种常见模型，项目主要由 jsp 和 JavaBean 两部分组成。</p>
<p>它的优点是：结构简单。开发小型项目时效率高。</p>
<p>它的缺点也同样明显：</p>
<p>第一：JSP 的职责兼顾于展示数据和处理数据（也就是干了控制器和视图的事）</p>
<p>第二：所有逻辑代码都是写在 JSP 中的，导致代码重用性很低。</p>
<p>第三：由于展示数据的代码和部分的业务代码交织在一起，维护非常不便。</p>
<p>所以，结论是此种设计模型已经被淘汰没人使用了。</p>
<p><img src="/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220710002151773.png" alt="image-20220710002151773"></p>
<p>在Model 1模式下，整个Web应用几乎全部由JSP页面组成，JSP页面接收处理客户端请求，对请求处理后直接做出响应。用少量的JavaBean来处理数据库连接、数据库访问等操作。 </p>
<h3 id="1-2-Model2-模型"><a href="#1-2-Model2-模型" class="headerlink" title="1.2 Model2 模型"></a><strong>1.2 Model2</strong> <strong>模型</strong></h3><p>Model2 模型是在 Model1 的基础上进行改良，它是 MVC 模型的一个经典应用。它把处理请求和展示数据进行分离，让每个部分各司其职。</p>
<p>此时的 JSP 已经就是纯粹的展示数据了，而处理请求的事情交由控制器来完成，使</p>
<p>每个组件充分独立，提高了代码可重用性和易维护性。下图展示的就是 Model2 模型：</p>
<p><img src="/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220710002200181.png" alt="image-20220710002200181"></p>
<blockquote>
<p>Model 2是基于MVC架构的设计模式。</p>
<p>在Model 2架构中，Servlet作为前端控制器，负责接收客户端发送的请求</p>
<p>在Servlet中只包含控制逻辑和简单的前端处理；</p>
<p>后端JavaBean来完成实际的逻辑处理；</p>
<p>最后，转发到相应的JSP页面处理显示逻辑。</p>
<p>Model 2具有组件化的特点，更适用于大规模应用的开发。</p>
</blockquote>
<h2 id="2-基于-MVC-模型框架之：SpringMVC"><a href="#2-基于-MVC-模型框架之：SpringMVC" class="headerlink" title="2 基于 MVC 模型框架之：SpringMVC"></a>2 <strong>基于</strong> <strong>MVC</strong> 模型框架之：SpringMVC</h2><h3 id="2-1-SpringMVC-的执行过程分析"><a href="#2-1-SpringMVC-的执行过程分析" class="headerlink" title="2.1 SpringMVC 的执行过程分析"></a><strong>2.1 SpringMVC</strong> <strong>的执行过程分析</strong></h3><p><img src="/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220710002328751.png" alt="image-20220710002328751"></p>
<blockquote>
<p>1）前端控制器DispatcherServlet 由框架提供</p>
<p>作用：接收请求，处理响应结果</p>
<p>2）处理器映射器HandlerMapping由框架提供</p>
<p>作用：根据请求URL，找到对应的Handler</p>
<p>3）处理器适配器HandlerAdapter由框架提供</p>
<p>作用：调用处理器（Handler|Controller）的方法</p>
<p>4）处理器Handler又名Controller,后端处理器</p>
<p>作用：接收用户请求数据，调用业务方法处理请求</p>
<p>5）视图解析器ViewResolver由框架提供</p>
<p>作用：视图解析，把逻辑视图名称解析成真正的物理视图</p>
<p>支持多种视图技术：JSTLView,FreeMarker…</p>
<p>6）视图View,程序员开发</p>
<p>作用：将数据展现给用户</p>
</blockquote>
<h3 id="2-2-SpringMVC-中三大组件详解"><a href="#2-2-SpringMVC-中三大组件详解" class="headerlink" title="2.2 SpringMVC 中三大组件详解"></a><strong>2.2 SpringMVC</strong> <strong>中三大组件详解</strong></h3><p><strong>2.2.1</strong> <strong>处理器映射器</strong></p>
<p>它指的是：<strong>HandlerMapping</strong></p>
<p>是在 Spring 的 3.1 版本之后加入的。它的出现，可以让使用者更加轻松的去配置 SpringMVC 的请求路径映</p>
<p>射。去掉了早期繁琐的 xml 的配置</p>
<p>它的配置有两种方式：都是在 springmvc.xml 中加入配置。</p>
<p>第一种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;       </span><br></pre></td></tr></table></figure>

<p>第二种方式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;         </span><br></pre></td></tr></table></figure>

<p><strong>2.2.2</strong> <strong>处理器适配器</strong></p>
<p>要清晰的认识 SpringMVC 的处理器适配器，就先必须知道适配器以及它的作用。我们先通过下图，直观的了解一下：</p>
<p><img src="/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220710002734687.png" alt="image-20220710002734687"></p>
<p>通过上面三张图，我们可以直观的感受到，它是把不同的接口都转换成了 USB 接口。</p>
<p>带入到我们 SpringMVC 中，就是把不同的控制器，最终都可以看成是适配器类型，从而执行适配器中定义的</p>
<p>方法。更深层次的是，我们可以把公共的功能都定义在适配器中，从而减少每种控制器中都有的重复性代码。</p>
<p>学习了SpringMVC 的执行过程，最终调用的是前端控制器 DispatcherServlet 的 doDispatch 方法，而该方法中的 HandlerAdapter 的 handle 方法实际调用了我</p>
<p>们自己写的控制器方法。而我们写的控制方法名称各不一样，它是通过 handle 方法反射调用的。但是我们不知道的是，其实 SpringMVC 中处理器适配器也有多</p>
<p>个。</p>
<p>HandlerAdapter详解</p>
<p>这里Spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的Adapter,其Handler与 HandlerAdapter 对应关系如下:</p>
<table>
<thead>
<tr>
<th>Handler类别</th>
<th>对应适配器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>SimpleControllerHandlerAdapter</td>
<td>标准控制器，返回ModelAndView</td>
</tr>
<tr>
<td>HttpRequestHandler</td>
<td>HttpRequestHandlerAdapter</td>
<td>业务自行处理 请求，不需要通过modelAndView 转到视图</td>
</tr>
<tr>
<td>Servlet</td>
<td>SimpleServletHandlerAdapter</td>
<td>基于标准的servlet 处理</td>
</tr>
<tr>
<td>HandlerMethod</td>
<td>RequestMappingHandlerAdapter</td>
<td>基于@requestMapping对应方法处理</td>
</tr>
</tbody></table>
<ul>
<li><p>第一个：org.springframework.web.servlet.mvc.<strong>SimpleControllerHandlerAdapter</strong></p>
<p>使用此适配器，适用的控制器写法：要求实现 Controller 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController2</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">同时要求我们在 springmvc.xml 中添加：</span><br><span class="line">&lt;bean id=<span class="string">&quot;simpleControllerHandlerAdapter &quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean name=<span class="string">&quot;/sayhello2&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.baiqi.web.controller.HelloController2&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>第二个：org.springframework.web.servlet.mvc.<strong>HttpRequestHandlerAdapter</strong></p>
<blockquote>
<p>使用此适配器的控制器写法：要求实现 HttpRequestHandler 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController3</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时要求我们在 springmvc.xml 中添加：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;/sayhello3&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.baiqi.web.controller.HelloController3&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot; httpRequestHandlerAdapter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>第三个：org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerAdapter</strong></p>
<blockquote>
<p>这种方式也是我们实际开发中采用最多的。它的要求是我们用注解@Controller 配置控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;控制器方法执行了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时要求我们在 springmvc.xml 中配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;requestMappingHandlerAdapter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>不过通常情况下我们都是直接配置: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><strong>2.2.3</strong> <strong>视图解析器</strong></p>
<blockquote>
<p>首先，我们得先了解一下 SpringMVC 中的视图。视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。为了实现视图模型和具体实现技术的解耦，Spring 在 org.springframework.web.servlet 包中定义了一个高度抽象的 View 接口。我们的视图是无状态的，所以他们不会有线程安全的问题。无状态是指对于每一个请求，都会创建一个 View对象。</p>
</blockquote>
<p>在 SpringMVC 中常用的视图类型：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>视图类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>URL 视图</td>
<td>InternalResourceView</td>
<td>将 JSP 或者其他资源封装成一个视图，是InternaleResourceViewResolver默认使用的视图类型。</td>
</tr>
<tr>
<td>JstlView</td>
<td>它是当我们在页面中使用了 JSTL 标签库的国际化标签后，需要采用的类型。</td>
<td></td>
</tr>
<tr>
<td>文档类视图</td>
<td>AbstractPdfView</td>
<td>PDF 文档视图的抽象类</td>
</tr>
<tr>
<td>AbstarctXlsView</td>
<td>Excel 文档视图的抽象类，该类是 4.2版 本 之 后 才 有 的 。 之 前 使 用 的 是AbstractExcelView。</td>
<td></td>
</tr>
<tr>
<td>JSON 视图</td>
<td>MappingJackson2JsonView</td>
<td>将模型数据封装成Json格式数据输出。它需要借助 Jackson 开源框架。</td>
</tr>
<tr>
<td>XML 视图</td>
<td>MappingJackson2XmlView</td>
<td>将模型数据封装成 XML 格式数据。它是从 4.1 版本之后才加入的。</td>
</tr>
</tbody></table>
<p>接下来就是了解视图解析器的作用。View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。视图对象是由视图解析器负责实例化。视图解析器的作用是将逻辑视图转为物理视图，所有的视图解析器都必须实现 ViewResolver 接口。SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。程序员可以选择一种视图解析器或混用多种视图解析器。可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高，SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则抛出 ServletException异常。</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>解析器类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>解析为 Bean 的名称</td>
<td>BeanNameViewResolver</td>
<td>Bean 的 id 即为逻辑视图名称。</td>
</tr>
<tr>
<td>解析为 URL 文件</td>
<td>InternalResourceViewResolver</td>
<td>将视图名解析成一个 URL 文件，一般就是一个 jsp 或者 html 文件。文件一般都存放在 WEB-INF 目录中。</td>
</tr>
<tr>
<td>解析指定 XML 文件</td>
<td>XmlViewResolver</td>
<td>解析指定位置的 XML 文件，默认在/WEB-INF/views.xml</td>
</tr>
<tr>
<td>解析指定属性文件</td>
<td>ResourceBundleViewResolver</td>
<td>解析 properties 文件。</td>
</tr>
</tbody></table>
<p><strong>2.2.4</strong> <strong>不需要视图解析器的场景分析</strong></p>
<p>在分析之前，我们先需要回顾下控制器方法的返回值，此处我们都是以注解@Controller 配置控制器为例，控制器的方法返回值其实支持三种方式：</p>
<ul>
<li><p>第一种：String 类型。借助视图解析器，可以在指定位置为我们找到指定扩展名的视图。视图可以是 JSP，HTML 或者其他的控制器方法上的 RequestMapping 映射地址。前往指定视图的方式，默认是请求转发，可以通过redirect:前缀控制其使用重定向。</p>
</li>
<li><p>第二种：void，即没有返回值。因为我们在控制器方法的参数中可以直接使用原始 SerlvetAPI 对象HttpServletRequest 和 HttpServletResponse 对象，所以无论是转发还是重定向都可以轻松实现，而无需使用返回值。</p>
</li>
<li><p>第三种：ModelAndView 类型。其实我们跟踪源码可以发现在 DispatcherServlet 中的 doDispatch 方法执行时，HandlerAdapter 的 handle 方法的返回值就是 ModelAndView，只有我们的控制器方法定义为 void时，才不会返回此类型。当返回值是 String 的时候也会创建 ModelAndView 并返回。</p>
</li>
</ul>
<p>通过上面三种控制器方法返回值，我们可以再深入的剖析一下我们请求之后接收响应的方式，其实无外乎就三种。</p>
<ul>
<li><p>第一种：请求转发</p>
</li>
<li><p>第二种：重定向</p>
</li>
<li><p>第三 直接使用 Response 对象获取流对象输入。可以是字节流也可以是字符流。</p>
</li>
</ul>
<p>接下来我们就分析，这三种方式的本质区别。其中请求转发和重定向的区别相信大家已经很熟悉了。但是它们的共同点呢？就是都会引发页面的跳转。在我们的实际开发中，如果我们不需要页面跳转，即基于 ajax 的异步请求，用 json 数据交互时，即可不配置任何视图解析器。前后端交互是通过 json 数据的，利用@RequestBody 和@ResponseBody 实现数据到 java对象的绑定（当然还要借助类似 Jackson 开源框架）。</p>
<p><strong>2.2.5</strong> <strong>请求参数封装的实现原理</strong></p>
<p>在使用 SpringMVC 实现请求参数封装时，它支持基本类型，POJO 类型和集合类型。其封装原理其实就是使用我们原始的 ServletAPI 中的方法，并且配合反射实现的封装。此处我们以最简单的 String 和 Integer 两个方法为例，带着大家把整个执行过程走一圈。先来看控制器的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name,Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;控制器方法执行了&quot;</span>+name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2.6</strong> <strong>常用注解的使用场景及实现思路分析：</strong></p>
<p><strong>2.2.6.1 RequestParam</strong></p>
<p>首先我们要明确，我们的请求参数体现形式是什么样的。 在请求体的 MIME 类型为 application/x-www-form-urlencoded 或者 application/json 的情况下，无论 get/post/put/delete 请求方式，参数的体现形式都是 key=value。再来，通过上一小节我们知道，SpringMVC 是使用我们控制器方法的形参作为参数名称，再使用 request 的getParameterValues 方法获取的参数。所以才会有请求参数的 key 必须和方法形参变量名称保持一致的要求。但是如果形参变量名称和请求参数的 key 不一致呢？此时，参数将无法封装成功。此时 RequestParam 注解就会起到作用，它会把该注解 value 属性的值作为请求参数的 key 来获取请求参数的值，并传递给控制器方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamController1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理请求的控制器方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span>String name,Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;控制器方法执行了&quot;</span>+name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2.6.2 RequestBody</strong></p>
<p>我们通过源码分析得知，SpringMVC 在封装请求参数的时候，默认只会获取参数的值，而不会把参数名称一同获取出来，这在我们使用表单提交的时候没有任何问题。因为我们的表单提交，请求参数是key=value 的。但是当我们使用 ajax 进行提交时，请求参数可能是 json 格式的：{key:value}，在此种情况下，要想实现封装以我们前面的内容是无法实现的。此时需要我们使用@RequestBody 注解。</p>
<p><strong>JSP</strong> <strong>代码片段：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js&quot;</span>&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">$(function()&#123;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#ajaxBtn&quot;</span>).click(function()&#123;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line"></span><br><span class="line">type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line"></span><br><span class="line">url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/hello2&quot;</span>,</span><br><span class="line"></span><br><span class="line">dataType:<span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">data:<span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;test&#x27;,&#x27;age&#x27;:18&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line">contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line"></span><br><span class="line">success:function(data)&#123;</span><br><span class="line"></span><br><span class="line">alert(data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;title&gt;SpringMVC&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;button id=<span class="string">&quot;ajaxBtn&quot;</span>&gt;异步请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>控制器代码片段</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理请求的控制器方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello2</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;控制器方法执行了 2&quot;</span>+body);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2.6.3 PathVariable</strong></p>
<p>它是 SpringMVC 在 3.0 之后新加入的一个注解，是 SpringMVC 支持 Restful 风格 URL 的一个重要标志。</p>
<p><img src="/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220710003643041.png" alt="image-20220710003643041"></p>
<p>该注解的作用大家已经非常熟悉了，就是把藏在请求 URL 中的参数，给我们控制器方法的形参赋值。而Restful风格的 URL，在现如今的开发中使用越来越普遍了。那么它是如何实现封装的呢？请看下图：首先还是执行到红框中解析参数这行代码，我们看出 SpringMVC 在实现请求 URL 使用占位符传参并封装到控制器方法的形参中，是通过请求域来实现的。最后把请求域转成一个 Map，再根据形参的名称作为 key，从 map 中获取 value，并给形参赋值。当然如果我们使用了 PathVariable 注解的 value 属性，则不会以形参名称为 key，而是直接使用 value属性的值作为 key 了。</p>
<p><strong>2.2.7</strong> <strong>拦截器的</strong> <strong>AOP</strong> <strong>思想</strong></p>
<p>AOP 思想是 Spring 框架的两大核心之一，是解决方法调用依赖以及提高方便后期代码维护的重要思想。它是把我们代码中高度重复的部分抽取出来，并在适当的时机，通过代理机制来执行，从而做到不修改源码对已经写好的方法进行增强。而拦截器正式这种思想的具体实现。</p>
<p>拦截器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;拦截器执行了&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;执行了 postHandle 方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;执行了 afterCompletion 方法&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.2.8</strong> <strong>自定义拦截器中三个方法说明及使用场景</strong></p>
<p><strong>2.2.8.1 preHandle</strong></p>
<p>此方法的执行时机是在控制器方法执行之前，所以我们通常是使用此方法对请求部分进行增强。同时由于结果</p>
<p>视图还没有创建生成，所以此时我们可以指定响应的视图。</p>
<p><strong>2.2.8.2 postHandle</strong></p>
<p>此方法的执行时机是在控制器方法执行之后，结果视图创建生成之前。所以通常是使用此方法对响应部分进行增强。因为结果视图没有生成，所以我们此时仍然可以控制响应结果。</p>
<p><strong>2.2.8.3 afterCompletion</strong></p>
<p>此方法的执行时机是在结果视图创建生成之后，展示到浏览器之前。所以此方法执行时，本次请求要准备的数据具已生成完毕，且结果视图也已创建完成，所以我们可以利用此方法进行清理操作。同时，我们也无法控制响应结果集内容。</p>
<h3 id="2-3-为什么不使用-XML-配置-SpringMVC"><a href="#2-3-为什么不使用-XML-配置-SpringMVC" class="headerlink" title="2.3 为什么不使用 XML 配置 SpringMVC"></a><strong>2.3</strong> <strong>为什么不使用</strong> <strong>XML</strong> <strong>配置</strong> <strong>SpringMVC</strong></h3><p><strong>2.3.1我们先来看基于</strong> <strong>XML</strong> <strong>的</strong> <strong>SpringMVC</strong> <strong>配置：</strong></p>
<p>第一步：配置 web.xml</p>
<p>第二步：编写控制器</p>
<p>第三步：编写 springmvc.xml</p>
<p>第四步：配置控制器</p>
<p>第五步：配置处理器映射器，处理器适配器。</p>
<p>第六步：配置视图解析器。</p>
<p>其中，前 3 步和第六步基于注解配置时也都有，而第四第五步注解配置只需：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启 springmvc 对注解的支持--&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</span><br><span class="line"></span><br><span class="line">而 XML 配置则需：</span><br><span class="line"></span><br><span class="line">&lt;!-- 实现 Controller 接口--&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt; </span><br><span class="line">&lt;bean name=<span class="string">&quot;/sayhello2&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.baiqi.web.controller.HelloController2&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 继承 HttpRequestHandler 类--&gt; </span><br><span class="line">&lt;bean name=<span class="string">&quot;/sayhello3&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.baiqi.web.controller.HelloController3&quot;</span>/&gt; </span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而对比注解配置只需一个 Controller 注解和一个 RequestMapping 注解来比，显然注解来的更方便。</p>
<p><strong>2.3.2 mvc:annotation-driven</strong> <strong>的说明</strong></p>
<p>它就相当于在 xml 中配置了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Begin --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HandlerMapping --&gt; </span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HandlerAdapter --&gt; </span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HadnlerExceptionResolvers --&gt; </span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- End --&gt; </span><br></pre></td></tr></table></figure>

<p>3、Spring整合SpringMvc注意事项</p>
<p>Bean 被创建两次 ？ </p>
<p>• Spring 的 IOC 容器不应该扫描 SpringMVC 中的 bean, 对应的SpringMVC 的 IOC 容器不应该扫描 Spring 中的 bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.baiqi.springmvc&quot;</span> use-<span class="keyword">default</span>-filters=<span class="string">&quot;false&quot;</span>&gt;  </span><br><span class="line">&lt;context:include-filter type=<span class="string">&quot;annotation&quot;</span>    expression=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="line">       &lt;context:include-filter type=<span class="string">&quot;annotation&quot;</span>    expression=<span class="string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span>/&gt;</span><br><span class="line">  &lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.baiqi.springmvc&quot;</span>&gt;  </span><br><span class="line">    &lt;context:exclude-filter type=<span class="string">&quot;annotation&quot;</span>    expression=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="line">    &lt;context:exclude-filter type=<span class="string">&quot;annotation&quot;</span>    expression=<span class="string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span>/&gt;</span><br><span class="line"> &lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>4、在 Spring MVC 配置文件中引用业务层的 Bean</p>
<p>• 多个 Spring IOC 容器之间可以设置为父子关系，以实现良好的解耦。</p>
<p>• Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：即 WEB 层容器可以引用业务层容器的 Bean，而业务层容器却访问不到 WEB 层容器的 Bean</p>
<p><img src="/2022/07/09/02-00-12-SpringMVC%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220710003810431.png" alt="image-20220710003810431"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis执行SQL流程分析</title>
    <url>/2022/08/09/02-01-01-Mybatis%E6%89%A7%E8%A1%8CSQL%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="Mybatis执行SQL流程分析"><a href="#Mybatis执行SQL流程分析" class="headerlink" title="Mybatis执行SQL流程分析"></a>Mybatis执行SQL流程分析</h1><h2 id="1、例子"><a href="#1、例子" class="headerlink" title="1、例子"></a>1、例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        Reader reader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将XML配置文件构建为Configuration配置类</span></span><br><span class="line">            reader = Resources.getResourceAsReader(resource);</span><br><span class="line">            <span class="comment">// 通过加载配置文件流构建一个SqlSessionFactory  DefaultSqlSessionFactory</span></span><br><span class="line">            SqlSessionFactory sqlMapper = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">            <span class="comment">// 数据源 执行器  DefaultSqlSession</span></span><br><span class="line">            SqlSession session = sqlMapper.openSession();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行查询 底层执行jdbc</span></span><br><span class="line">                <span class="comment">//User user = (User)session.selectOne(&quot;com.tuling.mapper.selectById&quot;, 1);</span></span><br><span class="line"></span><br><span class="line">                UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">                System.out.println(mapper.getClass());</span><br><span class="line">                User user = mapper.selectById(<span class="number">1L</span>);</span><br><span class="line">                System.out.println(user.getUserName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、SqlNode设置参数过程"><a href="#2、SqlNode设置参数过程" class="headerlink" title="2、SqlNode设置参数过程"></a>2、SqlNode设置参数过程</h2><ul>
<li>先将#{}取出替换成问号？，将#{}中的变量拿出来</li>
<li>根据第一步拿到的参数找到对应的类型，比如是Integer，然后会找出对应的IntegerTypeHandler</li>
</ul>
<h2 id="2、openSession的过程"><a href="#2、openSession的过程" class="headerlink" title="2、openSession的过程:"></a>2、<strong>openSession的过程:</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">//获取执行器，这边获得的执行器已经代理拦截器的功能（见下面代码）</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">//根据获取的执行器创建SqlSession</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interceptorChain生成代理类，具体参见Plugin这个类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Executor分成两大类，一类是CacheExecutor，另一类是普通Executor。</p>
<p>普通Executor又分为三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ul>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<p>CacheExecutor其实是封装了普通的Executor，和普通的区别是在查询前先会查询缓存中是否存在结果，如果存在就使用缓存中的结果，如果不存在还是使用普通的Executor进行查询，再将查询出来的结果存入缓存。</p>
</blockquote>
<p><strong>执行过程</strong></p>
<p><img src="/2022/08/09/02-01-01-Mybatis%E6%89%A7%E8%A1%8CSQL%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220809232800534.png" alt="image-20220809232800534"></p>
<p>到此为止，我们已经获得了SqlSession，拿到SqlSession就可以执行各种CRUD方法了。</p>
<p><strong>简单总结</strong></p>
<ul>
<li>拿到SqlSessionFactory对象后，会调用SqlSessionFactory的openSesison方法，这个方法会创建一个Sql执行器（Executor），这个Sql执行器会代理你配置的拦截器方法。</li>
<li>获得上面的Sql执行器后，会创建一个SqlSession（默认使用DefaultSqlSession）,这个SqlSession中也包含了Configration对象，所以通过SqlSession也能拿到全局配置；</li>
<li>获得SqlSession对象后就能执行各种CRUD方法了。</li>
</ul>
<p>SQL的具体执行流程见后续博客。</p>
<p>一些重要类总结：</p>
<ul>
<li>SqlSessionFactory</li>
<li>SqlSessionFactoryBuilder</li>
<li>SqlSession（默认使用DefaultSqlSession）</li>
<li>Executor接口</li>
<li>Plugin、InterceptorChain的pluginAll方法</li>
</ul>
<h2 id="3、获取Mapper的流程"><a href="#3、获取Mapper的流程" class="headerlink" title="3、获取Mapper的流程"></a>3、<strong>获取Mapper的流程</strong></h2><p>例子：</p>
<p>进入sqlSession.getMapper方法，会发现调的是Configration对象的getMapper方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mapperRegistry实质上是一个Map，里面注册了启动过程中解析的各种Mapper.xml</span></span><br><span class="line">    <span class="comment">//mapperRegistry的key是接口的Class类型</span></span><br><span class="line">    <span class="comment">//mapperRegistry的Value是MapperProxyFactory,用于生成对应的MapperProxy（动态代理类）</span></span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入getMapper方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="comment">//如果配置文件中没有配置相关Mapper,直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//关键方法</span></span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>进入MapperProxyFactory的newInstance方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//生成Mapper接口的动态代理类MapperProxy，MapperProxy实现了InvocationHandler 接口</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取Mapper的流程总结如下：</p>
<p><img src="/2022/08/09/02-01-01-Mybatis%E6%89%A7%E8%A1%8CSQL%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220711232816553.png" alt="image-20220711232816553"></p>
<h2 id="4、Mapper方法的执行流程"><a href="#4、Mapper方法的执行流程" class="headerlink" title="4、Mapper方法的执行流程"></a>4、<strong>Mapper方法的执行流程</strong></h2><p>下面是动态代理类MapperProxy，调用Mapper接口的所有方法都会先调用到这个代理类的invoke方法（注意由于Mybatis中的Mapper接口没有实现类，所以MapperProxy这个代理对象中没有委托类，也就是说MapperProxy干了代理类和委托类的事情）。好了下面重点看下invoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MapperProxy代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取MapperMethod，并调用MapperMethod</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>MapperProxy的invoke方法非常简单，主要干的工作就是创建MapperMethod对象或者是从缓存中获取MapperMethod对象。获取到这个对象后执行execute方法。</p>
<p>所以这边需要进入MapperMethod的execute方法：这个方法判断你当前执行的方式是增删改查哪一种，并通过SqlSession执行相应的操作。（这边以sqlSession.selectOne这种方式进行分析~）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="comment">//判断是CRUD那种方法</span></span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">    	Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## <span class="number">1</span>、sqlSession.selectOne方法会会调到DefaultSqlSession的selectList方法。这个方法获取了获取了MappedStatement对象，并最终调用了Executor的query方法。</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">## <span class="number">2</span>、然后，通过一层一层的调用（这边省略了缓存操作的环节，会在后面的文章中介绍），最终会来到doQuery方法， 这儿咱们就随便找个Excutor看看doQuery方法的实现吧，我这儿选择了SimpleExecutor:</span><br><span class="line">Copy</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">//内部封装了ParameterHandler和ResultSetHandler</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="comment">//StatementHandler封装了Statement, 让 StatementHandler 去处理</span></span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">## <span class="number">3</span>、接下来，咱们看看StatementHandler 的一个实现类 PreparedStatementHandler（这也是我们最常用的，封装的是PreparedStatement）, 看看它使怎么去处理的：</span><br><span class="line">Copy</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">     <span class="comment">//到此，原形毕露， PreparedStatement, 这个大家都已经滚瓜烂熟了吧</span></span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="comment">//结果交给了ResultSetHandler 去处理,处理完之后返回给客户端</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程：</p>
<p><img src="/2022/08/09/02-01-01-Mybatis%E6%89%A7%E8%A1%8CSQL%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20220809232834775.png" alt="image-20220809232834775"></p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p><strong>简单总结</strong></p>
<p>这边结合获取SqlSession的流程，做下简单的总结：</p>
<ul>
<li>SqlSessionFactoryBuilder解析配置文件，包括属性配置、别名配置、拦截器配置、环境（数据源和事务管理器）、Mapper配置等；解析完这些配置后会生成一个Configration对象，这个对象中包含了MyBatis需要的所有配置，然后会用这个Configration对象创建一个SqlSessionFactory对象，这个对象中包含了Configration对象；</li>
<li>拿到SqlSessionFactory对象后，会调用SqlSessionFactory的openSesison方法，这个方法会创建一个Sql执行器（Executor组件中包含了Transaction对象），这个Sql执行器会代理你配置的拦截器方法。</li>
<li>获得上面的Sql执行器后，会创建一个SqlSession（默认使用DefaultSqlSession）,这个SqlSession中也包含了Configration对象和上面创建的Executor对象，所以通过SqlSession也能拿到全局配置；</li>
<li>获得SqlSession对象后就能执行各种CRUD方法了。</li>
</ul>
<p>以上是获得SqlSession的流程，下面总结下本博客中介绍的Sql的执行流程：</p>
<ul>
<li>调用SqlSession的getMapper方法，获得Mapper接口的动态代理对象MapperProxy，调用Mapper接口的所有方法都会调用到MapperProxy的invoke方法（动态代理机制）；</li>
<li>MapperProxy的invoke方法中唯一做的就是创建一个MapperMethod对象，然后调用这个对象的execute方法，sqlSession会作为execute方法的入参；</li>
<li>往下，层层调下来会进入Executor组件（如果配置插件会对Executor进行动态代理）的query方法，这个方法中会创建一个StatementHandler对象，这个对象中同时会封装ParameterHandler和ResultSetHandler对象。调用StatementHandler预编译参数以及设置参数值，使用ParameterHandler来给sql设置参数。</li>
</ul>
<p>Executor组件有两个直接实现类，分别是BaseExecutor和CachingExecutor。CachingExecutor静态代理了BaseExecutor。Executor组件封装了Transction组件，Transction组件中又分装了Datasource组件。</p>
<ul>
<li>调用StatementHandler的增删改查方法获得结果，ResultSetHandler对结果进行封装转换，请求结束。</li>
</ul>
<p>Executor、StatementHandler 、ParameterHandler、ResultSetHandler，Mybatis的插件会对上面的四个组件进行动态代理。</p>
<p><strong>重要类</strong></p>
<ul>
<li>MapperRegistry：本质上是一个Map，其中的key是Mapper接口的全限定名，value的MapperProxyFactory；</li>
<li>MapperProxyFactory：这个类是MapperRegistry中存的value值，在通过sqlSession获取Mapper时，其实先获取到的是这个工厂，然后通过这个工厂创建Mapper的动态代理类；</li>
<li>MapperProxy：实现了InvocationHandler接口，Mapper的动态代理接口方法的调用都会到达这个类的invoke方法；</li>
<li>MapperMethod：判断你当前执行的方式是增删改查哪一种，并通过SqlSession执行相应的操作；</li>
<li>SqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能；</li>
<li>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护；</li>
</ul>
<p>StatementHandler:封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</p>
<p>ParameterHandler:负责对用户传递的参数转换成JDBC Statement 所需要的参数，</p>
<p>ResultSetHandler:负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</p>
<p>TypeHandler:负责java数据类型和jdbc数据类型之间的映射和转换</p>
<p>MappedStatement:MappedStatement维护了一条节点的封装，</p>
<p>SqlSource:负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</p>
<p>BoundSql:表示动态生成的SQL语句以及相应的参数信息</p>
<p>Configuration:MyBatis所有的配置信息都维持在Configuration对象之中。</p>
<p><strong>调试主要关注点</strong></p>
<ul>
<li>MapperProxy.invoke方法：MyBatis的所有Mapper对象都是通过动态代理生成的，任何方法的调用都会调到invoke方法，这个方法的主要功能就是创建MapperMethod对象，并放进缓存。所以调试时我们可以在这个位置打个断点，看下是否成功拿到了MapperMethod对象，并执行了execute方法。</li>
<li>MapperMethod.execute方法：这个方法会判断你当前执行的方式是增删改查哪一种，并通过SqlSession执行相应的操作。Debug时也建议在此打个断点看下。</li>
<li>DefaultSqlSession.selectList方法：这个方法获取了获取了MappedStatement对象，并最终调用了Executor的query方法；</li>
</ul>
<p>流程图总结</p>
<p><a href="https://www.processon.com/view/link/62f29f3de401fd2fc7cc3731">MyBatis SQL执行流程</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>源码框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高并发缓存架构实战</title>
    <url>/2022/06/03/03-00-08-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Redis高并发缓存架构实战"><a href="#一、Redis高并发缓存架构实战" class="headerlink" title="一、Redis高并发缓存架构实战"></a>一、Redis高并发缓存架构实战</h2><h3 id="1、Redis集群架构下的分布式锁存在什么问题？"><a href="#1、Redis集群架构下的分布式锁存在什么问题？" class="headerlink" title="1、Redis集群架构下的分布式锁存在什么问题？"></a>1、Redis集群架构下的分布式锁存在什么问题？</h3><ul>
<li><p>主从节点切换可能会丢失redis锁的key</p>
<blockquote>
<p>比如：有一个主从redis（RedisA作为master，RedisB作为slave）线程一写RedisA成功，返回给客户端（RedisB还没来得及同步key），之后RedisA挂掉了，RedisB切换为主节点；此时线程二请求加锁，可以加锁成功</p>
<p>ZooKeeper可以解决节点切换导致key丢失的问题，但是性能不如redis</p>
</blockquote>
</li>
<li><p>RedLock能解决上述节点切换丢失redis 分布式锁key的问题吗？</p>
<blockquote>
<p>红锁原理：使用红锁，先要配置多个Redis节点（非集群，彼此之间没有关联，对等的单节点）。加锁的时候对多个Redis节点加锁，多个节点的返回结果要大于半数以上才算加锁成功（比如有3个节点，至少有两个反馈加锁成功，才认为加锁成功，所以第一个问题就来了，多个节点挂掉后，后续加锁操作可能无法进行）。<strong>红锁不推荐使用。</strong></p>
<p><strong>红锁的使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lockKey = <span class="string">&quot;product_001&quot;</span>;</span><br><span class="line">        <span class="comment">//这里需要自己实例化不同redis实例的redisson客户端连接，这里只是伪代码用一个redisson客户端简化了</span></span><br><span class="line">        RLock lock1 = redisson1.getLock(lockKey);</span><br><span class="line">        RLock lock2 = redisson2.getLock(lockKey);</span><br><span class="line">        RLock lock3 = redisson3.getLock(lockKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">             * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">boolean</span> res = redLock.tryLock(<span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">//成功获得锁，在这里处理业务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;lock fail&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//无论如何, 最后都要解锁</span></span><br><span class="line">            redLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>红锁存在的问题：</p>
<p>1&gt;  如果redis每个节点为了保证可用性一般会加从节点；比如有三组Redis（【redis1主、redis2从】、【redis3主、redis4从】、【redis5主、redis6从】）。线程thread1加锁redis1节点成功，加锁thread3节点成功，此时从节点redis4数据还没有同步，然后redis3节点挂了；这个时候有thread2加锁，redis1节点加锁失败（因为被thread1加锁占用）、redis4加锁成功（redis3挂了，redis4就成了主节点，redis4没有同步之前redis3的数据，故可以加锁成功），redis5加锁成功（thread1还没有对thread5加锁）</p>
<p>可能的解决方法：</p>
<p>①不加从节点：有问题，当多个主节点挂了，因为加锁成功半数机制存在，可能导致后续所有的锁都无法加锁成功</p>
<p>②多搞几个节点：性能问题，节点越多，性能越差。用redis本来就是追求高性能，这样适得其反，还不如用zk。</p>
<p>2&gt; 持久化问题：redis一般会用aof持久化。一般是一秒执行一次持久化。那么究存在问题，这一秒之内的数据可能会丢失，可能导致锁的key丢失，从而造成多个线程对同一个锁key加锁成功，这样就有问题。</p>
</blockquote>
</li>
</ul>
<h3 id="2、大促场景下分布式锁性能提升"><a href="#2、大促场景下分布式锁性能提升" class="headerlink" title="2、大促场景下分布式锁性能提升"></a>2、大促场景下分布式锁性能提升</h3><ul>
<li><p>锁的粒度：越小越好，没有必要加锁的代码并行执行</p>
</li>
<li><p>分段锁的思想：</p>
<blockquote>
<p>举例一个秒杀减库存场景：</p>
<p>redis中的key：product_101_stock     value ：500（初始库存）</p>
<p>分段锁的思想是：把这个500个库存分为多个key存储，比如五个</p>
<p>{key:product_101_stock_1     value ：100}</p>
<p>{key:product_101_stock_2     value ：100}</p>
<p>{key:product_101_stock_3     value ：100}</p>
<p>{key:product_101_stock_4     value ：100}</p>
<p>{key:product_101_stock_5     value ：100}</p>
<p>由原来的一次性用一个key锁500个库存，改为用5个key分别锁100个库存</p>
<p>减库存的时候多个线程就可以减不同key的库存，（每个线程来的时候可以随机/轮询选择某个key，当一个key库存减完，就设置一个标记，下次线程就不选这个key了）。1.7的ConcurrentHashMap中就用到了分段锁的思想。</p>
</blockquote>
</li>
</ul>
<h3 id="3、大厂的缓存架构实现"><a href="#3、大厂的缓存架构实现" class="headerlink" title="3、大厂的缓存架构实现"></a>3、大厂的缓存架构实现</h3><p><img src="/2022/06/03/03-00-08-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/image-20220603222145251.png" alt="image-20220603222145251"></p>
<ul>
<li><p>大规模商品缓存数据冷热分离</p>
<p><img src="/2022/06/03/03-00-08-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/image-20220603224606359.png" alt="image-20220603224606359"></p>
</li>
<li><p>缓存击穿（缓存失效）</p>
<blockquote>
<p>定义：由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好<strong>将这一批数据的缓存过期时间设置为一个时间段内的不同时间。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 过期时间设置为随机数</span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">genProductCacheTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加随机超时机制解决缓存批量失效(击穿)问题</span></span><br><span class="line">        <span class="keyword">return</span> PRODUCT_CACHE_TIMEOUT + <span class="keyword">new</span> Random().nextInt(<span class="number">5</span>) * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>缓存穿透</p>
<blockquote>
<p>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。</p>
<p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。</p>
<p>造成缓存穿透的基本原因有两个：</p>
<p>第一， 自身业务代码或者数据出现问题。</p>
<p>第二， 一些恶意攻击、 爬虫等造成大量空命中。 </p>
<p>缓存穿透问题解决方案：</p>
<ul>
<li><p>1、缓存空对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2、布隆过滤器</p>
<p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说<strong>某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。</strong></p>
<p><img src="/2022/06/03/03-00-08-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/image-20220603230112939.png" alt="image-20220603230112939"></p>
<p>布隆过滤器就是<strong>一个大型的位数组和几个不一样的无偏 hash 函数</strong>。所谓无偏就是能够把元素的 hash 值算得比较均匀。</p>
<p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</p>
<p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组长度比较大，存在概率就会很大，如果这个位数组长度比较小，存在概率就会降低。</p>
<p>这种方法适用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景， 代码维护较为复杂， 但是<strong>缓存空间占用很少</strong>。</p>
<p>可以用redisson实现布隆过滤器，引入依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">3.6</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redisson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line">        <span class="comment">//构造Redisson</span></span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;nameList&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%,根据这两个参数会计算出底层的bit数组大小</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">        <span class="comment">//将zhuge插入到布隆过滤器中</span></span><br><span class="line">        bloomFilter.add(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断下面号码是否在布隆过滤器中</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;guojia&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;baiqi&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;zhuge&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：布隆过滤器不能删除数据，如果要删除得重新初始化数据。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>缓存雪崩</p>
<p>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层。</p>
<p>由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会打到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情况。 </p>
<p>预防和解决缓存雪崩问题， 可以从以下三个方面进行着手。</p>
<p>1） 保证缓存层服务高可用性，比如使用Redis Sentinel或Redis Cluster。</p>
<p>2） 依赖隔离组件为后端限流熔断并降级。比如使用Sentinel或Hystrix限流降级组件。</p>
<p>比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</p>
<p>3） 提前演练。 在项目上线前， 演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</p>
<p>4）多级缓存架构</p>
<ul>
<li><p>加一级JVM缓存【每秒可以抗百万并发】，这种方案要考虑不同服务器间的jvm缓存的一致性，可以通过mq、redis发布订阅等方式解决。</p>
</li>
<li><p>还可能出现短时间的数据不一致，使用了多级缓存，一般这种场景可以容忍。</p>
</li>
<li><p>大型互联网公司，还会有热点缓存计算系统（一种可以实现的方式：对redis的数据做aop拦截，然后将redis数据发送到计算系统中，计算系统通过大数据的实时计算系统维护热点缓存，这样web应用系统也做了解耦）【负责put热点数据，web应用系统直接get获取】，所有的web应用会跟这个系统建立联系，比如监听（web应用监听到缓存系统的数据之后，就将数据写入到自己本地缓存）。为什么不web应用自己维护本地缓存，自己put呢？因为数据会变化，可能现在是热点数据，过一会就不是热点数据了。</p>
</li>
</ul>
</li>
<li><p>突发性热点缓存重建导致系统压力暴增</p>
<ul>
<li><p>DCL双重检查锁：使用于单机，如果集群环境使用，可能重建缓存会多次</p>
</li>
<li><p>分布式锁重建缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">get</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String productCacheKey = RedisKeyPrefixConst.PRODUCT_CACHE + productId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从缓存里查数据</span></span><br><span class="line">        product = getProductFromCache(productCacheKey);</span><br><span class="line">        <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加分布式锁解决热点缓存并发重建问题</span></span><br><span class="line">        RLock hotCreateCacheLock = redisson.getLock(LOCK_PRODUCT_HOT_CACHE_CREATE_PREFIX + productId);</span><br><span class="line">        hotCreateCacheLock.lock();</span><br><span class="line">        <span class="comment">// 这个优化谨慎使用，防止超时导致的大规模并发重建问题</span></span><br><span class="line">        <span class="comment">// hotCreateCacheLock.tryLock(1, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            product = getProductFromCache(productCacheKey);</span><br><span class="line">            <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//RLock productUpdateLock = redisson.getLock(LOCK_PRODUCT_UPDATE_PREFIX + productId);</span></span><br><span class="line">            RReadWriteLock productUpdateLock = redisson.getReadWriteLock(LOCK_PRODUCT_UPDATE_PREFIX + productId);</span><br><span class="line">            RLock rLock = productUpdateLock.readLock();</span><br><span class="line">            <span class="comment">//加分布式读锁解决缓存双写不一致问题</span></span><br><span class="line">            rLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                product = productDao.get(productId);</span><br><span class="line">                <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    redisUtil.set(productCacheKey, JSON.toJSONString(product),</span><br><span class="line">                            genProductCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//设置空缓存解决缓存穿透问题</span></span><br><span class="line">                    redisUtil.set(productCacheKey, EMPTY_CACHE, genEmptyCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            hotCreateCacheLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>缓存和数据库双写不一致问题</p>
<p>​    原因：</p>
<p>​    </p>
<p><img src="/2022/06/03/03-00-08-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/image-20220604174453971.png" alt="image-20220604174453971"></p>
<p>​    <img src="/2022/06/03/03-00-08-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/image-20220604174616840.png" alt="image-20220604174616840"></p>
<ul>
<li>加分布式锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">get</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">       Product product = <span class="keyword">null</span>;</span><br><span class="line">       String productCacheKey = RedisKeyPrefixConst.PRODUCT_CACHE + productId;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//从缓存里查数据</span></span><br><span class="line">       product = getProductFromCache(productCacheKey);</span><br><span class="line">       <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> product;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//加分布式锁解决热点缓存并发重建问题</span></span><br><span class="line">       RLock hotCreateCacheLock = redisson.getLock(LOCK_PRODUCT_HOT_CACHE_CREATE_PREFIX + productId);</span><br><span class="line">       hotCreateCacheLock.lock();</span><br><span class="line">       <span class="comment">// 这个优化谨慎使用，防止超时导致的大规模并发重建问题</span></span><br><span class="line">       <span class="comment">// hotCreateCacheLock.tryLock(1, TimeUnit.SECONDS);</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           product = getProductFromCache(productCacheKey);</span><br><span class="line">           <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> product;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           RLock productUpdateLock = redisson.getLock(LOCK_PRODUCT_UPDATE_PREFIX + productId);</span><br><span class="line">           <span class="comment">// RReadWriteLock productUpdateLock = redisson.getReadWriteLock(LOCK_PRODUCT_UPDATE_PREFIX + productId);</span></span><br><span class="line">           <span class="comment">// RLock rLock = productUpdateLock.readLock();</span></span><br><span class="line">           <span class="comment">//加分布式读锁解决缓存双写不一致问题</span></span><br><span class="line">           productUpdateLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               product = productDao.get(productId);</span><br><span class="line">               <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   redisUtil.set(productCacheKey, JSON.toJSONString(product),</span><br><span class="line">                           genProductCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//设置空缓存解决缓存穿透问题</span></span><br><span class="line">                   redisUtil.set(productCacheKey, EMPTY_CACHE, genEmptyCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               productUpdateLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           hotCreateCacheLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> product;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读多写少【主要说的是数据库的读和写】的场景，使用分布式的读写锁，使用Redisson的ReadWriteLock</p>
<p>如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Product <span class="title">get</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String productCacheKey = RedisKeyPrefixConst.PRODUCT_CACHE + productId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从缓存里查数据</span></span><br><span class="line">        product = getProductFromCache(productCacheKey);</span><br><span class="line">        <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加分布式锁解决热点缓存并发重建问题</span></span><br><span class="line">        RLock hotCreateCacheLock = redisson.getLock(LOCK_PRODUCT_HOT_CACHE_CREATE_PREFIX + productId);</span><br><span class="line">        hotCreateCacheLock.lock();</span><br><span class="line">        <span class="comment">// 这个优化谨慎使用，防止超时导致的大规模并发重建问题</span></span><br><span class="line">        <span class="comment">// hotCreateCacheLock.tryLock(1, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            product = getProductFromCache(productCacheKey);</span><br><span class="line">            <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//RLock productUpdateLock = redisson.getLock(LOCK_PRODUCT_UPDATE_PREFIX + productId);</span></span><br><span class="line">            RReadWriteLock productUpdateLock = redisson.getReadWriteLock(LOCK_PRODUCT_UPDATE_PREFIX + productId);</span><br><span class="line">            RLock rLock = productUpdateLock.readLock(); <span class="comment">// 加读锁</span></span><br><span class="line">            <span class="comment">//加分布式读锁解决缓存双写不一致问题</span></span><br><span class="line">            rLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                product = productDao.get(productId);</span><br><span class="line">                <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    redisUtil.set(productCacheKey, JSON.toJSONString(product),</span><br><span class="line">                            genProductCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//设置空缓存解决缓存穿透问题</span></span><br><span class="line">                    redisUtil.set(productCacheKey, EMPTY_CACHE, genEmptyCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            hotCreateCacheLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 加写锁</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">update</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        Product productResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//RLock productUpdateLock = redisson.getLock(LOCK_PRODUCT_UPDATE_PREFIX + product.getId());</span></span><br><span class="line">        RReadWriteLock productUpdateLock = redisson.getReadWriteLock(LOCK_PRODUCT_UPDATE_PREFIX + product.getId());</span><br><span class="line">        RLock writeLock = productUpdateLock.writeLock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="comment">//加分布式写锁解决缓存双写不一致问题</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            productResult = productDao.update(product);</span><br><span class="line">            redisUtil.set(RedisKeyPrefixConst.PRODUCT_CACHE + productResult.getId(), JSON.toJSONString(productResult),</span><br><span class="line">                    genProductCacheTimeout(), TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> productResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>缓存重建 加的分布式锁优化====&gt;加个阻塞时间，适用于明确知道执行时间的，否则不要轻易使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##上述讲到了重建缓存加了分布式锁，代码如下</span><br><span class="line"><span class="comment">//加分布式锁解决热点缓存并发重建问题</span></span><br><span class="line">RLock hotCreateCacheLock = redisson.getLock(LOCK_PRODUCT_HOT_CACHE_CREATE_PREFIX + productId);</span><br><span class="line">hotCreateCacheLock.lock();</span><br><span class="line"><span class="comment">// 这个优化谨慎使用，防止超时导致的大规模并发重建问题</span></span><br><span class="line"><span class="comment">// hotCreateCacheLock.tryLock(1, TimeUnit.SECONDS);</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    hotCreateCacheLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper典型使用场景实战</title>
    <url>/2022/06/11/03-02-02-Zookeeper%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、Zookeeper典型使用场景实战"><a href="#一、Zookeeper典型使用场景实战" class="headerlink" title="一、Zookeeper典型使用场景实战"></a>一、Zookeeper典型使用场景实战</h2><h3 id="1、Zookeeper实现分布式锁"><a href="#1、Zookeeper实现分布式锁" class="headerlink" title="1、Zookeeper实现分布式锁"></a>1、Zookeeper实现分布式锁</h3><h4 id="1-1-非公平锁"><a href="#1-1-非公平锁" class="headerlink" title="1.1 非公平锁"></a>1.1 非公平锁</h4><p><strong>原理：</strong></p>
<p><img src="/2022/06/11/03-02-02-Zookeeper%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/image-20220611194332769.png" alt="image-20220611194332769"></p>
<blockquote>
<p>原理（是非公平锁，因为监听等待的线程在重新加锁的时候是没有顺序的，无法控制先来后到）：模拟两个线程并发获取锁</p>
<p>1&gt;thread1获取锁（通过命令create -e /exclusive/lock创建节点），判断锁是否被创建，此时没有被创建可以加锁成功；</p>
<p>2&gt;thread2此时来获取锁，判断锁释放被创建，此时锁被创建，则thread2会监听 /exclusive/lock节点（执行get -w /exclusive/lock命令），等待拿到锁的线程对锁进行释放</p>
<p>3&gt;thread1执行完业务逻辑，就释放锁（执行delete /exclusive/lock命令），此时thread2通过监听得知锁被释放，然后就尝试进行加锁，加锁成功，执行业务逻辑，然后释放锁</p>
<p><strong>这种非公平锁的缺点：</strong></p>
<p>加入竞争锁，导致等待的线程非常多，当一个线程使用完锁，释放锁之后，其余线程都会尝试去加锁，但是只能有一个线程可以成功获取到锁。这样循环往复会对zookeeper造成很大的压力。<strong>这就是著名的羊群效应，也叫惊群效应</strong></p>
</blockquote>
<h4 id="1-2-公平锁"><a href="#1-2-公平锁" class="headerlink" title="1.2 公平锁"></a>1.2 公平锁</h4><p><strong>原理：</strong></p>
<p><img src="/2022/06/11/03-02-02-Zookeeper%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/image-20220611194440831.png" alt="image-20220611194440831"></p>
<blockquote>
<p>基于临时顺序节点加锁（公平性，要加锁的线程排序，临时顺序节点维护了先来后到的顺序）：</p>
<p>原理：模拟多个线程并发举例</p>
<p>1&gt;thread1请求加锁，会创建一个临时顺序节点（/x-0000000000），然后thread1会查询/lock下的所有的节点，判断自己是不是最小的节点，如果是则加锁成功，获得锁</p>
<p>2&gt;后续的线程加锁请求比如thread2加锁会先创建顺序节点（/x-0000000001），然后监听他的上一个节点。</p>
<p>3&gt;thread1执行完业务逻辑，就要释放锁，删除当前临时节点，然后会通知监听它的下一个节点（/x-0000000001）</p>
<p>4&gt;当thread2收到通知后，会获取/lock下面的所有子节点，然后判断自己的节点是不是当前最小节点，此时是最小节点，则thread2获取锁，执行自己的业务逻辑</p>
<p>5&gt;以此类推，就实现了公平锁</p>
<p>另：</p>
<p>1&gt;一般来说节点都是顺序的，如果按上图，0000000001节点被删除了（可能客户端连接挂了），这个节点会被清除掉；节点就会变为不连续了。</p>
<p>2&gt;假如此时000000000还在使用锁执行业务逻辑。</p>
<p>3&gt;000000001被删除0000000002会收到通知,会获取/lock下的所有子节点，判断0000000002是否是当前最小节点。</p>
<p>3&gt;如果000000000还没有释放，则不是最小节点，00000002会对00000000进行监听；如果是最小节点，则获取锁</p>
<p>还有一种情况：</p>
<p>比如一个客户端请求在zookeeper上加锁，服务端执行完创建节点命令，已经有数据了，但是服务端响应客户端失败了，即客户端不知道自己创建节点成功。</p>
<p>1&gt;如果session还在生命周期以内，服务端停掉了，立马重启，session还是有效的</p>
<p>2&gt;使用curator的话会自动重试，这样的话会创建多个临时顺序节点。那第一个创建的节点不会做任何处理，第一个节点我们称之为<strong>幽灵节点</strong></p>
<p><strong>3&gt;解决这种问题可以使用curator的保护模式（原理，创建节点的时候带一个前缀唯一标识，这个标识会维护在本地缓存中，重试的场景下，先判断这个唯一标志对应的节点有没有被创建过，已经创建过就不在重建了，避免了幽灵节点的产生）。</strong></p>
</blockquote>
<h4 id="1-3-curator实现的分布式锁原理"><a href="#1-3-curator实现的分布式锁原理" class="headerlink" title="1.3 curator实现的分布式锁原理"></a>1.3 curator实现的分布式锁原理</h4><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CuratorFramework curatorFramework;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/stock/deduct&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(curatorFramework, <span class="string">&quot;/product_&quot;</span> + id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            interProcessMutex.acquire();<span class="comment">// 【0】</span></span><br><span class="line">            orderService.reduceStock(id);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            interProcessMutex.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok:&quot;</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 加锁原理分析：</span><br><span class="line">---------&gt;【<span class="number">0</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !internalLock(-<span class="number">1</span>, <span class="keyword">null</span>) )<span class="comment">// 【1】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Lost connection while trying to acquire lock: &quot;</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------&gt;【<span class="number">1</span>】</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// re-entering</span></span><br><span class="line">        lockData.lockCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes()); <span class="comment">// 【2】</span></span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------【<span class="number">2</span>】</span><br><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>      startMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> Long      millisToWait = (unit != <span class="keyword">null</span>) ? unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="keyword">null</span>) ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">    <span class="keyword">int</span>             retryCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    String          ourPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         isDone = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !isDone )</span><br><span class="line">    &#123;</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ourPath = driver.createsTheLock(client, path, localLockNodeBytes); <span class="comment">// 【3】 创建节点</span></span><br><span class="line">            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath); <span class="comment">// 【4】 判断是不是最小节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// gets thrown by StandardLockInternalsDriver when it can&#x27;t find the lock node</span></span><br><span class="line">            <span class="comment">// this can happen when the session expires, etc. So, if the retry allows, just try it all again</span></span><br><span class="line">            <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )</span><br><span class="line">            &#123;</span><br><span class="line">                isDone = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( hasTheLock )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ourPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------&gt;【<span class="number">3</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String ourPath;</span><br><span class="line">    <span class="keyword">if</span> ( lockNodeBytes != <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 父节点是容器节点  子节点是 临时顺序节点</span></span><br><span class="line">        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">&#125;</span><br><span class="line">--------&gt;【<span class="number">4</span>】</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>     haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>     doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock )</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren();  <span class="comment">// 获取所有的节点并进行排序</span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash</span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases); <span class="comment">// 【5】 判断当前节点是不是最小节点</span></span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() ) <span class="comment">// 为true 是最小节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 不是最小节点</span></span><br><span class="line">            &#123; </span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">&quot;/&quot;</span> + predicateResults.getPathToWatch(); <span class="comment">// 拼接全路径</span></span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</span></span><br><span class="line">                        client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            wait(millisToWait); <span class="comment">// 监听等待 加锁目的</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            wait(); <span class="comment">// 监听等待 加锁目的</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e )&#123;</span><br><span class="line">        ThreadUtils.checkInterrupted(e);</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( doDelete )&#123;</span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br><span class="line">---------&gt;【<span class="number">5</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>             ourIndex = children.indexOf(sequenceNodeName);</span><br><span class="line">    validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line">    <span class="keyword">boolean</span>         getsTheLock = ourIndex &lt; maxLeases;</span><br><span class="line">    String          pathToWatch = getsTheLock ? <span class="keyword">null</span> : children.get(ourIndex - maxLeases); <span class="comment">// 当前节点是最小节点 不需要监听 如果不是最小节点则监听前一个节点，</span></span><br><span class="line">    <span class="comment">// 返回前一个几点路径索引</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(pathToWatch, getsTheLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-redis实现的分布式锁和zk实现的分布式锁有什么区别？"><a href="#1-4-redis实现的分布式锁和zk实现的分布式锁有什么区别？" class="headerlink" title="1.4 redis实现的分布式锁和zk实现的分布式锁有什么区别？"></a>1.4 redis实现的分布式锁和zk实现的分布式锁有什么区别？</h4><p>redis一般生产使用集群模式，集群模式当主从切换时，可能会有数据丢失问题，当加锁的key在主从切换空挡出现了数据丢失，那么就很可能出现之前已经加过的锁，在主从切换之后还能加锁成功，因为之前加的锁的key可能已经丢失了。</p>
<p>而zk写入数据的时候有过半机制，当写入leader节点时，还会同步数据写入flower节点，当过半写入成功（没写入成功的会跟leader数据同步）才算写入成功，因为数据的保存比redis更安全。</p>
<h4 id="1-5-读写锁（共享锁）"><a href="#1-5-读写锁（共享锁）" class="headerlink" title="1.5 读写锁（共享锁）"></a>1.5 读写锁（共享锁）</h4><blockquote>
<p>前面这两种加锁方式有一个共同的特质，就是都是<strong>互斥锁</strong>，同一时间只能有一个请求占用，如果是大量的并发上来，性能是会急剧下降的，所有的请求都得加锁，那是不是真的所有的请求都需要加锁呢？答案是否定的，比如如果数据没有进行任何修改的话，是不需要加锁的，但是如果读数据的请求还没读完，这个时候来了一个写请求，怎么办呢？有人已经在读数据了，这个时候是不能写数据的，不然数据就不正确了。直到前面读锁全部释放掉以后，写请求才能执行，所以需要给这个读请求加一个标识（读锁），让写请求知道，这个时候是不能修改数据的。不然数据就不一致了。如果已经有人在写数据了，再来一个请求写数据，也是不允许的，这样也会导致数据的不一致，所以所有的写请求，都需要加一个写锁，是为了避免同时对共享数据进行写操作。</p>
</blockquote>
<ul>
<li><p>原理</p>
<p><img src="/2022/06/11/03-02-02-Zookeeper%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/image-20220611200951116.png" alt="image-20220611200951116"></p>
</li>
</ul>
<blockquote>
<p><strong>写操作：</strong></p>
<p>前面不能有读，不能有写，写操作监听前面一个节点</p>
<p><strong>读操作：</strong></p>
<p>前面不能有写，监听前面的最近的写操作</p>
</blockquote>
<h4 id="1-6-集群选举实战："><a href="#1-6-集群选举实战：" class="headerlink" title="1.6 集群选举实战："></a>1.6 <strong>集群选举实战：</strong></h4><p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zookeeper.leaderselector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  String CONNECT_STR=<span class="string">&quot;192.168.31.139:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RetryPolicy retryPolicy=<span class="keyword">new</span> ExponentialBackoffRetry( <span class="number">5</span>*<span class="number">1000</span>, <span class="number">10</span> );</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  CuratorFramework curatorFramework;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String appName = System.getProperty(<span class="string">&quot;appName&quot;</span>);</span><br><span class="line">        CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(CONNECT_STR, retryPolicy);</span><br><span class="line">        LeaderSelectorDemo.curatorFramework = curatorFramework;</span><br><span class="line">        curatorFramework.start();</span><br><span class="line"></span><br><span class="line">        LeaderSelectorListener listener = <span class="keyword">new</span> LeaderSelectorListenerAdapter()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; I&#x27; m leader now . i&#x27;m , &quot;</span>+appName);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">15</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        LeaderSelector selector = <span class="keyword">new</span> LeaderSelector(curatorFramework, <span class="string">&quot;/cachePreHeat_leader&quot;</span>, listener);</span><br><span class="line">        selector.autoRequeue();  <span class="comment">// not required, but this is behavior that you will probably expect</span></span><br><span class="line">        selector.start(); <span class="comment">// 【0】</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 关键源码</span><br><span class="line">----------&gt;【<span class="number">0</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), <span class="string">&quot;Cannot be started more than once&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Preconditions.checkState(!executorService.isShutdown(), <span class="string">&quot;Already started&quot;</span>);</span><br><span class="line">    Preconditions.checkState(!hasLeadership, <span class="string">&quot;Already has leadership&quot;</span>);</span><br><span class="line"></span><br><span class="line">    client.getConnectionStateListenable().addListener(listener); <span class="comment">// main中添加的监听方法</span></span><br><span class="line">    requeue(); <span class="comment">// 【1】</span></span><br><span class="line">&#125;</span><br><span class="line">----------&gt;【<span class="number">1</span>】</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Preconditions.checkState(state.get() == State.STARTED, <span class="string">&quot;close() has already been called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> internalRequeue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">internalRequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !isQueued &amp;&amp; (state.get() == State.STARTED) ) <span class="comment">// 判断任务是否时正常状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        isQueued = <span class="keyword">true</span>;</span><br><span class="line">        Future&lt;Void&gt; task = executorService.submit(<span class="keyword">new</span> Callable&lt;Void&gt;() <span class="comment">// 线程池执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    doWorkLoop(); <span class="comment">// 【2】</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    clearIsQueued();</span><br><span class="line">                    <span class="keyword">if</span> ( autoRequeue.get() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        internalRequeue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ourTask.set(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------&gt;【<span class="number">2</span>】</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorkLoop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KeeperException exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        doWork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( KeeperException.ConnectionLossException e )</span><br><span class="line">    &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( KeeperException.SessionExpiredException e )</span><br><span class="line">    &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( InterruptedException ignore )</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (exception != <span class="keyword">null</span>) &amp;&amp; !autoRequeue.get() )   <span class="comment">// autoRequeue should ignore connection loss or session expired and just keep trying</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hasLeadership = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex.acquire();  <span class="comment">// 获取分布式锁的逻辑</span></span><br><span class="line"></span><br><span class="line">        hasLeadership = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( debugLeadershipLatch != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                debugLeadershipLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( debugLeadershipWaitLatch != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                debugLeadershipWaitLatch.await();</span><br><span class="line">            &#125;</span><br><span class="line">            listener.takeLeadership(client);  <span class="comment">// 执行leader选举算法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( InterruptedException e )</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Throwable e )</span><br><span class="line">        &#123;</span><br><span class="line">            ThreadUtils.checkInterrupted(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            clearIsQueued();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( InterruptedException e )</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( hasLeadership )</span><br><span class="line">        &#123;</span><br><span class="line">            hasLeadership = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> wasInterrupted = Thread.interrupted();  <span class="comment">// clear any interrupted tatus so that mutex.release() works immediately</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                mutex.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( failedMutexReleaseCount != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    failedMutexReleaseCount.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ThreadUtils.checkInterrupted(e);</span><br><span class="line">                log.error(<span class="string">&quot;The leader threw an exception&quot;</span>, e);</span><br><span class="line">                <span class="comment">// ignore errors - this is just a safety</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( wasInterrupted )</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">原理：</span><br><span class="line">底层就是一个公平锁实现</span><br></pre></td></tr></table></figure>

<h4 id="1-7-注册中心实战"><a href="#1-7-注册中心实战" class="headerlink" title="1.7 注册中心实战"></a>1.7 <strong>注册中心实战</strong></h4><blockquote>
<p>这个时候我们可以借助于Zookeeper的基本特性来实现一个注册中心,什么是注册中心，顾名思义，就是让众多的服务，都在Zookeeper中进行注册，啥是注册，注册就是把自己的一些服务信息，比如IP，端口，还有一些更加具体的服务信息，都写到 Zookeeper节点上， 这样有需要的服务就可以直接从zookeeper上面去拿，怎么拿呢？ 这时我们可以定义统一的名称，比如，User-Service, 那所有的<strong>用户服务</strong>在<strong>启动</strong>的时候，都在User-Service 这个节点下面创建一个子节点（临时节点），这个子节点保持唯一就好，代表了每个服务实例的唯一标识，有依赖<strong>用户服务</strong>的比如<strong>Order-Service</strong> 就可以通过<strong>User-Service</strong> 这个父节点，就能获取所有的User-Service 子节点，并且获取所有的子节点信息（IP，端口等信息），拿到子节点的数据后<strong>Order-Service</strong>可以对其进行缓存，然后实现一个客户端的负载均衡，同时还可以对这个User-Service 目录进行监听， 这样有新的节点加入，或者退出，<strong>Order-Service</strong>都能收到通知，这样<strong>Order-Service</strong>重新获取所有子节点，且进行数据更新。这个用户服务的子节点的类型为临时节点。 第一节课有讲过，Zookeeper中临时节点生命周期是和SESSION绑定的，如果SESSION超时了，对应的节点会被删除，被删除时，Zookeeper 会通知对该节点父节点进行监听的客户端, 这样对应的客户端又可以刷新本地缓存了。当有新服务加入时，同样也会通知对应的客户端，刷新本地缓存，要达到这个目标需要客户端重复的注册对父节点的监听。这样就实现了服务的自动注册和自动退出。</p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>RoketMQ源码分析</title>
    <url>/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="RocketMQ源码分析"><a href="#RocketMQ源码分析" class="headerlink" title="RocketMQ源码分析"></a>RocketMQ源码分析</h1><h2 id="1、源码环境搭建"><a href="#1、源码环境搭建" class="headerlink" title="1、源码环境搭建"></a>1、源码环境搭建</h2><blockquote>
<p>RocketMQ官方仓库：<a href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a> ，选用4.7.1版本</p>
<p>几个模块：</p>
<ul>
<li>broker: broker 模块（broke 启动进程）</li>
<li>client ：消息客户端，包含消息生产者、消息消费者相关类</li>
<li>example: RocketMQ 例代码</li>
<li>namesrv：NameServer实现相关类（NameServer启动进程）</li>
<li>store：消息存储实现相关类</li>
</ul>
</blockquote>
<h2 id="2、-启动nameServer"><a href="#2、-启动nameServer" class="headerlink" title="2、 启动nameServer"></a>2、 启动nameServer</h2><blockquote>
<p>源码路径：namesrv-&gt;NamesrvStartup-&gt;main()方法</p>
<p>nameserver作用：</p>
<ul>
<li>维护Broker的服务地址并进行及时的更新</li>
<li>给Producer和Consumer提供服务获取Broker列表</li>
</ul>
</blockquote>
<h3 id="2-1、启动流程"><a href="#2-1、启动流程" class="headerlink" title="2.1、启动流程"></a>2.1、启动流程</h3><p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="NameServer启动流程"></p>
<h3 id="2-2、源码核心"><a href="#2-2、源码核心" class="headerlink" title="2.2、源码核心"></a>2.2、源码核心</h3><p>整个NameServer的核心就是一个NamesrvController对象。这个controller对象就跟java Web开发中的Controller功能类似，都是响应客户端请求的。</p>
<p>在创建NamesrvController对象时，有两个关键的配置</p>
<ul>
<li>NamesrvConfig 这个是NameServer自己运行需要的配置信息。</li>
<li>NettyServerConfig 包含Netty服务端的配置参数，默认占用了9876端口。可以在配置文件中覆盖。</li>
</ul>
<p>然后在启动服务时，启动几个重要组件：</p>
<ul>
<li>RemotingServer 这个就是用来响应请求的。</li>
<li>还有一个定时任务会定时扫描不活动的Broker。这个Broker管理是通过routeInfoManager这个功能组件。</li>
</ul>
<p>在关闭服务时，关闭了四个东西</p>
<ul>
<li>RemotingServer</li>
<li>remotingExecutor Netty服务线程池;</li>
<li>scheduledExecutorService 定时任务;</li>
<li>fileWatchService 这个是用来跟踪TLS配置的。这是跟权限相关的，我们暂不关注。</li>
<li>从启动和关闭这两个关键步骤，我们可以总结出NameServer的组件其实并不是很多，整个NameServer的结构是这样：</li>
</ul>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%BA%90%E7%A0%81Nameserver1.png" alt="源码Nameserver1"></p>
<h2 id="3、启动Broker"><a href="#3、启动Broker" class="headerlink" title="3、启动Broker"></a>3、启动Broker</h2><blockquote>
<p>源码路径：</p>
<p>Broker是整个RocketMQ的业务核心，所有消息存储、转发这些最为重要的业务都是在Broker中进行处理的。</p>
<p>而Broker的内部架构，有点类似于JavaWeb开发的MVC架构。有Controller负责响应请求，各种Service组件负责具体业务，然后还有负责消息存盘的功能模块则类似于Dao。</p>
<p>所以我们这一段的重点，是通过Broker的启动过程，观察总结出Broker的内部结构。</p>
</blockquote>
<p>Broker启动的入口在BrokerStartup这个类，可以从他的main方法开始调试。</p>
<p>启动过程关键点：</p>
<p>重点也是围绕一个BrokerController对象，先创建，然后再启动。</p>
<p><strong>首先：</strong> 在BrokerStartup.createBrokerController方法中可以看到Broker的几个核心配置：</p>
<p> BrokerConfig</p>
<p> NettyServerConfig ：Netty服务端占用了10911端口。同样也可以在配置文件中覆盖。</p>
<p> NettyClientConfig</p>
<p> MessageStoreConfig</p>
<p><strong>然后：</strong> 在BrokerController.start方法可以看到启动了一大堆Broker的核心服务，我们挑一些重要的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.messageStore.start();启动核心的消息存储组件</span><br><span class="line"></span><br><span class="line">this.remotingServer.start();</span><br><span class="line">this.fastRemotingServer.start(); 启动两个Netty服务</span><br><span class="line"></span><br><span class="line">this.brokerOuterAPI.start();启动客户端，往外发请求</span><br><span class="line"></span><br><span class="line">BrokerController.this.registerBrokerAll： 向NameServer注册心跳。</span><br><span class="line"></span><br><span class="line">this.brokerStatsManager.start();</span><br><span class="line">this.brokerFastFailure.start();这也是一些负责具体业务的功能组件</span><br></pre></td></tr></table></figure>

<p>我们现在不需要了解这些核心组件的具体功能，只要有个大概，Broker中有一大堆的功能组件负责具体的业务。后面等到分析具体业务时再去深入每个服务的细节。</p>
<p>我们需要抽象出Broker的一个整体结构：</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Broker%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90.png" alt="Broker核心组成"></p>
<h2 id="4、Broker注册"><a href="#4、Broker注册" class="headerlink" title="4、Broker注册"></a>4、Broker注册</h2><blockquote>
<p> 在之前我们已经介绍到了。Broker会在启动时向NameServer注册自己的服务信息，并且会定时的往NameServer发送心跳信息。而NameServer会维护Broker的路由列表，并对路由列表进行实时更新。</p>
</blockquote>
<h3 id="4-1-源码重点"><a href="#4-1-源码重点" class="headerlink" title="4.1 源码重点"></a>4.1 源码重点</h3><p>BrokerController.this.registerBrokerAll方法会发起向NameServer注册心跳。启动时会立即注册，同时也会启动一个线程池，以10秒延迟，默认30秒的间隔 持续向NameServer发送心跳。</p>
<p>BrokerController.this.registerBrokerAll这个方法就是注册心跳的入口。</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Broker%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" alt="Broker注册流程"></p>
<p>然后，在NameServer中也会启动一个定时任务，扫描不活动的Broker。具体观察NamesrvController.initialize方法</p>
<h2 id="5、Producer"><a href="#5、Producer" class="headerlink" title="5、Producer"></a>5、Producer</h2><blockquote>
<p>Producer有两种</p>
<ul>
<li>一种是普通发送者：DefaultMQProducer。这个只需要构建一个Netty客户端，往Broker发送消息就行了。注意，异步回调只是在Producer接收到Broker的响应后自行调整流程，不需要提供Netty服务。</li>
<li>另一种是事务消息发送者： TransactionMQProducer。这个需要构建一个Netty客户端，往Broker发送消息。同时也要构建Netty服务端，供Broker回查本地事务状态。</li>
</ul>
<p>由于整个Producer的流程，其实还是挺复杂的，我们这里只关注DefaultMQProducer的整个过程。TransactionMQProducer就不在课上带大家看了。</p>
</blockquote>
<h3 id="5-1-源码重点"><a href="#5-1-源码重点" class="headerlink" title="5.1 源码重点"></a>5.1 源码重点</h3><p>整个Producer的流程，大致分两个步骤</p>
<ul>
<li>start方法，进行一大堆的准备工作</li>
<li>各种各样的send方法，进行消息发送。</li>
</ul>
<p>那我们重点关注以下几个问题：</p>
<p><strong>首先</strong> 我们关注下Broker的核心启动流程：</p>
<p>在mQClientFactory的start方法中，启动了生产者的一大堆重要服务。</p>
<p>然后在DefaultMQProducerImpl的start方法中，又回到了生产者的mqClientFactory的启动过程，这中间有服务状态的管理。</p>
<p><strong>其次：</strong>关于Borker路由信息的管理： Producer需要拉取Broker列表，然后跟Broker建立连接等等很多核心的流程，其实都是在发送消息时建立的。因为在启动时，还不知道要拉取哪个Topic的Broker列表呢。所以对于这个问题，我们关注的重点，不应该是start方法，而是send方法。</p>
<p>而对NameServer的地址管理，则是散布在启动和发送的多个过程当中，并且NameServer地址可以通过一个Http服务来获取。</p>
<p>Send方法中，首先需要获得Topic的路由信息。这会从本地缓存中获取，如果本地缓存中没有，就从NameServer中去申请。</p>
<p>核心在 org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#tryToFindTopicPublishInfo方法</p>
<p>路由信息大致的管理流程：</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86.png" alt="路由管理"></p>
<p><strong>然后</strong> 关于Producer的负载均衡。</p>
<p>在之前介绍RocketMQ的顺序消息时，讲到了Producer的负载均衡策略，默认会把消息平均的发送到所有MessageQueue里的。那到底是怎么进行负载均衡的呢？</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Producer%E9%80%89%E6%8B%A9Queue.png" alt="Producer选择Queue"></p>
<p><strong>然后</strong> 在发送Netty请求时，实际上是指定的MessageQueue，而不是Topic。Topic只是用来找MessageQueue。</p>
<p>然后根据MessageQueue再找所在的Broker，往Broker发送请求。</p>
<h1 id="六、消息存储"><a href="#六、消息存储" class="headerlink" title="六、消息存储"></a>六、消息存储</h1><h2 id="1、功能回顾"><a href="#1、功能回顾" class="headerlink" title="1、功能回顾"></a>1、功能回顾</h2><p>我们接着上面的流程，Producer把消息发到了Broker，接下来就关注下Broker接收到消息后是如何把消息进行存储的。最终存储的文件有哪些？</p>
<ul>
<li>commitLog：消息存储目录</li>
<li>config：运行期间一些配置信息</li>
<li>consumerqueue：消息消费队列存储目录</li>
<li>index：消息索引文件存储目录</li>
<li>abort：如果存在改文件寿命Broker非正常关闭</li>
<li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li>
</ul>
<p>还记得我们之前看到的Broker的核心组件吗？其中messageStore就是负责消息存储的核心组件。</p>
<h2 id="2、源码重点："><a href="#2、源码重点：" class="headerlink" title="2、源码重点："></a>2、源码重点：</h2><p>消息存储的入口在：DefaultMessageStore.putMessage</p>
<p><strong>1-commitLog写入</strong></p>
<p>CommitLog的doAppend方法就是Broker写入消息的实际入口。这个方法最终会把消息追加到MappedFile映射的一块内存里，并没有直接写入磁盘。写入消息的过程是串行的，一次只会允许一个线程写入。</p>
<p><strong>2-分发ConsumeQueue和IndexFile</strong></p>
<pre><code>当CommitLog写入一条消息后，在DefaultMessageStore的start方法中，会启动一个后台线程reputMessageService每隔1毫秒就会去拉取CommitLog中最新更新的一批消息，然后分别转发到ComsumeQueue和IndexFile里去，这就是他底层的实现逻辑。

并且，如果服务异常宕机，会造成CommitLog和ConsumeQueue、IndexFile文件不一致，有消息写入CommitLog后，没有分发到索引文件，这样消息就丢失了。DefaultMappedStore的load方法提供了恢复索引文件的方法，入口在load方法。
</code></pre>
<p><strong>3、文件同步刷盘与异步刷盘</strong></p>
<pre><code>入口：CommitLog.putMessage -&gt; CommitLog.handleDiskFlush

其中主要涉及到是否开启了对外内存。TransientStorePoolEnable。如果开启了堆外内存，会在启动时申请一个跟CommitLog文件大小一致的堆外内存，这部分内存就可以确保不会被交换到虚拟内存中。
</code></pre>
<p><strong>4、过期文件删除</strong></p>
<pre><code>入口： DefaultMessageStore.addScheduleTask -&gt; DefaultMessageStore.this.cleanFilesPeriodically()

默认情况下， Broker会启动后台线程，每60秒，检查CommitLog、ConsumeQueue文件。然后对超过72小时的数据进行删除。也就是说，默认情况下， RocketMQ只会保存3天内的数据。这个时间可以通过fileReservedTime来配置。注意他删除时，并不会检查消息是否被消费了。
</code></pre>
<p>整个文件存储的核心入口入口在DefaultMessageStore的start方法中。</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220723221300813.png" alt="image-20220723221300813"></p>
<p><strong>5文件存储部分的总结</strong>：</p>
<p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p>
<p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。</p>
<p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p>
<p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p>
<h1 id="七、消费者"><a href="#七、消费者" class="headerlink" title="七、消费者"></a>七、消费者</h1><h2 id="1、功能回顾-1"><a href="#1、功能回顾-1" class="headerlink" title="1、功能回顾"></a>1、功能回顾</h2><p>结合我们之前的示例，回顾下消费者这一块的几个重点：</p>
<ul>
<li><p>消费者也是有两种，推模式消费者和拉模式消费者。消费者的使用过程也跟生产者差不多，都是先start()然后再开始消费。</p>
</li>
<li><p>消费者以消费者组的模式开展。消费者组之间有集群模式和广播模式两种消费模式。我们就要了解下这两种集群模式是如何做的逻辑封装。</p>
</li>
<li><p>然后我们关注下消费者端的负载均衡的原理。即消费者是如何绑定消费队列的。</p>
</li>
<li><p>最后我们来关注下在推模式的消费者中，MessageListenerConcurrently 和MessageListenerOrderly这两种消息监听器的处理逻辑到底有什么不同，为什么后者能保持消息顺序。</p>
</li>
</ul>
<p>我们接下来就通过这几个问题来把RocketMQ的消费者部分源码串起来。</p>
<h2 id="2、源码重点：-1"><a href="#2、源码重点：-1" class="headerlink" title="2、源码重点："></a>2、源码重点：</h2><p><strong>1、启动</strong></p>
<pre><code>DefaultMQPushConsumer.start方法

启动过程不用太过关注，有个概念就行，然后客户端启动的核心是mQClientFactory 主要是启动了一大堆的服务。

这些服务可以结合具体场景再进行深入。例如pullMessageService主要处理拉取消息服务，rebalanceService主要处理客户端的负载均衡。
</code></pre>
<p><strong>2、消息拉取：</strong></p>
<pre><code>拉模式： PullMessageService
</code></pre>
<p>PullRequest里有messageQueue和processQueue，其中messageQueue负责拉取消息，拉取到后，将消息存入processQueue，进行处理。 存入后就可以清空messageQueue，继续拉取了。</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220723221432079.png" alt="image-20220723221432079"></p>
<p><strong>3 客户端负载均衡策略</strong></p>
<p>在消费者示例的start方法中，启动RebalanceService，这个是客户端进行负载均衡策略的启动服务。他只负责根据负载均衡策略获取当前客户端分配到的MessageQueue示例。</p>
<p>五种负载策略，可以由Consumer的allocateMessageQueueStrategy属性来选择。</p>
<p>最常用的是AllocateMessageQueueAveragely平均分配和AllocateMessageQueueAveragelyByCircle平均轮询分配。    </p>
<p>平均分配是把MessageQueue按组内的消费者个数平均分配。</p>
<p>而平均轮询分配就是把MessageQueue按组内的消费者一个一个轮询分配。</p>
<blockquote>
<p> 例如，六个队列q1,q2,q3,q4,q5,q6，分配给三个消费者c1,c2,c3</p>
<p> 平均分配的结果就是:  c1:{q1,q2},c2:{q3,q4},c3{q5,q6}</p>
<p> 平均轮询分配的结果就是： c1:{q1,q4},c2:{q2,q5},c3:{q3,q6}</p>
</blockquote>
<p><strong>4 并发消费与顺序消费的过程</strong></p>
<p>消费的过程依然是在DefaultMQPushConsumerImpl的 consumeMessageService中。他有两个子类ConsumeMessageConcurrentlyService和ConsumeMessageOrderlyService。其中最主要的差别是ConsumeMessageOrderlyService会在消费前把队列锁起来，优先保证拉取同一个队列里的消息。</p>
<p>消费过程的入口在DefaultMQPushConsumerImpl的pullMessage中定义的PullCallback中。</p>
<h1 id="八、延迟消息"><a href="#八、延迟消息" class="headerlink" title="八、延迟消息"></a>八、延迟消息</h1><h2 id="1、功能回顾-2"><a href="#1、功能回顾-2" class="headerlink" title="1、功能回顾"></a>1、功能回顾</h2><p>我们这里，就用一个典型的延迟消息的流程，来把上面看到的各个组件，结合一下。</p>
<p>延迟消息的核心使用方法就是在Message中设定一个MessageDelayLevel参数，对应18个延迟级别。然后Broker中会创建一个默认的Schedule_Topic主题，这个主题下有18个队列，对应18个延迟级别。消息发过来之后，会先把消息存入Schedule_Topic主题中对应的队列。然后等延迟时间到了，再转发到目标队列，推送给消费者进行消费。</p>
<p>整个延迟消息的实现方式是这样的：</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220723221513122.png" alt="image-20220723221513122"></p>
<h2 id="2、源码重点"><a href="#2、源码重点" class="headerlink" title="2、源码重点"></a>2、源码重点</h2><p>延迟消息的处理入口在scheduleMessageService这个组件中。 他会在broker启动时也一起加载。</p>
<p><strong>1、消息写入：</strong></p>
<p>代码见CommitLog.putMessage方法。</p>
<p>在CommitLog写入消息时，会判断消息的延迟级别，然后修改Message的Topic和Queue，达到转储Message的目的。</p>
<p><strong>2、消息转储到目标Topic</strong></p>
<p>这个转储的核心服务是scheduleMessageService，他也是Broker启动过程中的一个功能组件、</p>
<p>然后ScheduleMessageService会每隔1秒钟执行一个executeOnTimeup任务，将消息从延迟队列中写入正常Topic中。 代码见ScheduleMessageService中的DeliverDelayedMessageTimerTask.executeOnTimeup方法。</p>
<p>这个其中有个需要注意的点就是在ScheduleMessageService的start方法中。有一个很关键的CAS操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br></pre></td></tr></table></figure>

<p>这个CAS操作保证了同一时间只会有一个DeliverDelayedMessageTimerTask执行。保证了消息安全的同时也限制了消息进行回传的效率。所以，这也是很多互联网公司在使用RocketMQ时，对源码进行定制的一个重点。</p>
<h2 id="3-消费者部分小结："><a href="#3-消费者部分小结：" class="headerlink" title="3 消费者部分小结："></a>3 消费者部分小结：</h2><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p>
<p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p>
<p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。 </p>
<p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p>
<p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p>
<p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。与并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>
<h1 id="源码解读小结"><a href="#源码解读小结" class="headerlink" title="源码解读小结"></a>源码解读小结</h1><p>关于RocketMQ的源码部分，我们就带大家解读到这里。到目前为止，几个核心的流程我们已经解读完成了，我们按照由大到小，由粗到细的方式对几条主线进行了解读。通过解读源码，我们可以对之前提到的各种高级特性有更深入的理解。对有些有争议的问题，带着问题来源码中找答案是最好的。例如我们经常有人讨论NameServer全部挂了之后，生产者和消费者是否能够用他本地的缓存继续工作一段时间？ 这样的一些问题，看过源码之后是不是有更清晰的了解？</p>
<p>至于其他的代码，大家也可以按照自己的关注点，以业务线的方式来逐步解读。</p>
<p><img src="/2022/08/21/03-04-05-RoketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RocektMQ%E6%BA%90%E7%A0%81.jpg" alt="RocektMQ源码"></p>
<p><a href="https://www.processon.com/view/link/630234d3e401fd27b3cde689">RocketMQ_源码部分</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实践问题总结</title>
    <url>/2022/07/23/03-04-06-RocketMQ%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="RocketMQ-常见问题总结"><a href="#RocketMQ-常见问题总结" class="headerlink" title="RocketMQ 常见问题总结"></a>RocketMQ 常见问题总结</h1><h2 id="一、使用RocketMQ如何保证消息不丢失？"><a href="#一、使用RocketMQ如何保证消息不丢失？" class="headerlink" title="一、使用RocketMQ如何保证消息不丢失？"></a>一、使用RocketMQ如何保证消息不丢失？</h2><blockquote>
<p>面试高频问题</p>
</blockquote>
<h3 id="1-1哪些环节会有丢消息的可能？"><a href="#1-1哪些环节会有丢消息的可能？" class="headerlink" title="1.1哪些环节会有丢消息的可能？"></a>1.1哪些环节会有丢消息的可能？</h3><p>我们考虑一个通用的MQ场景：</p>
<p><img src="/2022/07/23/03-04-06-RocketMQ%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220723223418102.png" alt="image-20220723223418102"></p>
<p>其中，1（生产者发送消息），2（mq主从消息同步），4（消息消费）三个场景都是跨网络的，而跨网络就肯定会有丢消息的可能。</p>
<p>然后关于3这个环节，通常MQ存盘时都会先写入操作系统的缓存page cache中，然后再由操作系统异步的将消息写入硬盘。这个中间有个时间差，就可能会造成消息丢失。如果服务挂了，缓存中还没有来得及写入硬盘的消息就会丢失。这个是MQ场景都会面对的通用的丢消息问题。</p>
<h3 id="1-2RocketMQ消息零丢失方案"><a href="#1-2RocketMQ消息零丢失方案" class="headerlink" title="1.2RocketMQ消息零丢失方案"></a>1.2<strong>RocketMQ消息零丢失方案</strong></h3><ul>
<li><p><strong>生产者使用事务消息机制保证消息零丢失</strong></p>
<blockquote>
<p>这个结论比较容易理解，因为RocketMQ的事务消息机制就是为了保证零丢失来设计的，并且经过阿里的验证，肯定是非常靠谱的。</p>
<p>但是如果深入一点的话，我们还是要理解下这个事务消息到底是不是靠谱。我们以最常见的电商订单场景为例，来简单分析下事务消息机制如何保证消息不丢失。我们看下下面这个流程图：</p>
<p><img src="/2022/07/23/03-04-06-RocketMQ%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220723223826513.png" alt="image-20220723223826513"></p>
<p><strong>1、为什么要发送个half消息？有什么用？</strong></p>
<p>这个half消息是在订单系统进行下单操作前发送，并且对下游服务的消费者是不可见的。那这个消息的作用更多的体现在确认RocketMQ的服务是否正常。相当于嗅探下RocketMQ服务是否正常，并且通知RocketMQ，我马上就要发一个很重要的消息了，你做好准备。</p>
<p><strong>2.half消息如果写入失败了怎么办？</strong></p>
<p>如果没有half消息这个流程，那我们通常是会在订单系统中先完成下单，再发送消息给MQ。这时候写入消息到MQ如果失败就会非常尴尬了。而half消息如果写入失败，我们就可以认为MQ的服务是有问题的，这时，就不能通知下游服务了。我们可以在下单时给订单一个状态标记，然后等待MQ服务正常后再进行补偿操作，等MQ服务正常后重新下单通知下游服务。</p>
<p><strong>3.订单系统写数据库失败了怎么办？</strong></p>
<p>这个问题我们同样比较下没有使用事务消息机制时会怎么办？如果没有使用事务消息，我们只能判断下单失败，抛出了异常，那就不往MQ发消息了，这样至少保证不会对下游服务进行错误的通知。但是这样的话，如果过一段时间数据库恢复过来了，这个消息就无法再次发送了。当然，也可以设计另外的补偿机制，例如将订单数据缓存起来，再启动一个线程定时尝试往数据库写。而如果使用事务消息机制，就可以有一种更优雅的方案。</p>
<p>如果下单时，写数据库失败(可能是数据库崩了，需要等一段时间才能恢复)。那我们可以另外找个地方把订单消息先缓存起来(Redis、文本或者其他方式)，然后给RocketMQ返回一个UNKNOWN状态。这样RocketMQ就会过一段时间来回查事务状态。我们就可以在回查事务状态时再尝试把订单数据写入数据库，如果数据库这时候已经恢复了，那就能完整正常的下单，再继续后面的业务。这样这个订单的消息就不会因为数据库临时崩了而丢失。</p>
<p><strong>4.half消息写入成功后RocketMQ挂了怎么办？</strong></p>
<p>我们需要注意下，在事务消息的处理机制中，未知状态的事务状态回查是由RocketMQ的Broker主动发起的。也就是说如果出现了这种情况，那RocketMQ就不会回调到事务消息中回查事务状态的服务。这时，我们就可以将订单一直标记为”新下单”的状态。而等RocketMQ恢复后，只要存储的消息没有丢失，RocketMQ就会再次继续状态回查的流程。</p>
<p><strong>5.下单成功后如何优雅的等待支付成功？</strong></p>
<p>在订单场景下，通常会要求下单完成后，客户在一定时间内，例如10分钟，内完成订单支付，支付完成后才会通知下游服务进行进一步的营销补偿。</p>
<p>如果不用事务消息，那通常会怎么办？</p>
<p>最简单的方式是启动一个定时任务，每隔一段时间扫描订单表，比对未支付的订单的下单时间，将超过时间的订单回收。这种方式显然是有很大问题的，需要定时扫描很庞大的一个订单信息，这对系统是个不小的压力。</p>
<p>那更进一步的方案是什么呢？是不是就可以使用RocketMQ提供的延迟消息机制。往MQ发一个延迟1分钟的消息，消费到这个消息后去检查订单的支付状态，如果订单已经支付，就往下游发送下单的通知。而如果没有支付，就再发一个延迟1分钟的消息。最终在第十个消息时把订单回收。这个方案就不用对全部的订单表进行扫描，而只需要每次处理一个单独的订单消息。</p>
<p>那如果使用上了事务消息呢？我们就可以用事务消息的状态回查机制来替代定时的任务。在下单时，给Broker返回一个UNKNOWN的未知状态。而在状态回查的方法中去查询订单的支付状态。这样整个业务逻辑就会简单很多。我们只需要配置RocketMQ中的事务消息回查次数(默认15次)和事务回查间隔时间(messageDelayLevel)，就可以更优雅的完成这个支付状态检查的需求。</p>
<p><strong>6、事务消息机制的作用</strong></p>
<p>整体来说，在订单这个场景下，消息不丢失的问题实际上就还是转化成了下单这个业务与下游服务的业务的分布式事务一致性问题。而事务一致性问题一直以来都是一个非常复杂的问题。而RocketMQ的事务消息机制，实际上只保证了整个事务消息的一半，他保证的是订单系统下单和发消息这两个事件的事务一致性，而对下游服务的事务并没有保证。但是即便如此，也是分布式事务的一个很好的降级方案。目前来看，也是业内最好的降级方案。</p>
</blockquote>
</li>
<li><p><strong>1.3、RocketMQ配置同步刷盘+Dledger主从架构保证MQ自身不会丢消息</strong></p>
<p><strong>1、同步刷盘</strong></p>
<p>这个从我们之前的分析，就很好理解了。我们可以简单的把RocketMQ的刷盘方式 flushDiskType配置成同步刷盘就可以保证消息在刷盘过程中不会丢失了。</p>
<p><strong>2、Dledger的文件同步</strong></p>
<p><img src="/2022/07/23/03-04-06-RocketMQ%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220723223946088.png" alt="image-20220723223946088"></p>
</li>
</ul>
<p>在使用Dledger技术搭建的RocketMQ集群中，Dledger会通过两阶段提交的方式保证文件在主从之间成功同步。</p>
<blockquote>
<p>简单来说，数据同步会通过两个阶段，一个是uncommitted阶段，一个是commited阶段。 Leader Broker上的Dledger收到一条数据后，会标记为uncommitted状态，然后他通过自己的DledgerServer组件把这个uncommitted数据发给Follower Broker的DledgerServer组件。         接着Follower Broker的DledgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的Dledger。然后如果Leader Broker收到超过半数的Follower Broker返回的ack之后，就会把消息标记为committed状态。         再接下来， Leader Broker上的DledgerServer就会发送committed消息给Follower Broker上的DledgerServer，让他们把消息也标记为committed状态。这样，就基于Raft协议完成了两阶段的数据同步。</p>
</blockquote>
<ul>
<li><p><strong>1.4、RocketMQ特有的问题，NameServer挂了如何保证消息不丢失？</strong></p>
<p>NameServer在RocketMQ中，是扮演的一个路由中心的角色，提供到Broker的路由功能。但是其实路由中心这样的功能，在所有的MQ中都是需要的。kafka是用zookeeper和一个作为Controller的Broker一起来提供路由服务，整个功能是相当复杂纠结的。而RabbitMQ是由每一个Broker来提供路由服务。而只有RocketMQ把这个路由中心单独抽取了出来，并独立部署。</p>
<p>这个NameServer之前都了解过，集群中任意多的节点挂掉，都不会影响他提供的路由功能。那<strong>如果集群中所有的NameServer节点都挂了呢？</strong></p>
<p>有很多人就会认为在生产者和消费者中都会有全部路由信息的缓存副本，那整个服务可以正常工作一段时间。其实这个问题大家可以做一下实验，当NameServer全部挂了后，生产者和消费者是立即就无法工作了的。至于为什么，可以回顾一下我们之前的源码课程去源码中找找答案。</p>
<p><strong>那再回到我们的消息不丢失的问题</strong>，在这种情况下，RocketMQ相当于整个服务都不可用了，那他本身肯定无法给我们保证消息不丢失了。我们只能自己设计一个降级方案来处理这个问题了。例如在订单系统中，如果多次尝试发送RocketMQ不成功，那就只能另外找给地方(Redis、文件或者内存等)把订单消息缓存下来，然后起一个线程定时的扫描这些失败的订单消息，尝试往RocketMQ发送。这样等RocketMQ的服务恢复过来后，就能第一时间把这些消息重新发送出去。整个这套降级的机制，在大型互联网项目中，都是必须要有的。</p>
</li>
<li><p><strong>1.5RocketMQ消息零丢失方案总结</strong></p>
<p>完整分析过后，整个RocketMQ消息零丢失的方案其实挺简单</p>
<ul>
<li>生产者使用事务消息机制。</li>
<li>Broker配置同步刷盘+Dledger主从架构</li>
<li>消费者不要使用异步消费。</li>
<li>整个MQ挂了之后准备降级方案</li>
</ul>
<p>那这套方案是不是就很完美呢？其实很明显，这整套的消息零丢失方案，在各个环节都大量的降低了系统的处理性能以及吞吐量。在很多场景下，这套方案带来的性能损失的代价可能远远大于部分消息丢失的代价。所以，我们在设计RocketMQ使用方案时，要根据实际的业务情况来考虑。例如，如果针对所有服务器都在同一个机房的场景，完全可以把Broker配置成异步刷盘来提升吞吐量。而在有些对消息可靠性要求没有那么高的场景，在生产者端就可以采用其他一些更简单的方案来提升吞吐，而采用定时对账、补偿的机制来提高消息的可靠性。而如果消费者不需要进行消息存盘，那使用异步消费的机制带来的性能提升也是非常显著的。</p>
<p>总之，这套消息零丢失方案的总结是为了在设计RocketMQ使用方案时的一个很好的参考。</p>
</li>
</ul>
<h2 id="二、使用RocketMQ如何保证消息顺序"><a href="#二、使用RocketMQ如何保证消息顺序" class="headerlink" title="二、使用RocketMQ如何保证消息顺序"></a><strong>二、使用RocketMQ如何保证消息顺序</strong></h2><h3 id="2-1为什么要保证消息有序？"><a href="#2-1为什么要保证消息有序？" class="headerlink" title="2.1为什么要保证消息有序？"></a>2.1<strong>为什么要保证消息有序？</strong></h3><p>这个也是面试时最常见的问题，需要对MQ场景有一定的深入理解。例如如果我们有个大数据系统，需要对业务系统的日志进行收集分析，这时候为了减少对业务系统的影响，通常都会通过MQ来做消息中转。而这时候，对消息的顺序就有一定的要求了。例如我们考虑下面这一系列的操作。</p>
<ol>
<li>用户的积分默认是0分，而新注册用户设置为默认的10分。</li>
<li>用户有奖励行为，积分+2分。</li>
<li>用户有不正当行为，积分-3分。</li>
</ol>
<p>这样一组操作，正常用户积分要变成9分。但是如果顺序乱了，这个结果就全部对不了。这时，就需要对这一组操作，保证消息都是有序的。</p>
<h3 id="2-2如何保证消息有序？"><a href="#2-2如何保证消息有序？" class="headerlink" title="2.2如何保证消息有序？"></a>2.2<strong>如何保证消息有序？</strong></h3><p>MQ的顺序问题分为全局有序和局部有序。</p>
<ul>
<li>全局有序：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费。</li>
<li>局部有序：只保证一部分关键消息的消费顺序。</li>
</ul>
<p>​    <strong>首先</strong> 我们需要分析下这个问题，在通常的业务场景中，全局有序和局部有序哪个更重要？其实在大部分的MQ业务场景，我们只需要能够保证局部有序就可以了。例如我们用QQ聊天，只需要保证一个聊天窗口里的消息有序就可以了。而对于电商订单场景，也只要保证一个订单的所有消息是有序的就可以了。至于全局消息的顺序，并不会太关心。而通常意义下，全局有序都可以压缩成局部有序的问题。例如以前我们常用的聊天室，就是个典型的需要保证消息全局有序的场景。但是这种场景，通常可以压缩成只有一个聊天窗口的QQ来理解。即整个系统只有一个聊天通道，这样就可以用QQ那种保证一个聊天窗口消息有序的方式来保证整个系统的全局消息有序。</p>
<p>​    <strong>然后</strong> 落地到RocketMQ。通常情况下，发送者发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀的分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息。而MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序的。</p>
<p>​    而对于局部有序的要求，只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序。RocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里。</p>
<p>​    另外，通常所谓的保证Topic全局消息有序的方式，就是将Topic配置成只有一个MessageQueue队列(默认是4个)。这样天生就能保证消息全局有序了。这个说法其实就是我们将聊天室场景压缩成只有一个聊天窗口的QQ一样的理解方式。而这种方式对整个Topic的消息吞吐影响是非常大的，如果这样用，基本上就没有用MQ的必要了。</p>
<h2 id="三、使用RocketMQ如何快速处理积压消息？"><a href="#三、使用RocketMQ如何快速处理积压消息？" class="headerlink" title="三、使用RocketMQ如何快速处理积压消息？"></a><strong>三、使用RocketMQ如何快速处理积压消息？</strong></h2><h3 id="3-1如何确定RocketMQ有大量的消息积压？"><a href="#3-1如何确定RocketMQ有大量的消息积压？" class="headerlink" title="3.1如何确定RocketMQ有大量的消息积压？"></a>3.1<strong>如何确定RocketMQ有大量的消息积压？</strong></h3><p>​    在正常情况下，使用MQ都会要尽量保证他的消息生产速度和消费速度整体上是平衡的，但是如果部分消费者系统出现故障，就会造成大量的消息积累。这类问题通常在实际工作中会出现得比较隐蔽。例如某一天一个数据库突然挂了，大家大概率就会集中处理数据库的问题。等好不容易把数据库恢复过来了，这时基于这个数据库服务的消费者程序就会积累大量的消息。或者网络波动等情况，也会导致消息大量的积累。这在一些大型的互联网项目中，消息积压的速度是相当恐怖的。所以消息积压是个需要时时关注的问题。</p>
<p>​    对于消息积压，如果是RocketMQ或者kafka还好，他们的消息积压不会对性能造成很大的影响。而如果是RabbitMQ的话，那就惨了，大量的消息积压可以瞬间造成性能直线下滑。</p>
<p>​    对于RocketMQ来说，有个最简单的方式来确定消息是否有积压。那就是使用web控制台，就能直接看到消息的积压情况。</p>
<p>​    在Web控制台的主题页面，可以通过 Consumer管理 按钮实时看到消息的积压情况。</p>
<p><img src="/2022/07/23/03-04-06-RocketMQ%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220723224322757.png" alt="image-20220723224322757"></p>
<p>另外，也可以通过mqadmin指令在后台检查各个Topic的消息延迟情况。</p>
<p>还有RocketMQ也会在他的 ${storePathRootDir}/config 目录下落地一系列的json文件，也可以用来跟踪消息积压情况。</p>
<h3 id="3-2如何处理大量积压的消息？"><a href="#3-2如何处理大量积压的消息？" class="headerlink" title="3.2如何处理大量积压的消息？"></a>3.2<strong>如何处理大量积压的消息？</strong></h3><p>队列不可用动态扩容，创建topic的时候就已经指定好了队列。</p>
<p>其实我们回顾下RocketMQ的负载均衡的内容就不难想到解决方案。</p>
<p>如果Topic下的MessageQueue配置得是足够多的，那每个Consumer实际上会分配多个MessageQueue来进行消费。这个时候，就可以简单的通过增加Consumer的服务节点数量来加快消息的消费，等积压消息消费完了，再恢复成正常情况。最极限的情况是把Consumer的节点个数设置成跟MessageQueue的个数相同。但是如果此时再继续增加Consumer的服务节点就没有用了。</p>
<p>而如果Topic下的MessageQueue配置得不够多的话，那就不能用上面这种增加Consumer节点个数的方法了。这时怎么办呢？ 这时如果要快速处理积压的消息，可以创建一个新的Topic，配置足够多的MessageQueue。然后把所有消费者节点的目标Topic转向新的Topic，并紧急上线一组新的消费者，只负责消费旧Topic中的消息，并转储到新的Topic中，这个速度是可以很快的。然后在新的Topic上，就可以通过增加消费者个数来提高消费速度了。之后再根据情况恢复成正常情况。</p>
<blockquote>
<p>在官网中，还分析了一个特殊的情况。就是如果RocketMQ原本是采用的普通方式搭建主从架构，而现在想要中途改为使用Dledger高可用集群，这时候如果不想历史消息丢失，就需要先将消息进行对齐，也就是要消费者把所有的消息都消费完，再来切换主从架构。因为Dledger集群会接管RocketMQ原有的CommitLog日志，所以切换主从架构时，如果有消息没有消费完，这些消息是存在旧的CommitLog中的，就无法再进行消费了。这个场景下也是需要尽快的处理掉积压的消息。</p>
</blockquote>
<h2 id="四、RocketMQ的消息轨迹"><a href="#四、RocketMQ的消息轨迹" class="headerlink" title="四、RocketMQ的消息轨迹"></a>四、<strong>RocketMQ的消息轨迹</strong></h2><p>RocketMQ默认提供了消息轨迹的功能：</p>
<h3 id="4-1RocketMQ消息轨迹数据的关键属性："><a href="#4-1RocketMQ消息轨迹数据的关键属性：" class="headerlink" title="4.1RocketMQ消息轨迹数据的关键属性："></a>4.1<strong>RocketMQ消息轨迹数据的关键属性：</strong></h3><table>
<thead>
<tr>
<th>Producer端</th>
<th>Consumer端</th>
<th>Broker端</th>
</tr>
</thead>
<tbody><tr>
<td>生产实例信息</td>
<td>消费实例信息</td>
<td>消息的Topic</td>
</tr>
<tr>
<td>发送消息时间</td>
<td>投递时间,投递轮次</td>
<td>消息存储位置</td>
</tr>
<tr>
<td>消息是否发送成功</td>
<td>消息是否消费成功</td>
<td>消息的Key值</td>
</tr>
<tr>
<td>发送耗时</td>
<td>消费耗时</td>
<td>消息的Tag值</td>
</tr>
</tbody></table>
<h3 id="4-2、消息轨迹配置"><a href="#4-2、消息轨迹配置" class="headerlink" title="4.2、消息轨迹配置"></a><strong>4.2、消息轨迹配置</strong></h3><p>打开消息轨迹功能，需要在broker.conf中打开一个关键配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceTopicEnable=true</span><br></pre></td></tr></table></figure>

<p>这个配置的默认值是false。也就是说默认是关闭的。</p>
<h3 id="4-3消息轨迹数据存储"><a href="#4-3消息轨迹数据存储" class="headerlink" title="4.3消息轨迹数据存储"></a>4.3<strong>消息轨迹数据存储</strong></h3><p>默认情况下，消息轨迹数据是存于一个系统级别的Topic ,RMQ_SYS_TRACE_TOPIC。这个Topic在Broker节点启动时，会自动创建出来。</p>
<p><img src="/2022/07/23/03-04-06-RocketMQ%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220723224605560.png" alt="image-20220723224605560"></p>
<p>另外，也支持客户端自定义轨迹数据存储的Topic。</p>
<p>在客户端的两个核心对象 DefaultMQProducer和DefaultMQPushConsumer，他们的构造函数中，都有两个可选的参数来打开消息轨迹存储</p>
<ul>
<li>enableMsgTrace：是否打开消息轨迹。默认是false。</li>
<li>customizedTraceTopic：配置将消息轨迹数据存储到用户指定的Topic 。</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法入门基础</title>
    <url>/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="数据结构与算法入门基础"><a href="#数据结构与算法入门基础" class="headerlink" title="数据结构与算法入门基础"></a>数据结构与算法入门基础</h2><h3 id="1、大纲"><a href="#1、大纲" class="headerlink" title="1、大纲"></a>1、大纲</h3><p><img src="/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/data-1649164095365.png" alt="数据结构与算法"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">算法题：判断一个数是否是<span class="number">2</span>的N次方。比如<span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> 是的<span class="number">6</span> <span class="number">10</span> 不是的就看这个数是不是可以拆成N个<span class="number">2</span>相乘</span><br><span class="line">常规方法：</span><br><span class="line">伪代码：</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;		不等于<span class="number">0</span>那肯定就不是的 </span><br><span class="line"> n = n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">按位与：</span><br><span class="line"><span class="number">1</span>:<span class="number">01</span></span><br><span class="line"><span class="number">2</span>:<span class="number">10</span> &amp; :<span class="number">01</span> &amp; <span class="number">10</span> =<span class="number">00</span></span><br><span class="line"><span class="number">4</span>:<span class="number">100</span></span><br><span class="line"><span class="number">3</span>:<span class="number">011</span> <span class="number">4</span>&amp;<span class="number">3</span>==<span class="number">0</span></span><br><span class="line"><span class="number">8</span>:<span class="number">1000</span></span><br><span class="line"><span class="number">7</span>:<span class="number">0111</span></span><br><span class="line"><span class="number">16</span>:<span class="number">10000</span></span><br><span class="line"><span class="number">15</span>:<span class="number">01111</span>  ===&gt;转化成了 <span class="keyword">if</span>(n&amp;(n-<span class="number">1</span>) == <span class="number">0</span>) 那么n就是<span class="number">2</span>的次方 n  &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="2、算法的重要性"><a href="#2、算法的重要性" class="headerlink" title="2、算法的重要性"></a>2、算法的重要性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.BAT一线互联网公司面试必问技术:</span><br><span class="line">为什么必问？数据结构与算法是所有计算机类的基础。大企业看重的是潜力。</span><br><span class="line">2.如果你不想做一辈子的CRUD工程师：业务工程师，CURD工程师，redis。redis的数据结构？集合 set 跳表。</span><br><span class="line">统计功能：排序+循环。</span><br><span class="line">3.架构师必备，写出框架级的代码；API，写出开源级代码。中年危机</span><br><span class="line">4.提升自己的能力，不被行业淘汰：H5，小程序。红黑树，几十年的时间。B+Tree.</span><br></pre></td></tr></table></figure>

<h3 id="3、算法的特性"><a href="#3、算法的特性" class="headerlink" title="3、算法的特性"></a>3、算法的特性</h3><p>五个特征：有穷性、确定性、可行性、有输入、有输出</p>
<p>设计原则：正确性、可读性、健壮性（ bug：写出代码很少有bug，而且系统比较稳定）</p>
<p>高效率与低存储：内存+CPU 堆栈内存 （OOM：堆栈内存溢出） 内存占用最小，CPU占用最小，运算速度最快。</p>
<p>评价算法的两个重要指标：</p>
<p><strong>时间复杂度：</strong>运行一个程序所花费的时间。O()</p>
<p><strong>空间复杂度：</strong>运行程序所需要的内存  OOM</p>
<p><code>时间复杂度</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">// 此行代码执行四次</span></span><br><span class="line">    a++;<span class="comment">//此行代码执行三次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>循环执行顺序如下所示：</span><br><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line">先执行“表达式<span class="number">1</span>”，再进行“表达式<span class="number">2</span>”的判断，判断为真则执行 “循环体”，循环体执行完以后执行表达式<span class="number">3.</span></span><br></pre></td></tr></table></figure>



<p>1.时间复杂度计算的意义：通过分析代码时间复杂度分析接口性能。</p>
<p>2.时间复杂度表示方法：大O表示法。O(n),O(nlogn);</p>
<p>3.时间复杂度如何来分析</p>
<p>（1）找for while 递归。而且要找循环量最大的那一段</p>
<p>（2）同级循环怎么计算</p>
<h3 id="4、几种常见的时间复杂度（指的是某一段代码）分析"><a href="#4、几种常见的时间复杂度（指的是某一段代码）分析" class="headerlink" title="4、几种常见的时间复杂度（指的是某一段代码）分析"></a>4、几种常见的时间复杂度（指的是某一段代码）分析</h3><p>计算时间复杂度往往是计算比较大的而且是不确定的数，如果已经确定了，那么就不用计算了，也是我们说的常量。</p>
<ul>
<li><p>常数：O(1) <strong>1表示是常数，所有能确定的数字我们都用O（1</strong>），O(1000)=&gt;o(1)</p>
</li>
<li><p>对数：O(logn),O(nlogn)</p>
</li>
<li><p>线性：O(n)</p>
</li>
<li><p>线性对数：O(nlogn)</p>
</li>
<li><p>平方：O(n^2)</p>
</li>
<li><p>N次方：O(n^n)</p>
</li>
</ul>
<p>我们怎么找时间复杂度：</p>
<ol>
<li><p> 找到有循环的地方</p>
</li>
<li><p>找有网络请求（RPC，远程调用，分布式，数据库请求）的地方，就是测试时间：log打印，计算平均时间。</p>
</li>
</ol>
<p><img src="/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220405211010288.png" alt="常用时间复杂度"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(<span class="number">1</span>)：<span class="number">1</span>表示是常数，所有能确定的数字我们都用O（<span class="number">1</span>）</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  b++;<span class="comment">//O(1)</span></span><br><span class="line">&#125;</span><br><span class="line">o(N):</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    b++;<span class="comment">// O(N) N是未知的 如果N是已知的则为O(1)</span></span><br><span class="line">&#125;</span><br><span class="line">O(logn):</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">    i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">O(nlogn):</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">   <span class="keyword">while</span>(j&lt;=n)&#123;</span><br><span class="line">      j = j * <span class="number">3</span>;<span class="comment">//2^x=n;  x就是我们运行的次数，x=log3N</span></span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line">O(N^<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">        a++;<span class="comment">//运行次数  N* （N+1）/2 忽略常数项 有加减法的时候 保留最高次项 即为 O(N^2) 平方级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、几种常见的时间复杂度总结"><a href="#5、几种常见的时间复杂度总结" class="headerlink" title="5、几种常见的时间复杂度总结"></a>5、几种常见的时间复杂度总结</h3><p>学了时间复杂度，那我们的目的就是要把代码写到最优，效率最高(效率从高到低：O(1)&gt;O(logn)&gt;O(n)&gt;O(nlogn)&gt;O(n^2)&gt;O(n^x))</p>
<p>优化的目的：就是要往O（1）的方向接近。</p>
<p><strong>O(1)&gt;O(logn)&gt;O(n)&gt;O(nlogn) 效果都是很好的。几乎优化的空间不是很大。</strong></p>
<p>登录：判断用户名密码O(1)到数据库里查记录=&gt;做分布式缓存。</p>
<p>列表的接口：排序，冒泡排序；=&gt;找更优秀的排序算法如：快速排序，归并排序，堆排序。</p>
<p>最坏情况、最好情况、平均情况时间复杂度。</p>
<h3 id="6、空间复杂度"><a href="#6、空间复杂度" class="headerlink" title="6、空间复杂度"></a>6、空间复杂度</h3><p>1.空间复杂度分析的意义：<strong>找花了内存的地方，看数据</strong></p>
<p>2.如何找出程序的空间复杂度：<strong>开了空间的地方， 比如数组、链表、map，缓存对象，递归【占用堆栈内存】</strong></p>
<h3 id="7、总结十大基础排序算法"><a href="#7、总结十大基础排序算法" class="headerlink" title="7、总结十大基础排序算法"></a>7、总结十大基础排序算法</h3><p><code>冒泡排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">/*循环数组长度的次数*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*从第0个元素开始，依次和后面的元素进行比较</span></span><br><span class="line"><span class="comment">             * j &lt; array.length - 1 - i表示第[array.length - 1 - i]</span></span><br><span class="line"><span class="comment">             * 个元素已经冒泡到了合适的位置，无需进行比较，可以减少比较次数*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">                <span class="comment">/*如果第j个元素比后面的第j+1元素大，交换两者的位置*/</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                PrintArray.print(nums);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">            <span class="comment">//PrintArray.print(array);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> BubbleSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>桶排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketCap 桶的容量，即每个桶所能放置多少个不同数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> bucketCap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">int</span> max = array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到最大值最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">                max = array.get(i);</span><br><span class="line">            <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">                min = array.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*获得桶的数量*/</span></span><br><span class="line">        <span class="keyword">int</span> bucketCount = (max - min) / bucketCap + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*构建桶*/</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">        ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*将原始数组中的数据分配到桶中*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            bucketArr.get((array.get(i) - min) / bucketCap).add(array.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*看看桶中数据的分布*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个桶包含数据：&quot;</span>);</span><br><span class="line">            PrintArray.printObject(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCap == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                    resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                    bucketCap--;</span><br><span class="line">                System.out.println(<span class="string">&quot;对第&quot;</span>+i+<span class="string">&quot;桶中的数据再次用桶进行排序----&quot;</span>);</span><br><span class="line">                <span class="comment">/*对桶中的数据再次用桶进行排序*/</span></span><br><span class="line">                ArrayList&lt;Integer&gt; temp = sort(bucketArr.get(i), bucketCap);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                    resultArr.add(temp.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        array.add(<span class="number">86</span>);</span><br><span class="line">        array.add(<span class="number">11</span>);</span><br><span class="line">        array.add(<span class="number">77</span>);</span><br><span class="line">        array.add(<span class="number">23</span>);</span><br><span class="line">        array.add(<span class="number">32</span>);</span><br><span class="line">        array.add(<span class="number">45</span>);</span><br><span class="line">        array.add(<span class="number">58</span>);</span><br><span class="line">        array.add(<span class="number">63</span>);</span><br><span class="line">        array.add(<span class="number">93</span>);</span><br><span class="line">        array.add(<span class="number">4</span>);</span><br><span class="line">        array.add(<span class="number">37</span>);</span><br><span class="line">        array.add(<span class="number">22</span>);</span><br><span class="line">        PrintArray.printObject(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; dest = BucketSort.sort(array,<span class="number">2</span>);</span><br><span class="line">        PrintArray.printObject(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>简单选择排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex=i;<span class="comment">/*最小数的下标，每个循环开始总是假设第一个数最小*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) <span class="comment">/*找到最小的数*/</span></span><br><span class="line">                    minIndex = j; <span class="comment">/*将最小数的索引保存*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;最小数为：&quot;</span>+nums[minIndex]);</span><br><span class="line">            <span class="comment">/*交换最小数和i当前所指的元素*/</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[minIndex];</span><br><span class="line">            nums[minIndex] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            PrintArray.print(nums);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> ChoiceSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>计数排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">/*寻找数组中最大值，最小值</span></span><br><span class="line"><span class="comment">        * bias:偏移量,用以定位原始数组每个元素在计数数组中的下标位置*/</span></span><br><span class="line">        <span class="keyword">int</span> bias, min = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">                max = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min)</span><br><span class="line">                min = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        bias = <span class="number">0</span> - min;</span><br><span class="line">        <span class="comment">/*获得计数数组的容量*/</span></span><br><span class="line">        <span class="keyword">int</span>[] counterArray = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(counterArray, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*遍历整个原始数组，将原始数组中每个元素值转化为计数数组下标，</span></span><br><span class="line"><span class="comment">        并将计数数组下标对应的元素值大小进行累加*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            counterArray[nums[i] + bias]++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计数数组为：&quot;</span>);</span><br><span class="line">        PrintArray.print(counterArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">/*访问原始数组时的下标计数器*/</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">/*访问计数数组时的下标计数器*/</span></span><br><span class="line">        <span class="comment">/*访问计数数组，将计数数组中的元素转换后，重新写回原始数组*/</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">/*只要计数数组中当前下标元素的值不为0，就将计数数组中的元素转换后，重新写回原始数组*/</span></span><br><span class="line">            <span class="keyword">if</span> (counterArray[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = i - bias;</span><br><span class="line">                counterArray[i]--;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">            PrintArray.print(counterArray);</span><br><span class="line">            PrintArray.print(nums);</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[] src = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        PrintArray.print(src);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> CountingSort().sortArray(src);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>堆排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明全局变量，用于记录数组array的长度；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 交换数组内两个元素*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">/*1.构建一个最大堆*/</span></span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="comment">/*2.循环将堆首位（最大值）与未排序数据末位交换，然后重新调整为最大堆*/</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(nums, <span class="number">0</span>);</span><br><span class="line">            PrintArray.print(nums);</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立最大堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*从最后一个非叶子节点开始向上构造最大堆*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span>-<span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(array, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造完成最大堆&quot;</span>);</span><br><span class="line">        PrintArray.print(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整使之成为最大堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span>*(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*如果有左子树，且左子树大于父节点，则将最大指针指向左子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; array[left] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = left;</span><br><span class="line">        <span class="comment">/*如果有右子树，且右子树大于父节点且大于左子树，则将最大指针指向右子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; array[right] &gt; array[maxIndex]&amp;&amp;array[right]&gt;array[left])</span><br><span class="line">            maxIndex = right;</span><br><span class="line">        <span class="comment">/*如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。*/</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i);</span><br><span class="line">            PrintArray.print(array);</span><br><span class="line">            adjustHeap(array, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> HeapSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>堆排序原理：</p>
<p><img src="/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220605230448487.png" alt="image-20220605230448487"></p>
<p><img src="/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220605225714413.png" alt="image-20220605225714413"></p>
<p><code>简单插入排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> currentValue;<span class="comment">/*当前待排序数据，该元素之前的元素均已被排序过*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;<span class="comment">/*已被排序数据的索引*/</span></span><br><span class="line">            currentValue = nums[preIndex + <span class="number">1</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;待排序元素索引:&quot;</span>+(i + <span class="number">1</span>)+<span class="string">&quot;，值为：&quot;</span> +currentValue+</span><br><span class="line">                    <span class="string">&quot;,已被排序数据的索引:&quot;</span>+preIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*在已被排序过数据中倒序寻找合适的位置，如果当前待排序数据比比较的元素要小，</span></span><br><span class="line"><span class="comment">            将比较的元素元素后移一位*/</span></span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentValue &lt; nums[preIndex]) &#123;</span><br><span class="line">                <span class="comment">//将当前元素后移一位</span></span><br><span class="line">                nums[preIndex + <span class="number">1</span>] = nums[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">                PrintArray.print(nums);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*while循环结束时，说明已经找到了当前待排序数据的合适位置，插入*/</span></span><br><span class="line">            nums[preIndex + <span class="number">1</span>] = currentValue;</span><br><span class="line">            System.out.println(<span class="string">&quot;本轮被插入排序后的数组&quot;</span>);</span><br><span class="line">            PrintArray.print(nums);</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> InsertionSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>归并排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">/*切分数组，然后递归排序，并用merge合并*/</span></span><br><span class="line">        <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(nums, mid, nums.length);</span><br><span class="line">        <span class="keyword">return</span> merge(sortArray(left), sortArray(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序——将两段排序好的数组结合成一个排序数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= left.length)<span class="comment">/*左边数组已经取完，完全取右边数组的值即可*/</span></span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)<span class="comment">/*右边数组已经取完，完全取左边数组的值即可*/</span></span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j])<span class="comment">/*左边数组的元素值大于右边数组，取右边数组的值*/</span></span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            <span class="keyword">else</span><span class="comment">/*右边数组的元素值大于左边数组，取左边数组的值*/</span></span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;左子数组:&quot;</span>);</span><br><span class="line">        PrintArray.print(left);</span><br><span class="line">        System.out.print(<span class="string">&quot;右子数组:&quot;</span>);</span><br><span class="line">        PrintArray.print(right);</span><br><span class="line">        System.out.print(<span class="string">&quot;合并后数组:&quot;</span>);</span><br><span class="line">        PrintArray.print(result);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> MergeSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>快速排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">return</span> sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= array.length || start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*数据分割成独立的两部分时，从哪儿分区的指示器*/</span></span><br><span class="line">        <span class="keyword">int</span> zoneIndex = partition(array, start, end);</span><br><span class="line">        <span class="keyword">if</span> (zoneIndex &gt; start)</span><br><span class="line">            sort(array, start, zoneIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (zoneIndex &lt; end)</span><br><span class="line">            sort(array, zoneIndex + <span class="number">1</span>, end);</span><br><span class="line">        System.out.println(<span class="string">&quot;本轮排序后的数组&quot;</span>);</span><br><span class="line">        PrintArray.printIndex(array, start, end);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序分区方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*只有一个元素时，无需再分区*/</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="comment">/*随机选取一个基准数*/</span></span><br><span class="line">        <span class="keyword">int</span> pivot = (<span class="keyword">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">/*zoneIndex是分区指示器，初始值为分区头元素下标减一*/</span></span><br><span class="line">        <span class="keyword">int</span> zoneIndex = start - <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始下标：&quot;</span> + start + <span class="string">&quot;,结束下标:&quot;</span> + end + <span class="string">&quot;,基准数下标：&quot;</span></span><br><span class="line">                + pivot + <span class="string">&quot;,元素值:&quot;</span> + array[pivot] + <span class="string">&quot;，分区指示器下标：&quot;</span> + zoneIndex);</span><br><span class="line">        <span class="comment">/*将基准数和分区尾元素交换位置*/</span></span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">/*当前元素小于等于基准数*/</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class="line">                <span class="comment">/*首先分区指示器累加*/</span></span><br><span class="line">                zoneIndex++;</span><br><span class="line">                <span class="comment">/*当前元素在分区指示器的右边时，交换当前元素和分区指示器元素*/</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; zoneIndex)</span><br><span class="line">                    swap(array, i, zoneIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;分区指示器：&quot;</span> + zoneIndex + <span class="string">&quot;,遍历指示器:&quot;</span> + i);</span><br><span class="line">            PrintArray.printIndex(array, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> zoneIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组内两个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> QuickSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>快排原则：</p>
<p><img src="/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220605224921681.png" alt="快排原理"></p>
<p><code>基数排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">/*找出最大数*/</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*先算出最大数的位数,它决定了我们要进行几轮排序*/</span></span><br><span class="line">        <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*构建桶*/</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="comment">/*按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，</span></span><br><span class="line"><span class="comment">        每一轮排序都基于上轮排序后的结果*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----第&quot;</span>+i+<span class="string">&quot;轮排序-----&quot;</span>);</span><br><span class="line">            <span class="comment">/*遍历原始数组，投入桶中*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (nums[j] % mod) / div;</span><br><span class="line">                bucketList.get(num).add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*看看桶中数据的分布*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; bucketList.size(); b++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;第&quot;</span>+b+<span class="string">&quot;个桶包含数据：&quot;</span>);</span><br><span class="line">                PrintArray.printObject(bucketList.get(b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*桶中的数据写回原始数组，清除桶，准备下一轮的排序*/</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    nums[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> RadixSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>希尔排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">/*按增量分组后，每个分组中，temp代表当前待排序数据，该元素之前的组内元素均已被排序过*/</span></span><br><span class="line">        <span class="comment">/*gap指用来分组的增量，会依次递减*/</span></span><br><span class="line">        <span class="keyword">int</span> currentValue, gap = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                currentValue = nums[i];</span><br><span class="line">                <span class="comment">/*组内已被排序数据的索引*/</span></span><br><span class="line">                <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">                <span class="comment">/*在组内已被排序过数据中倒序寻找合适的位置，如果当前待排序数据比比较的元素要小，</span></span><br><span class="line"><span class="comment">                则将比较的元素在组内后移一位*/</span></span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; nums[preIndex] &gt; currentValue) &#123;</span><br><span class="line">                    nums[preIndex + gap] = nums[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*while循环结束时，说明已经找到了当前待排序数据的合适位置，插入*/</span></span><br><span class="line">                nums[preIndex + gap] = currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;本轮增量【&quot;</span>+gap+<span class="string">&quot;】排序后的数组&quot;</span>);</span><br><span class="line">            PrintArray.print(nums);</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintArray.print(PrintArray.SRC);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> ShellSort().sortArray(PrintArray.SRC);</span><br><span class="line">        PrintArray.print(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、排序算法总结"><a href="#8、排序算法总结" class="headerlink" title="8、排序算法总结"></a>8、排序算法总结</h3><p><img src="/2022/04/05/06-00-00-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220405220811573.png" alt="十大基本排序算法比较"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="一、网络分层原理"><a href="#一、网络分层原理" class="headerlink" title="一、网络分层原理"></a>一、网络分层原理</h2><h3 id="1、复杂的网络"><a href="#1、复杂的网络" class="headerlink" title="1、复杂的网络"></a>1、复杂的网络</h3><p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404090937050.png" alt="网络传输过程"></p>
<h3 id="2、网络分层"><a href="#2、网络分层" class="headerlink" title="2、网络分层"></a>2、网络分层</h3><p><strong>为了简化网络的复杂度，网络通信的不同方面被分解为多层次结构，每一层只与紧挨着的上一层或下一层进行交互，将网络分层，这样就可以修改，甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其它层。</strong></p>
<ul>
<li><p><code>OSI（Open System Interconnection Reference Model）:开放系统互连参考模型</code></p>
</li>
<li><p><code>TCP/IP协议族</code></p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404091034519.png" alt="网络分层"></p>
</li>
</ul>
<h3 id="3、一个HTTP请求的分层解析流程"><a href="#3、一个HTTP请求的分层解析流程" class="headerlink" title="3、一个HTTP请求的分层解析流程"></a>3、一个HTTP请求的分层解析流程</h3><p>  <img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404091130168.png" alt="一个Http请求的分层解析流程"></p>
<h2 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h2><p><strong>超文本传输协议(HyperText Transfer Protocol，HTTP)：</strong> 一种无状态的（本身不会存储用户的信息），以请求/应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与 基于网络的超文本信息系统灵活的互动。</p>
<h3 id="1、HTTP报文格式"><a href="#1、HTTP报文格式" class="headerlink" title="1、HTTP报文格式"></a>1、HTTP报文格式</h3><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成： </p>
<ul>
<li><code>起始行（start line）</code>：描述请求或响应的基本信息 </li>
<li><code>头部字段集合（header）</code>：使用 key-value 形式更详细地说明报文 </li>
<li><code>消息正文（entity）</code>：实际传输的数据，它不一定是纯文本，可以是图片、视频 等二进制数据</li>
</ul>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404092725026.png" alt="HTTP报文格式"></p>
<h3 id="2、请求行报文格式"><a href="#2、请求行报文格式" class="headerlink" title="2、请求行报文格式"></a>2、请求行报文格式</h3><p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404092555777.png" alt="请求行报文格式"></p>
<h3 id="3、响应行报文格式"><a href="#3、响应行报文格式" class="headerlink" title="3、响应行报文格式"></a>3、响应行报文格式</h3><p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404092929856.png" alt="响应行报文格式"></p>
<ul>
<li>版本号：表示报文使用的 HTTP 协议版本； </li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因 </li>
</ul>
<h3 id="4、HTTP-头字段"><a href="#4、HTTP-头字段" class="headerlink" title="4、HTTP 头字段"></a>4、HTTP 头字段</h3><p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字 段结束。比如前后分离时经常遇到的要与后端协商传输数据的类型“Content-type: application/json”，这里 key 就是“Content-type”，value 就 是“application/json”。HTTP 头字段非常灵活，不仅可以使用标准里的 Host、 Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>
<p>头字段注意事项 </p>
<ul>
<li>字段名不区分大小写，字段名里不允许出现空格，可以使用连字符“-”，但不 能使用下划线“_”（有的服务器不会解析带“_”的头字段）。字段名后面必须紧接 着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li> 字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li> 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
</ul>
<h3 id="5、常用头字段"><a href="#5、常用头字段" class="headerlink" title="5、常用头字段"></a>5、常用头字段</h3><p>HTTP 协议中有非常多的头字段，但基本上可以分为四大类： </p>
<ul>
<li><code>请求字段</code>：请求头中的头字段；如Host，Referer（防盗链会用到）。 </li>
<li><code>响应字段</code>：响应头中的头字段，如：Server（标识哪种类型的服务器 nginx、apache）、Date（请求字段/响应字段都会存在）； </li>
<li><code>通用字段</code>：在请求头和响应头里都可以出现，如 Content-type（数据传输到服务器用的什么格式）， Connection ；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP 400 – 请求无效</span><br><span class="line"></span><br><span class="line">HTTP 404- 无法找到文件或目录</span><br><span class="line"></span><br><span class="line">HTTP 500 – 内部服务器错误</span><br><span class="line"></span><br><span class="line">HTTP 502 – 网关错误</span><br><span class="line"></span><br><span class="line">HTTP 400 – 请求无效</span><br><span class="line">HTTP 401.1 – 未授权：登录失败</span><br><span class="line">HTTP 401.2 – 未授权：服务器配置问题导致登录失败</span><br><span class="line">HTTP 401.3 – ACL 禁止访问资源</span><br><span class="line">HTTP 401.4 – 未授权：授权被筛选器拒绝</span><br><span class="line">HTTP 401.5 – 未授权：ISAPI 或 CGI 授权失败</span><br><span class="line"></span><br><span class="line">HTTP 403 – 禁止访问</span><br><span class="line">HTTP 403 – 对 Internet 服务管理器 的访问仅限于 Localhost</span><br><span class="line">HTTP 403.1 禁止访问：禁止可执行访问</span><br><span class="line">HTTP 403.2 – 禁止访问：禁止读访问</span><br><span class="line">HTTP 403.3 – 禁止访问：禁止写访问</span><br><span class="line">HTTP 403.4 – 禁止访问：要求 SSL</span><br><span class="line">HTTP 403.5 – 禁止访问：要求 SSL 128</span><br><span class="line">HTTP 403.6 – 禁止访问：IP 地址被拒绝</span><br><span class="line">HTTP 403.7 – 禁止访问：要求客户证书</span><br><span class="line">HTTP 403.8 – 禁止访问：禁止站点访问</span><br><span class="line">HTTP 403.9 – 禁止访问：连接的用户过多</span><br><span class="line">HTTP 403.10 – 禁止访问：配置无效</span><br><span class="line">HTTP 403.11 – 禁止访问：密码更改</span><br><span class="line">HTTP 403.12 – 禁止访问：映射器拒绝访问</span><br><span class="line">HTTP 403.13 – 禁止访问：客户证书已被吊销</span><br><span class="line">HTTP 403.15 – 禁止访问：客户访问许可过多</span><br><span class="line">HTTP 403.16 – 禁止访问：客户证书不可信或者无效</span><br><span class="line">HTTP 403.17 – 禁止访问：客户证书已经到期或者尚未生效 HTTP 404.1 -</span><br><span class="line"></span><br><span class="line">无法找到 Web 站点</span><br><span class="line">HTTP 404- 无法找到文件</span><br><span class="line">HTTP 405 – 资源被禁止</span><br><span class="line">HTTP 406 – 无法接受</span><br><span class="line">HTTP 407 – 要求代理身份验证</span><br><span class="line">HTTP 410 – 永远不可用</span><br><span class="line">HTTP 412 – 先决条件失败</span><br><span class="line">HTTP 414 – 请求 – URI 太长</span><br><span class="line"></span><br><span class="line">HTTP 500 – 内部服务器错误</span><br><span class="line">HTTP 500.100 – 内部服务器错误 – ASP 错误</span><br><span class="line">HTTP 500-11 服务器关闭</span><br><span class="line">HTTP 500-12 应用程序重新启动</span><br><span class="line">HTTP 500-13 – 服务器太忙</span><br><span class="line">HTTP 500-14 – 应用程序无效</span><br><span class="line">HTTP 500-15 – 不允许请求 global.asa</span><br><span class="line">Error 501 – 未实现</span><br><span class="line">HTTP 502 – 网关错误</span><br></pre></td></tr></table></figure>

<h2 id="三、HTTP请求的完整过程"><a href="#三、HTTP请求的完整过程" class="headerlink" title="三、HTTP请求的完整过程"></a>三、HTTP请求的完整过程</h2><h3 id="1、当用户在浏览器输入网址回车之后，网络协议都做了哪些工作呢？"><a href="#1、当用户在浏览器输入网址回车之后，网络协议都做了哪些工作呢？" class="headerlink" title="1、当用户在浏览器输入网址回车之后，网络协议都做了哪些工作呢？"></a>1、当用户在浏览器输入网址回车之后，网络协议都做了哪些工作呢？</h3><ol>
<li><code>首先干活的是 浏览器应用程序，他要解析出 URL中的域名 </code></li>
<li><code>根据域名获取对应的ip地址，首先从浏览器缓存中查看，如下可以查看浏览器中域名对应 </code></li>
</ol>
<p>ip的解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://net‐internals/#events</span><br></pre></td></tr></table></figure>

<p>如果没有则从本机域名解析文件hosts（/etc/hosts）中查看，还没有则从 LDNS（Localdnsserver）、Rootserver域名服务器、国际顶级域名服务商的DNS 的层层解析</p>
<ol start="3">
<li><code>拿到IP地址后，浏览器就可以发起 与服务器的三次握手</code></li>
<li><code>握手建立之后，就开始组装http请求报文，发送报文 </code></li>
<li><code>服务器收到请求报文之后开始，请求报文解析，生成响应数据，发送响应数据 </code></li>
<li><code>浏览器收到响应之后，开始渲染页面</code></li>
</ol>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404094446754.png" alt="HTTP请求完整过程"></p>
<h2 id="四、TCP协议"><a href="#四、TCP协议" class="headerlink" title="四、TCP协议"></a>四、TCP协议</h2><h3 id="1、TCP协议"><a href="#1、TCP协议" class="headerlink" title="1、TCP协议"></a>1、TCP协议</h3><p>TCP（Transmission Control Protocol）： 面向连接的，可靠的，基于字节流的传输层通信协议 </p>
<p>特点： </p>
<ul>
<li>基于连接的 ：数据传输之前需要建立连接 </li>
<li>全双工的：双向传输 </li>
<li>字节流：不限制数据大小，打包成报文段，保证有序接收，重复报文自动丢弃 </li>
<li>流量缓冲：解决双方处理能力的不匹配 ，三次握手的时候双方会建立缓冲区</li>
<li>可靠的传输服务：保证可达，丢包时通过重发机制实现可靠性 </li>
<li>拥塞控制：防止网络出现恶性拥塞</li>
</ul>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404095635761.png" alt="TCP报文"></p>
<p>报文标识：</p>
<ul>
<li>SYN:为1，标识同步序列号的报文，建立连接的报文</li>
<li>ACK：响应报文，握手/数据传输中确认数据已经收到</li>
<li>FIN：关闭连接的报文</li>
</ul>
<h3 id="2、TCP连接管理"><a href="#2、TCP连接管理" class="headerlink" title="2、TCP连接管理"></a>2、TCP连接管理</h3><ol>
<li><p>TCP连接：四元组[ 源地址， 源端口， 目的地址， 目的端口 ] </p>
</li>
<li><p>确立连接：TCP三次握手 </p>
<ol>
<li><p>同步通信双方初始序列号( ISN, initial sequence number ) </p>
</li>
<li><p>协商TCP通信参数（MSS, 窗口信息，指定校验和算法） </p>
</li>
</ol>
</li>
</ol>
<p>如何进行握手 ？</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404100145862.png" alt="三次握手"></p>
<p>连接状态查看: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat ‐ntp ‐c 1</span><br></pre></td></tr></table></figure>

<p><code>三次握手补充:</code></p>
<p><code>三次握手的本质是确认通信双方收发数据的能力</code></p>
<p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的</strong>。</p>
<p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以</strong>。</p>
<p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，<strong>他若收到了，他便清楚了他的发件能力和我的收件能力是可以的</strong>。</p>
<p>这，就是三次握手。</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/82a87c962f5c40249781b88f9af5019f.png" alt="三次握手.png"></p>
<ul>
<li>第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li>
<li>第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>
<li>第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>
</ul>
<h3 id="3、TCP四次挥手"><a href="#3、TCP四次挥手" class="headerlink" title="3、TCP四次挥手"></a>3、TCP四次挥手</h3><p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404102719024.png" alt="四次挥手"></p>
<p>A：发送FIN数据包，代表A不在发送数据 </p>
<p>B：收到请求，开始应答 ，避免了A重新发送FIN重试（应答机制） </p>
<p>B： 处理完数据之后关闭，关闭连接,及发送FIN请求 </p>
<p>A：收到请求后发送ACK应答，B服务可以释放连接 </p>
<p><strong>等待 2MSL【MSL:最大报文生成时间，一个msl即客户端和服务端一个请求来回的时间】后释放连接</strong> </p>
<ol>
<li>防止报文丢失，导致B重复发送FIN ，服务端没有收到第四次握手响应，会重发第三次握手信息，如果这个时候客户端关闭，那么服务端会一直重试，造成资源不会释放</li>
<li>防止滞留在网络中的报文，对新建立的连接造成数据扰乱</li>
</ol>
<p><code>四次挥手补充：</code></p>
<p><code>四次挥手的目的是关闭一个连接</code></p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ea60825747b44584915c144b4d16f5a7.jpeg" alt="四次挥手.jpeg"></p>
<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<ul>
<li>第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li>
<li>第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li>
<li>第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</li>
<li>第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li>
</ul>
<h3 id="4、字节流的协议"><a href="#4、字节流的协议" class="headerlink" title="4、字节流的协议"></a>4、字节流的协议</h3><p>TCP把应用交付的数据仅仅看成是一连串的无结构的字节流，TCP并不知道字节流的含义，TCP并不关心应用程序一次将多大的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥堵的程度来决 定一个报文段应该包含多少个字节。 </p>
<p><strong>MSS: Max Segment Size, 默认 536byte 实际数据</strong></p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404103821430.png" alt="TCP数据传输"></p>
<h3 id="5、数据可靠性传输"><a href="#5、数据可靠性传输" class="headerlink" title="5、数据可靠性传输"></a>5、数据可靠性传输</h3><ol>
<li><strong>停止等待协议：</strong></li>
</ol>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404105438069.png" alt="停止等待协议"></p>
<ol start="2">
<li><p><strong>重传机制</strong> </p>
<ul>
<li><p><strong>ack报文丢失</strong></p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404105654955.png" alt="ac报文丢失"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在一定时长的等待中，客户端没有收到服务端给其的ack，客户端认为报文丢失了，客户端就进行重传，直到收到服务端的ack.</span><br><span class="line">效率低下</span><br></pre></td></tr></table></figure></li>
<li><p><strong>请求报文丢失</strong></p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404105709386.png" alt="请求报文丢失"></p>
</li>
</ul>
</li>
</ol>
<p><strong>3、 滑动窗口协议与累计确认（延时ack）</strong> </p>
<p>滑动窗口大小同通过 tcp三次握手和对端协商，且受网络状况影响</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404105741286.png" alt="滑动窗口协议"></p>
<h2 id="五、HTTPS协议"><a href="#五、HTTPS协议" class="headerlink" title="五、HTTPS协议"></a>五、HTTPS协议</h2><h3 id="1、HTTPS"><a href="#1、HTTPS" class="headerlink" title="1、HTTPS"></a>1、HTTPS</h3><p>由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能 够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。 因此就诞生了为安全而生的HTTPS协议。 使用HTTPS时，所有的HTTP请求和响应在发送到网络之前，都要进行加密。</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404112521803.png" alt="HTTPS"></p>
<h3 id="2、SSL-TLS"><a href="#2、SSL-TLS" class="headerlink" title="2、SSL/TLS"></a>2、SSL/TLS</h3><p>SSL 即安全套接层（Secure Sockets Layer），由网景公司于 1994 年 发明，IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，到今天 TLS 已经发展出了主流的三个 版本，分别是 2006 年的 1.1、2008 年的 1.2 ，2018的 1.3，每个新 版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经 成为了信息安全领域中的权威标准。 </p>
<p><strong>摘要算法</strong> </p>
<p>摘要算法能够把任意长度的数据“压缩”成固定长度、而且独一无二 的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。任意微小的数据差异，都可以生成完全不同的摘要。所以可以通过把明文 信息的摘要和明文一起加密进行传输，数据传输到对方之后再进行解密，重新对数据进行摘要，再比对就能发现数据有没有被篡改。这样就保证了数据的完整性。</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404112631820.png" alt="摘要算法"></p>
<p><strong>加密算法</strong> </p>
<p><strong>对称密钥加密算法</strong>：编、解码使用相同密钥的算法，如（AES，RC4,ChaCha20 ）。 </p>
<p><strong>非对称密钥加密算法</strong>：它有两个密钥，一个叫“公钥”，一个叫“私 钥”。两个密钥是不同的，公钥可以公开给任何人使用，而私钥必须严格保密。非对称加密可以解决“密钥交换”的问题。<strong>网站秘密保管私钥，在网上任意分发公钥</strong>，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。非对称密钥加密系统通常需要大量的数学运算，比较慢。如（DH、DSA、RSA、ECC ） </p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404112731961.png" alt="加密算法"></p>
<p>TLS 里使用的混合加密方式，即把对称加密和非对称加密结合起来呢，两者互相取长补短，即能高效地加密解密，又能安全地密钥交换。大致流程如下： </p>
<p>1.通信开始的时候使用非对称算法如 RSA,ECDHE先解决密钥交换的问题</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404112757765.png" alt="请求公钥"></p>
<p>2.用随机数产生对称算法使用的”会话密钥”，再用公钥加密。会话密钥很短，所以即便使用非对称加密算法也可以很快完成加解密。</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404112820819.png" alt="会话密钥"></p>
<p>3.对方拿到密文后用私钥解密，取出会话密钥。完成对称密钥的安全交换，后续就使用对称算法发完成数据交换</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404112847331.png" alt="密钥解密"></p>
<p><strong>身份验证</strong> </p>
<p>数字证书组成： </p>
<p>CA信息，公钥用户信息，公钥，权威机构的签名，有效期 </p>
<p>数字证书作用： </p>
<ol>
<li><p>通过数字证书向浏览器证明身份 </p>
</li>
<li><p>数字证书里面包含了公钥 </p>
</li>
</ol>
<p><strong>数字证书的申请和验证</strong> </p>
<p>如何申请： </p>
<ol>
<li><p>生成自己的公钥和私钥，服务器自己保留私钥 </p>
</li>
<li><p>向CA机构提交公钥，公司，域名信息等待认证 </p>
</li>
<li><p>CA机构通过线上，线下多种途径验证你提交信息的真实性，合法性 </p>
</li>
<li><p>信息审核通过，CA机构则会向你签发认证的数字证书，包含了公钥，组织信息，CA信息，有效时间，证书序列号，同时生成一个签名；</p>
</li>
</ol>
<p><strong>签名步骤:</strong> hash( 你用于申请证书所提交的明文信息 )=信息摘要；CA再使用私钥对 信息摘要进行加密，密文就是证书的数字签名 </p>
<p><strong>浏览器如何验证呢？</strong> </p>
<p>有了CA签名过的数字证书，当浏览器访问服务器时，服务器会返回数字证书给浏览器。浏览器收到证书后会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用CA签名时相同的hash函数计算得到信息摘要A，再利用对应的CA公钥解密数字签名数据得到信息摘要B，如果摘要A和摘要B一致，则可以确认证书时合法的。</p>
<p><img src="/2022/04/04/07-00-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220404113021908.png" alt="浏览器验证"></p>
<p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分域名验证（domain validated,DV）证书、组织验证（organization validated,OV）证 书、扩展验证（extended validation,EV）证书三种，区别在于可信程 度。</p>
<p>DV可信级别是最低的，只是域名级别的可信，背后是谁不知道。OV证书可信级别比DV高，会验证申请证书时填写的组织，企业信息是 否是正确的，申请往往需要几天时间， EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份。</p>
<h2 id="六、计算机网络常见问题"><a href="#六、计算机网络常见问题" class="headerlink" title="六、计算机网络常见问题"></a>六、计算机网络常见问题</h2><ol>
<li><code>为什么TCP连接的时候是3次？2次不可以吗？</code></li>
</ol>
<p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<ol start="2">
<li><code>为什么TCP连接的时候是3次，关闭的时候却是4次？</code></li>
</ol>
<p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<ol start="3">
<li><code>为什么客户端发出第四次挥手的确认报文后要等2MSL【<strong>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃</strong>】的时间才能释放TCP连接？</code></li>
</ol>
<p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<ol start="4">
<li><code>如果已经建立了连接，但是客户端突然出现故障了怎么办？</code></li>
</ol>
<p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<ol start="5">
<li><code>TCP 挥手可以只需要三次吗？</code></li>
</ol>
<p>因为服务器端收到客户端的FIN后，服务器端同时也要关闭连接，这样就可以把ACK和FIN合并到一起发送，节省了一个包，变成了“三次挥手”。</p>
<ol start="6">
<li><code>什么是HTTP，HTTP 与 HTTPS 的区别</code></li>
</ol>
<p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>HTTP</strong></th>
<th><strong>HTTPS</strong></th>
</tr>
</thead>
<tbody><tr>
<td>协议</td>
<td>运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份</td>
<td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。</td>
</tr>
<tr>
<td>端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>资源消耗</td>
<td>较少</td>
<td>由于加解密处理，会消耗更多的 CPU 和内存资源</td>
</tr>
<tr>
<td>开销</td>
<td>无需证书</td>
<td>需要证书，而证书一般需要向认证机构购买</td>
</tr>
<tr>
<td>加密机制</td>
<td>无</td>
<td>共享密钥加密和公开密钥加密并用的混合加密机制</td>
</tr>
<tr>
<td>安全性</td>
<td>弱</td>
<td>由于加密机制，安全性强</td>
</tr>
</tbody></table>
<ol start="7">
<li><code>常用HTTP状态码</code></li>
</ol>
<p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p>
<p>状态码的类别：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>原因短语</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody></table>
<p>常用HTTP状态码：</p>
<table>
<thead>
<tr>
<th><strong>2XX</strong></th>
<th><strong>成功（这系列表明请求被正常处理了）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK，表示从客户端发来的请求在服务器端被正确处理</td>
</tr>
<tr>
<td>204</td>
<td>No content，表示请求成功，但响应报文不含实体的主体部分</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content，进行范围请求成功</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>3XX</strong></th>
<th><strong>重定向（表明浏览器要执行特殊处理）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td>
</tr>
<tr>
<td>302</td>
<td>found，临时性重定向，表示资源临时被分配了新的 URL</td>
</tr>
<tr>
<td>303</td>
<td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td>
</tr>
<tr>
<td>304</td>
<td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td>
</tr>
<tr>
<td>307</td>
<td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>4XX</strong></th>
<th><strong>客户端错误</strong></th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>bad request，请求报文存在语法错误</td>
</tr>
<tr>
<td>401</td>
<td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td>
</tr>
<tr>
<td>403</td>
<td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td>
</tr>
<tr>
<td>404</td>
<td>not found，表示在服务器上没有找到请求的资源</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>5XX</strong></th>
<th><strong>服务器错误</strong></th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>internal sever error，表示服务器端在执行请求时发生了错误</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td>
</tr>
<tr>
<td>503</td>
<td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td>
</tr>
</tbody></table>
<ol start="8">
<li><code>GET和POST区别</code></li>
</ol>
<p>说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。</p>
<p>HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p>
<p>HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。</p>
<ul>
<li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li>
<li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li>
<li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li>
<li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li>
</ul>
<ol start="9">
<li><p><code>GET和POST区别</code></p>
</li>
<li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>
</li>
<li><p>Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p>
</li>
<li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。</p>
</li>
<li><p>Get执行效率却比Post方法好。Get是form提交的默认方法。</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
</li>
</ol>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<ol start="10">
<li><code>什么是对称加密与非对称加密</code></li>
</ol>
<p>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></p>
<p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p>
<ol start="11">
<li><code>什么是HTTP2</code></li>
</ol>
<p>HTTP2 可以提高了网页的性能。</p>
<p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p>
<p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅的代码是一种艺术</title>
    <url>/2022/07/27/10-00-01-%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E4%B8%80%E7%A7%8D%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<p><code>注解解析EL表达式AOP切面处理</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.learn .common.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.learn.common.business.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.common.annotation.InjectUser;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.common.constants.MDA;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.entity.dto.mit.UserInfoDTO;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.service.flow.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.DefaultParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.SpelParserConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4jpublic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjectAspect</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExpressionParser parser;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ParameterNameDiscoverer parameterNameDiscoverer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置织入点   </span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.java.learn .common.annotation.InjectUser)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;injectPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setUserInfo(joinPoint);</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MDA.U.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InjectUser annotation = <span class="keyword">null</span>;</span><br><span class="line">            Signature signature = joinPoint.getSignature();</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">            Method method = methodSignature.getMethod();</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            annotation = method.getAnnotation(InjectUser.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String userId = annotation.value();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(userId)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Expression expression = parser.parseExpression(userId);</span><br><span class="line">            <span class="keyword">if</span> (method.getParameterCount() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] parameterNames = parameterNameDiscoverer.getParameterNames(method);</span><br><span class="line">            Object[] args = joinPoint.getArgs();</span><br><span class="line">            EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(<span class="keyword">new</span> Object());</span><br><span class="line">            <span class="keyword">if</span> (parameterNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterNames.length; i++) &#123;</span><br><span class="line">                    context.setVariable(parameterNames[i], args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String value = expression.getValue(context, String.class);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MDA.U.set(Optional.ofNullable(userInfoService.getAirSignUserInfo(value)).map(x -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;InjectAspect userId is &#123;&#125; ,  userInfo is &#123;&#125;&quot;</span>, userId, x);</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;).orElseGet(UserInfoDTO::<span class="keyword">new</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BusinessException be) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;InjectAspect BusinessException is &quot;</span>, be);</span><br><span class="line">            <span class="keyword">throw</span> be;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;InjectAspect error , &quot;</span>, th);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        userInfoService = applicationContext.getBean(UserInfoService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class modeClass = Class.forName(<span class="string">&quot;org.springframework.expression.spel.SpelCompilerMode&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Constructor&lt;SpelParserConfiguration&gt; c = SpelParserConfiguration.class.getConstructor(modeClass, ClassLoader.class);</span><br><span class="line">                Object mode = modeClass.getField(<span class="string">&quot;IMMEDIATE&quot;</span>).get(<span class="keyword">null</span>);</span><br><span class="line">                SpelParserConfiguration config = c.newInstance(mode, InjectAspect.class.getClassLoader());</span><br><span class="line">                parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;parser load error &quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        &#125;</span><br><span class="line">        parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- 注解</span><br><span class="line"><span class="keyword">package</span> com.java.learn .common.annotation;<span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documentedpublic</span></span><br><span class="line"><span class="meta">@interface</span> InjectUser &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- 使用</span><br><span class="line"><span class="meta">@InjectUser(&quot;request.userId&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">save</span><span class="params">(Request request)</span></span>&#123; </span><br><span class="line">    MDA.U.get().getUserId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>优雅的数据上报</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.learn.entity.ubas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.paic.smp.cloud.common.business.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.common.constants.ResponseEnum;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.common.enums.InsuranceMetricEnum;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.common.enums.InsuranceMetricStatusEnum;</span><br><span class="line"><span class="keyword">import</span> com.java.learn.sao.BizMetricReportSao;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ubas 数据上报代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportDataProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReportDataProxy.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2286978876881645590L</span>;</span><br><span class="line">    <span class="keyword">private</span> MetricReport data;</span><br><span class="line">    <span class="keyword">private</span> BizMetricReportSao reportSao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReportDataProxy</span><span class="params">(InsuranceMetricEnum metricEnum, BizMetricReportSao reportSao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reportSao = reportSao;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> MetricReport();</span><br><span class="line">        <span class="keyword">this</span>.data.setBizId(metricEnum.getCode());</span><br><span class="line">        <span class="keyword">this</span>.data.setReportInfo(<span class="keyword">new</span> MetricReport.ReportInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务方法代理     </span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;U&gt;     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">U <span class="title">report</span><span class="params">(Function&lt;MetricReport, U&gt; function)</span> </span>&#123;</span><br><span class="line">        U result;</span><br><span class="line">        String status = InsuranceMetricStatusEnum.SUCCESS.getCode();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = function.apply(data);</span><br><span class="line">            data.getReportInfo().setResponseCode(ResponseEnum.SUCCESS.getCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BusinessException bu) &#123;</span><br><span class="line">            status = InsuranceMetricStatusEnum.FAIL.getCode();</span><br><span class="line">            data.getReportInfo().setResponseCode(bu.getCode());</span><br><span class="line">            <span class="keyword">throw</span> bu;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            status = InsuranceMetricStatusEnum.FAIL.getCode();</span><br><span class="line">            data.getReportInfo().setResponseCode(ResponseEnum.SYSTEM_ERROR.getCode());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(data.getReportInfo().getStatus())) &#123;</span><br><span class="line">                data.getReportInfo().setStatus(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.ubasReport(data);            <span class="comment">// gc            </span></span><br><span class="line">            <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.reportSao = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务方法代理     </span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(Consumer&lt;MetricReport&gt; consumer)</span> </span>&#123;</span><br><span class="line">        String status = InsuranceMetricStatusEnum.SUCCESS.getCode();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.accept(data);</span><br><span class="line">            data.getReportInfo().setResponseCode(ResponseEnum.SUCCESS.getCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BusinessException bu) &#123;</span><br><span class="line">            status = InsuranceMetricStatusEnum.FAIL.getCode();</span><br><span class="line">            data.getReportInfo().setResponseCode(bu.getCode());</span><br><span class="line">            <span class="keyword">throw</span> bu;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            status = InsuranceMetricStatusEnum.FAIL.getCode();</span><br><span class="line">            data.getReportInfo().setResponseCode(ResponseEnum.SYSTEM_ERROR.getCode());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(data.getReportInfo().getStatus())) &#123;</span><br><span class="line">                data.getReportInfo().setStatus(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.ubasReport(data);</span><br><span class="line">            <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.reportSao = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ubas上报     </span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ubasReport</span><span class="params">(MetricReport data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reportSao != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reportSao.reportMetric(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 使用</span><br><span class="line"><span class="keyword">new</span> ReportDataProxy(reportEnum,reportService).report(data-&gt;&#123;</span><br><span class="line">    <span class="comment">// do your business </span></span><br><span class="line">    <span class="comment">// build data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>优雅的限流工具类</code></p>
<p>支持动态更新信号量许可数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.learn.spring.service.TestInterface;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopSemaphoreFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestInterface testInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestInterface</span><span class="params">(TestInterface inter)</span> </span>&#123;</span><br><span class="line">        testInterface = inter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;SemaphoreEnum, ShopSemaphore&gt; semaphoreMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Semaphore <span class="title">create</span><span class="params">(SemaphoreEnum semaphoreEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createIfChanged(semaphoreEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore <span class="title">createOrGetBucket</span><span class="params">(SemaphoreEnum semaphoreEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> semaphoreMap.computeIfAbsent(semaphoreEnum, x -&gt; <span class="keyword">new</span> ShopSemaphore(testInterface.stateNumGet(semaphoreEnum)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore <span class="title">createIfChanged</span><span class="params">(SemaphoreEnum semaphoreEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!semaphoreMap.containsKey(semaphoreEnum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> createOrGetBucket(semaphoreEnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> semaphoreMap.computeIfPresent(semaphoreEnum, (k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.stateNumGet() == v.prevNumGet()) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v.stateNumGet() == v.prevNumGet()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.stateNumGet() &gt; v.prevNumGet()) &#123;</span><br><span class="line">                    v.release(v.stateNumGet() - v.prevNumGet());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v.reducePermits(v.prevNumGet() - v.stateNumGet());</span><br><span class="line">                &#125;</span><br><span class="line">                v.prevNumSet(v.stateNumGet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.learn.spring.aspect;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置织入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.learn.spring.aspect.RateLimiter)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;logPointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAfterReturning</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Semaphore rate;</span><br><span class="line">        <span class="keyword">if</span> ((rate = create(joinPoint)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Optional.of(rate.tryAcquire()).filter(x -&gt; x).orElseThrow(() -&gt; <span class="keyword">new</span> Exception(<span class="string">&quot;限速&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rate.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Semaphore <span class="title">create</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RateLimiter annotationLog = <span class="keyword">null</span>;</span><br><span class="line">            Signature signature = joinPoint.getSignature();</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">            Method method = methodSignature.getMethod();</span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                annotationLog = method.getAnnotation(RateLimiter.class);</span><br><span class="line">            &#125;</span><br><span class="line">            SemaphoreEnum value = annotationLog.value();</span><br><span class="line">            <span class="keyword">return</span> ShopSemaphoreFactory.create(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;create &quot;</span>, th);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.learn.spring.aspect;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SemaphoreEnum</span> </span>&#123;</span><br><span class="line">    rate_under_writing(<span class="string">&quot;rate_under_writing&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流场景</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String scene;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认并发线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer limiter;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    private static final Map&lt;SemaphoreEnum, ShopSemaphore&gt; semaphoreMap = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line">    SemaphoreEnum(String scene, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scene = scene;</span><br><span class="line">        <span class="keyword">this</span>.limiter = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scene;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScene</span><span class="params">(String scene)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scene = scene;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">(ReentrantLock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limiterGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    public static Semaphore createOrGetBucket(SemaphoreEnum semaphoreEnum) &#123;</span></span><br><span class="line"><span class="comment">        return semaphoreMap.computeIfAbsent(semaphoreEnum, x -&gt; new ShopSemaphore(x.limiterGet()));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static Semaphore createIfChanged(SemaphoreEnum semaphoreEnum) &#123;</span></span><br><span class="line"><span class="comment">        if (!semaphoreMap.containsKey(semaphoreEnum)) &#123;</span></span><br><span class="line"><span class="comment">            return createOrGetBucket(semaphoreEnum);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return semaphoreMap.computeIfPresent(semaphoreEnum, (k, v) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            if (v.stateNumGet() == v.prevNumGet()) &#123;</span></span><br><span class="line"><span class="comment">                return v;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            synchronized (v) &#123;</span></span><br><span class="line"><span class="comment">                if (v.stateNumGet() == v.prevNumGet()) &#123;</span></span><br><span class="line"><span class="comment">                    return v;</span></span><br><span class="line"><span class="comment">                &#125; else if (v.stateNumGet() &gt; v.prevNumGet()) &#123;</span></span><br><span class="line"><span class="comment">                    v.release(v.stateNumGet() - v.prevNumGet());</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    v.reducePermits(v.prevNumGet() - v.stateNumGet());</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                v.prevNumSet(v.stateNumGet());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return v;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static void reducePermits(Semaphore semaphore, Integer permits) &#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line"><span class="comment">            Class clazz = classLoader.loadClass(&quot;java.util.concurrent.Semaphore&quot;);</span></span><br><span class="line"><span class="comment">            Method method = clazz.getDeclaredMethod(&quot;reducePermits&quot;, int.class);</span></span><br><span class="line"><span class="comment">            method.setAccessible(true);</span></span><br><span class="line"><span class="comment">            method.invoke(semaphore, permits);</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            log.error(&quot;SemaphoreEnum reducePermits error &quot;, e);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//        reducePermits(semaphore, 10);</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;11&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;11&quot;</span>, x -&gt; Integer.parseInt(x) + <span class="number">100</span>);<span class="comment">// 有则不操作，没则添加</span></span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;11&quot;</span>, (k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (v) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sd = value - v;</span><br><span class="line">                    <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//有则覆盖，没值的时候不操作</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 无 插入        // 有 判断是否想等 相等 不管 不等 插入</span></span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        Integer put = map1.put(<span class="string">&quot;11&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>好用的分页器</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  com.learn.common.util.page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sql 分页查询工具类 </span></span><br><span class="line"><span class="comment"> * 为解决 limit 1000000 5 实际会查出1000005条数据的分页问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLPageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用条件：     </span></span><br><span class="line"><span class="comment">     * 1、数据量大需要分页场景     </span></span><br><span class="line"><span class="comment">     * 2、sql语句如下     </span></span><br><span class="line"><span class="comment">     * example:     </span></span><br><span class="line"><span class="comment">     * select id,col1,col2 from t where col1=#&#123;xxx&#125; and id &gt; #&#123;minId&#125; order by id（索引id 最好是主键id） asc limit size     		 * 3、sql语句必须排序，否则需自己实现外部排序器，自行扩展     </span></span><br><span class="line"><span class="comment">     * 4、使用外部排序器，适用于sql中不带order by 的     </span></span><br><span class="line"><span class="comment">     * 使用此方法需注意 排序器的id 可能整形超长问题     </span></span><br><span class="line"><span class="comment">     * 建议sql中使用order by     </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;     </span></span><br><span class="line"><span class="comment">     * 递归调用     </span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageEntity     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends BasePageEntity, R&gt; <span class="function">Collection&lt;R&gt; <span class="title">page</span><span class="params">(PageEntity&lt;T, R&gt; pageEntity)</span> </span>&#123;</span><br><span class="line">        Collection&lt;R&gt; apply = pageEntity.function.apply(pageEntity.getParam());</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(apply)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        R t = tail(apply);</span><br><span class="line">        pageEntity.getParam().setMinId(pageEntity.getPageKey().apply(t));</span><br><span class="line">        apply.addAll(page(pageEntity));</span><br><span class="line">        <span class="keyword">return</span> apply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Collection 最后一个值     </span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apply     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">tail</span><span class="params">(Collection&lt;R&gt; apply)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;R&gt; iterator = apply.iterator();</span><br><span class="line">        R lastValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            lastValue = iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建分页     *     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageKey    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;     </span></span><br><span class="line"><span class="comment">     * 	<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends BasePageEntity, R&gt; <span class="function">PageEntity&lt;T, R&gt; <span class="title">create</span><span class="params">(T param, Function&lt;R, Long&gt; pageKey, Function&lt;T, Collection&lt;R&gt;&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQLPageUtil.PageEntity&lt;&gt;(param, pageKey, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;sql.search.page.size:500&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPageSize</span><span class="params">(Integer pageSize)</span> </span>&#123;</span><br><span class="line">        SQLPageUtil.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PageEntity</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BasePageEntity</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 入参</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> T param;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 主键值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Function&lt;R, Long&gt; pageKey;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理sql的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Function&lt;T, Collection&lt;R&gt;&gt; function;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PageEntity</span><span class="params">(T param, Function&lt;R, Long&gt; pageKey, Function&lt;T, Collection&lt;R&gt;&gt; function)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.param = param;</span><br><span class="line">            <span class="keyword">this</span>.param.setSize(pageSize);</span><br><span class="line">            <span class="keyword">this</span>.pageKey = pageKey;</span><br><span class="line">            <span class="keyword">this</span>.function = function;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;R&gt; <span class="title">page</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SQLPageUtil.page(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用</span><br><span class="line">(List&lt;User&gt;)SQLPageUtil.creat(<span class="keyword">new</span> QueryUserPage(),User::getId,x-&gt;userMapper.queryUserListByPage(x)).page();</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm类加载机制</title>
    <url>/2022/04/12/00-00-00-Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Jvm类加载机制"><a href="#Jvm类加载机制" class="headerlink" title="Jvm类加载机制"></a>Jvm类加载机制</h2><h3 id="1、类加载运行全过程"><a href="#1、类加载运行全过程" class="headerlink" title="1、类加载运行全过程"></a>1、类加载运行全过程</h3><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过<strong>类加载器</strong>把主类加载到JVM。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;  <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过Java命令执行代码的大体流程如下：</strong></p>
<p><img src="/2022/04/12/00-00-00-Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clipboard-1649858891376.png" alt="Java命令运行过程"></p>
<p>其中loadClass的类加载过程有如下几步：</p>
<p><strong>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;</strong> 使用 &gt;&gt; 卸载</p>
<ul>
<li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个<strong>代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口【从磁盘加载到内存】</li>
<li>验证：校验字节码文件的正确性【验证.class文件格式是否正确】</li>
<li>准备：给类的静态变量分配内存，并赋予默认值【静态变量赋初始值，比如 static int a = 6 会先把a赋值为0，对象则为null】</li>
<li>解析：将<strong>符号引用【比如public 标识符 main方法标识符等都是符号，这些符号最终加载到方法区内存都有对应的地址，这个地址就是直接引用】</strong>替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的<strong>静态链接</strong>过程(类加载期间完成)，<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用，下节课会讲到动态链接</li>
<li><strong>初始化</strong>：对类的静态变量初始化为指定的值，执行静态代码块</li>
</ul>
<p><img src="/2022/04/12/00-00-00-Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clipboard-1649858942610.png" alt="img"></p>
<p>类被加载到方法区中后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用</strong>等信息。</p>
<p><strong>类加载器的引用</strong>：这个类到类加载器实例的引用</p>
<p><strong>对应class实例的引用</strong>：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p>
<p><strong>注意，</strong>主类在运行过程中如果使用到其它类，会逐步加载这些类。</p>
<p>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamicLoad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load TestDynamicLoad************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load test************&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">null</span>;  <span class="comment">//B不会加载，除非这里执行 new B()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load A************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************initial A************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load B************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************initial B************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">*************load TestDynamicLoad************</span><br><span class="line">*************load A************</span><br><span class="line">*************initial A************</span><br><span class="line">*************load test************</span><br></pre></td></tr></table></figure>

<h3 id="2、类加载器和双亲委派机制"><a href="#2、类加载器和双亲委派机制" class="headerlink" title="2、类加载器和双亲委派机制"></a>2、类加载器和双亲委派机制</h3><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p>
<ul>
<li>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等</li>
<li>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包</li>
<li>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li>
<li>自定义加载器：负责加载用户自定义路径下的类包</li>
</ul>
<p>看一个<strong>类加载器</strong>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDKClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.class.getClassLoader());<span class="comment">//jre/lib下，引导类加载器</span></span><br><span class="line">        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());<span class="comment">//jre/lib/ext</span></span><br><span class="line">        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        ClassLoader extClassloader = appClassLoader.getParent();</span><br><span class="line">        ClassLoader bootstrapLoader = extClassloader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;the bootstrapLoader : &quot;</span> + bootstrapLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;the extClassloader : &quot;</span> + extClassloader);</span><br><span class="line">        System.out.println(<span class="string">&quot;the appClassLoader : &quot;</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrapLoader加载以下文件：&quot;</span>);</span><br><span class="line">        URL[] urls = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">            System.out.println(urls[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;extClassloader加载以下文件：&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;appClassLoader加载以下文件：&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">null</span> <span class="comment">// C++的对象 java查看就为null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">the bootstrapLoader : <span class="keyword">null</span></span><br><span class="line">the extClassloader : sun.misc.Launcher$ExtClassLoader@<span class="number">3764951d</span></span><br><span class="line">the appClassLoader : sun.misc.Launcher$AppClassLoader@14dad5dc</span><br><span class="line"></span><br><span class="line">bootstrapLoader加载以下文件：</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/resources.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/rt.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jsse.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jce.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/charsets.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jfr.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/classes</span><br><span class="line"></span><br><span class="line">extClassloader加载以下文件：</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br><span class="line"></span><br><span class="line">appClassLoader加载以下文件：</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\charsets.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\deploy.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\cldrdata.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\dnsns.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\jaccess.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\jfxrt.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\localedata.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\nashorn.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunec.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunjce_provider.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunmscapi.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunpkcs11.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\zipfs.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\javaws.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jce.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jfr.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jfxswt.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jsse.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\management-agent.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\plugin.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\resources.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\rt.jar;D:\ideaProjects\project-all\target\classes;C:\Users\zhuge\.m2\repository\org\apache\zookeeper\zookeeper\<span class="number">3.4</span><span class="number">.12</span>\zookeeper-<span class="number">3.4</span><span class="number">.12</span>.jar;C:\Users\zhuge\.m2\repository\org\slf4j\slf4j-api\<span class="number">1.7</span><span class="number">.25</span>\slf4j-api-<span class="number">1.7</span><span class="number">.25</span>.jar;C:\Users\zhuge\.m2\repository\org\slf4j\slf4j-log4j12\<span class="number">1.7</span><span class="number">.25</span>\slf4j-log4j12-<span class="number">1.7</span><span class="number">.25</span>.jar;C:\Users\zhuge\.m2\repository\log4j\log4j\<span class="number">1.2</span><span class="number">.17</span>\log4j-<span class="number">1.2</span><span class="number">.17</span>.jar;C:\Users\zhuge\.m2\repository\jline\jline\<span class="number">0.9</span><span class="number">.94</span>\jline-<span class="number">0.9</span><span class="number">.94</span>.jar;C:\Users\zhuge\.m2\repository\org\apache\yetus\audience-annotations\<span class="number">0.5</span><span class="number">.0</span>\audience-annotations-<span class="number">0.5</span><span class="number">.0</span>.jar;C:\Users\zhuge\.m2\repository\io\netty\netty\<span class="number">3.10</span><span class="number">.6</span>.Final\netty-<span class="number">3.10</span><span class="number">.6</span>.Final.jar;C:\Users\zhuge\.m2\repository\com\google\guava\guava\<span class="number">22.0</span>\guava-<span class="number">22.0</span>.jar;C:\Users\zhuge\.m2\repository\com\google\code\findbugs\jsr305\<span class="number">1.3</span><span class="number">.9</span>\jsr305-<span class="number">1.3</span><span class="number">.9</span>.jar;C:\Users\zhuge\.m2\repository\com\google\errorprone\error_prone_annotations\<span class="number">2.0</span><span class="number">.18</span>\error_prone_annotations-<span class="number">2.0</span><span class="number">.18</span>.jar;C:\Users\zhuge\.m2\repository\com\google\j2objc\j2objc-annotations\<span class="number">1.1</span>\j2objc-annotations-<span class="number">1.1</span>.jar;C:\Users\zhuge\.m2\repository\org\codehaus\mojo\animal-sniffer-annotations\<span class="number">1.14</span>\animal-sniffer-annotations-<span class="number">1.14</span>.jar;D:\dev\IntelliJ IDEA <span class="number">2018.3</span><span class="number">.2</span>\lib\idea_rt.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>类加载器初始化过程：</strong></p>
<p>参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。</p>
<p>在Launcher构造方法内部，其创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。</p>
<p>JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</p>
<p>思考：为什么不是从引导类加载器向下加载呢？</p>
<p>答：猜测：应用程序中，绝大多数代码都是应用自身的代码，先由应用程序加载器加载，使得绝大多数类被加载缓存在应用程序加载类中，每次用的时候直接去应用程序加载器缓存拿就好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Launcher的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造扩展类加载器，在构造的过程中将其父加载器设置为null</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，</span></span><br><span class="line">        <span class="comment">//Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序</span></span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">    String var2 = System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">    。。。 。。。 <span class="comment">//省略一些不需关注代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双亲委派机制</strong></p>
<p>JVM类加载器是有亲子层级结构的，如下图</p>
<p><img src="/2022/04/12/00-00-00-Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clipboard-1649859285453.png" alt="img"></p>
<p>这里类加载其实就有一个<strong>双亲委派机制</strong>，加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。</p>
<p>比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器，应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。。</p>
<p><strong>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</strong></p>
<p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下：</p>
<ol>
<li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li>
<li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li>
<li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查当前类加载器是否已经加载了该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  <span class="comment">//如果当前加载器父加载器不为空则委托父加载器加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//不会执行</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要设计双亲委派机制？</strong></p>
<ul>
<li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改</li>
<li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证<strong>被加载类的唯一性</strong></li>
</ul>
<p>看一个类加载示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure>

<h3 id="3、全盘负责委托机制"><a href="#3、全盘负责委托机制" class="headerlink" title="3、全盘负责委托机制"></a>3、全盘负责委托机制</h3><p>“<strong>全盘负责</strong>”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。</p>
<p><strong>自定义类加载器示例：</strong></p>
<p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写<strong><strong>findClass</strong></strong>方法</strong>。自定义类加载器，父加载器是应用程序加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line"><span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line"><span class="comment">//defineClass是底层做类加载的</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="comment">//D盘创建 test/com/tuling/jvm 几级目录，将User类的复制类User1.class丢入该目录</span></span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure>

<p><strong>打破双亲委派机制</strong></p>
<p>再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现的 java.lang.String.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试用自己改写类加载机制去加载自己写的java.lang.String.class</span></span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">659</span>)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4、Tomcat打破双亲委派机制"><a href="#4、Tomcat打破双亲委派机制" class="headerlink" title="4、Tomcat打破双亲委派机制"></a>4、Tomcat打破双亲委派机制</h3><p>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？</p>
<p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题： </p>
<ol>
<li><p>一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 </p>
</li>
<li><p>部署在同一个web容器中<strong>相同的类库相同的版本可以共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。 </p>
</li>
<li><p><strong>web容器也有自己依赖的类库，不能与应用程序的类库混淆</strong>。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 </p>
</li>
<li><p>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p>
</li>
</ol>
<p>再看看我们的问题：<strong>Tomcat 如果使用默认的双亲委派类加载机制行不行？</strong> </p>
<p>答案是不行的。为什么？</p>
<p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>
<p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证<strong>唯一性</strong>。</p>
<p>第三个问题和第一个问题一样。</p>
<p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<p><strong>Tomcat自定义加载器详解</strong></p>
<p><img src="/2022/04/12/00-00-00-Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clipboard-1649859429756.png" alt="img"></p>
<p>tomcat的几个主要类加载器：</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本；</li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</p>
<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>
<p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p>
<p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗？答案是：违背了。 </p>
<p>很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，<strong>每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制</strong>。</p>
<p><strong>模拟实现Tomcat的webappClassLoader加载自己war包应用内不同版本类实现相互共存与隔离</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//非自定义的类还是走双亲委派加载</span></span><br><span class="line">                    <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;com.tuling.jvm&quot;</span>))&#123;</span><br><span class="line">                        c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test1&quot;</span>);</span><br><span class="line">        Class clazz1 = classLoader1.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        Object obj1 = clazz1.newInstance();</span><br><span class="line">        Method method1= clazz1.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method1.invoke(obj1, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz1.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@266474c2</span><br><span class="line"></span><br><span class="line">=======另外一个User1版本：自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@66d3c617</span><br></pre></td></tr></table></figure>

<p>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</p>
<p><strong>模拟实现Tomcat的JasperLoader热加载</strong></p>
<p>原理：后台启动线程监听jsp文件变化，如果变化了找到该jsp对应的servlet类的加载器引用(gcroot)，重新生成新的<strong>JasperLoader</strong>加载器赋值给引用，然后加载新的jsp对应的servlet类，之前的那个加载器因为没有gcroot引用了，下一次gc的时候会被销毁。</p>
<p>附下User类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======自己的加载器加载类调用方法=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：Hotspot源码JVM启动执行main方法流程</strong></p>
<p><img src="/2022/04/12/00-00-00-Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/hotspot%E6%BA%90%E7%A0%81jvm%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8Cmain%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B-1649859490385.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">类加载过程：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、加载：将字节码文件从磁盘读入内存</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、验证：校验字节码的正确性</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、准备：给类的静态变量赋初值，比如<span class="keyword">int</span>类型赋<span class="number">0</span>，引用类型赋<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、解析：将符号引用替换为直接引用-&gt;静态链接过程；程序运行期间完成符号引用替换为直接引用叫动态链接</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、初始化：对类的静态变量初始化为指定的值，执行静态代码块</span><br><span class="line"></span><br><span class="line">类加载的双亲委派机制：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、类加载器分类：引导类加载器、扩展类加载器、应用程序类加载器、自定义类加载器</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、双亲委派过程：子加载器加载某个类时会先委托父加载器去加载这个类，父加载器在本地查找这个类，如果加载过了就不在加载；如果在自己的类路径下找不到目标类就向上请求父加载器加载，直到引导类加载器。如果都父加载器都没有在本地路径下找到目标类，则有子加载器本身加载</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、双亲委派优点：<span class="number">1</span>&gt;沙箱安全机制防止核心库被篡改<span class="number">2</span>&gt;防止重复加载</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、如何打破双亲委派：重写find方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tomcat为什么要打破双亲委派：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、一个web容器部署多个应用程序，不同应用程序可能以来同一个第三方类库的不同版本，不能要求不同应用程序使用同一版本类库</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、部署在同一web容器的同一版本的第三方库需要可以共享。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、web容器也有自己需要依赖的类，不能与应用程序混淆。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、web容器需要支持jsp的修改，需要支持jsp修改后不用重启。</span><br></pre></td></tr></table></figure>

<p>每日一道算法题：</p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br>示例 2：</p>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]<br>示例 3：</p>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
<p>提示：</p>
<p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;= Node.val &lt;= 9<br>题目数据保证列表表示的数字不含前导零</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l1 == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( l2 == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        ListNode result = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">int</span> l1Num = l1 == <span class="keyword">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="keyword">int</span> l2Num = l2 == <span class="keyword">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = l1Num + l2Num + num;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( sum &gt;= <span class="number">10</span> )&#123;</span><br><span class="line">                res = sum -<span class="number">10</span>;</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( result == <span class="keyword">null</span> )&#123;</span><br><span class="line">                result = <span class="keyword">new</span> ListNode(res);    </span><br><span class="line">                node = result;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.next = <span class="keyword">new</span> ListNode(res);</span><br><span class="line">                result = result.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( l1 != <span class="keyword">null</span> )&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( l2 != <span class="keyword">null</span> )&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( num ==<span class="number">1</span>  &amp;&amp; result != <span class="keyword">null</span> )&#123;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm对象创建与内存分配机制深度剖析</title>
    <url>/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Jvm对象创建与内存分配机制深度剖析"><a href="#Jvm对象创建与内存分配机制深度剖析" class="headerlink" title="Jvm对象创建与内存分配机制深度剖析"></a>Jvm对象创建与内存分配机制深度剖析</h2><h2 id="一、对象的创建"><a href="#一、对象的创建" class="headerlink" title="一、对象的创建"></a>一、对象的创建</h2><p>对象创建的主要流程:</p>
<p><img src="/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/clipboard-1650200740666.png" alt="img"></p>
<p><strong>1.类加载检查</strong></p>
<p> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p> new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p>
<p><strong>2.分配内存</strong></p>
<p> 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p>
<p>这个步骤有两个问题：</p>
<p>1.如何划分内存。</p>
<p>2.在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p><strong>划分内存的方法：</strong></p>
<ul>
<li>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)</li>
</ul>
<p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<ul>
<li>“空闲列表”（Free List）</li>
</ul>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</p>
<p><strong>解决并发问题的方法：</strong></p>
<ul>
<li>CAS（compare and swap）</li>
</ul>
<p>虚拟机采用<strong>CAS配上失败重试</strong>的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p>
<ul>
<li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</li>
</ul>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过**-XX:+/-*<em><strong>UseTLAB</strong>参数来设定虚拟机是否使用TLAB(JVM会默认开启</em>*-XX:+**<strong>UseTLAB</strong>)，-XX:TLABSize 指定TLAB大小。</p>
<p><strong>3.初始化零值</strong></p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>4.设置对象头</strong></p>
<p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。</p>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>32位对象头</strong></p>
<p><img src="/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/clipboard-1650200753189.png" alt="img"></p>
<p><strong>Klass指针指向的元空间中的类元信息，jvm内部使用的就是Klass【c++对象】，对象的.getClass()对象【java对象】则是jvm生成的给java开发者使用的</strong></p>
<p><strong>64位对象头</strong></p>
<p><img src="/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/clipboard-1650200763541.png" alt="img"></p>
<p>对象头在hotspot的C++源码markOop.hpp文件里的注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>

<p><strong>5.执行<init>方法</init></strong></p>
<p> 执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</init></p>
<p><strong>对象大小与指针压缩</strong></p>
<p>对象大小可以用jol-core包查看，引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算对象大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOLSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLayout layout = ClassLayout.parseInstance(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        ClassLayout layout1 = ClassLayout.parseInstance(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;);</span><br><span class="line">        System.out.println(layout1.toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        ClassLayout layout2 = ClassLayout.parseInstance(<span class="keyword">new</span> A());</span><br><span class="line">        System.out.println(layout2.toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedOops           默认开启的压缩所有指针</span></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedClassPointers  默认开启的压缩对象头里的类型指针Klass Pointer</span></span><br><span class="line">    <span class="comment">// Oops : Ordinary Object Pointers</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">                       <span class="comment">//8B mark word</span></span><br><span class="line">                       <span class="comment">//4B Klass Pointer   如果关闭压缩-XX:-UseCompressedClassPointers或-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">        <span class="keyword">int</span> id;        <span class="comment">//4B</span></span><br><span class="line">        String name;   <span class="comment">//4B  如果关闭压缩-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">        <span class="keyword">byte</span> b;        <span class="comment">//1B </span></span><br><span class="line">        Object o;      <span class="comment">//4B  如果关闭压缩-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)    <span class="comment">//mark word</span></span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)    <span class="comment">//mark word     </span></span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)    <span class="comment">//Klass Pointer</span></span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[I object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">6d</span> <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">01101101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217363</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>    <span class="keyword">int</span> [I.&lt;elements&gt;                             N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">com.tuling.jvm.JOLSample$A object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>                    (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>                    (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>                    (object header)                           <span class="number">61</span> cc <span class="number">00</span> f8 (<span class="number">01100001</span> <span class="number">11001100</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134165407</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>                <span class="keyword">int</span> A.id                                      <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">1</span>               <span class="keyword">byte</span> A.b                                       <span class="number">0</span></span><br><span class="line">     <span class="number">17</span>     <span class="number">3</span>                    (alignment/padding gap)                  </span><br><span class="line">     <span class="number">20</span>     <span class="number">4</span>   java.lang.String A.name                                    <span class="keyword">null</span></span><br><span class="line">     <span class="number">24</span>     <span class="number">4</span>   java.lang.Object A.o                                       <span class="keyword">null</span></span><br><span class="line">     <span class="number">28</span>     <span class="number">4</span>                    (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">7</span> bytes total</span><br></pre></td></tr></table></figure>

<p>什么是java对象的<strong>指针压缩</strong>？</p>
<p>1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩</p>
<p>2.jvm配置参数:UseCompressedOops，compressed–压缩、oop(ordinary object pointer)–对象指针</p>
<p>3.启用指针压缩:-XX:+UseCompressedOops(<strong>默认开启</strong>)，禁止指针压缩:-XX:-UseCompressedOops</p>
<p>为什么要进行指针压缩？</p>
<p>1.在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，<strong>占用较大宽带，同时GC也会承受较大压力</strong></p>
<p>2.为了减少64位平台下内存的消耗，启用指针压缩功能</p>
<p>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入<strong>堆内存</strong>时压缩编码、取出到<strong>cpu寄存器</strong>后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方=32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</p>
<p>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</p>
<p>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p>
<p>关于指针压缩个人理解：</p>
<p>32位最大表示内存4g，当使用32位地址记录超过4g内存地址时，采用一定的压缩算法，将本来需要超过32位表示的地址压缩成能够使用32位地址来表示，cpu寄存器在使用使用时通过对应的解码算法算出对应的超过32位的地址寻址，使得32位地址可以表示超过4g内存</p>
<p><strong>关于对齐填充：</strong>对于大部分处理器，对象以8字节整数倍来对齐填充都是最高效的存取方式。</p>
<h2 id="二、对象内存分配"><a href="#二、对象内存分配" class="headerlink" title="二、对象内存分配"></a>二、对象内存分配</h2><p><strong>对象内存分配流程图</strong></p>
<p><img src="/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/327202027172.png" alt="img"></p>
<p><strong>对象栈上分配</strong></p>
<p>我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<p><strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   User user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   User user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。</p>
<p>JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>)，<strong>JDK7之后默认开启逃逸分析</strong>，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p>
<p><strong>标量替换：</strong>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，<strong>JDK7之后默认开启</strong>。</p>
<p><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p>
<p><strong>栈上分配示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配，标量替换</span></span><br><span class="line"><span class="comment"> * 代码调用了1亿次alloc()，如果是分配到堆上，大概需要1GB以上堆空间，如果堆空间小于该值，必然会触发GC。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用如下参数不会发生GC</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 使用如下参数都会发生大量GC</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllotOnStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：****栈上分配依赖于逃逸分析和标量替换</strong></p>
<p><strong>对象在Eden区分配</strong></p>
<p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。</p>
<p>在测试之前我们先来看看 <strong>Minor GC和Full GC 有什么不同呢？</strong></p>
<ul>
<li><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<p><strong>Eden与Survivor区默认8:1:1</strong></p>
<p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可，</strong></p>
<p>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//allocation2 = new byte[8000*1024];</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 65536K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000770900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">100</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fe80000</span>,<span class="number">0x000000076fe80000</span>,<span class="number">0x0000000770900000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 0K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少几M内存）。<strong>假如我们再为allocation2分配内存会出现什么情况呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 65253K-&gt;936K(76288K)] 65253K-&gt;60944K(251392K), <span class="number">0.0279083</span> secs] [Times: user=<span class="number">0.13</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 9591K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">13</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076bc73ef8</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ea020</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 60008K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好把新生代的对象<strong>提前转移到老年代</strong>中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">      allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 65253K-&gt;952K(76288K)] 65253K-&gt;60960K(251392K), <span class="number">0.0311467</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 13878K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">19</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076c09fb68</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ee030</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 60008K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used 3343K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<p><strong>大对象直接进入老年代</strong></p>
<p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p>
<p>比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节)  -XX:+UseSerialGC  ，再执行下上面的第一个程序会发现大对象直接进了老年代</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时的复制操作而降低效率。</p>
<p><strong>长期存活的对象将进入老年代</strong></p>
<p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p>
<p><strong>对象动态年龄判断</strong></p>
<p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以<strong>直接进入老年代</strong>了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的。</strong></p>
<p><strong>老年代空间分配担保机制</strong></p>
<p>年轻代每次<strong>minor gc</strong>之前JVM都会计算下老年代<strong>剩余可用空间</strong></p>
<p>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong>)</p>
<p>就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了</p>
<p>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的<strong>平均大小</strong>。</p>
<p>如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”</p>
<p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p>
<p><img src="/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/clipboard-1650200974560.png" alt="img"></p>
<h2 id="三、对象内存回收"><a href="#三、对象内存回收" class="headerlink" title="三、对象内存回收"></a>三、对象内存回收</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p><strong>引用计数法</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">   Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">      ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">      objA.instance = objB;</span><br><span class="line">      objB.instance = objA;</span><br><span class="line">      objA = <span class="keyword">null</span>;</span><br><span class="line">      objB = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可达性分析算法</strong></p>
<p>将<strong>“GC Roots”</strong> 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象</p>
<p><strong>GC Roots</strong>根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</p>
<p><img src="/2022/04/16/00-00-03-Jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/6e72848c54e84bb7a76f0ff89ed5010d.jpeg" alt="img"></p>
<p><strong>常见引用类型</strong></p>
<p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<p><strong>强引用</strong>：普通的变量引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt; user = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure>

<p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p>
<p><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure>

<p><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p>
<p><strong>finalize()方法最终判定对象是否存活</strong></p>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>
<p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p>
<p><strong>1. 第一次标记并进行一次筛选。</strong></p>
<p>筛选的条件是此对象是否有必要执行finalize()方法。</p>
<p>当对象没有覆盖finalize方法，对象将直接被回收。</p>
<p><strong>2. 第二次标记</strong></p>
<p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p>
<p>注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         list.add(<span class="keyword">new</span> User(i++, UUID.randomUUID().toString()));</span><br><span class="line">         <span class="keyword">new</span> User(j--, UUID.randomUUID().toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//User类需要重写finalize方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    OOMTest.list.add(<span class="keyword">this</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;关闭资源，userid=&quot;</span> + id + <span class="string">&quot;即将被回收&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finalize()方法的运行代价高昂， 不确定性大， 无法保证各个对象的调用顺序， 如今已被官方明确声明为不推荐使用的语法。 有些资料描述它适合做“关闭外部资源”之类的清理性工作， 这完全是对finalize()方法用途的一种自我安慰。 finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时， 所以建议大家完全可以忘掉Java语言里面的这个方法。</p>
<p><strong>如何判断一个类是无用的类</strong></p>
<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类呢？</p>
<p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。【一般是自定义类加载器比如tomcat自定义的类加载jsp类加载器】</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line"></span><br><span class="line">一、java对象创建：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、类加载检查</span><br><span class="line"></span><br><span class="line">jvm遇到一条<span class="keyword">new</span>指令时，首先会去检查这个指令对应的参数能否在常量池中定位到一个类的符号引用，并且检查这个类是否被加载、解析过，如果没有则执行类的加载过程</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、对象内存分配</span><br><span class="line"></span><br><span class="line">指针碰撞（默认使用）：如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</span><br><span class="line"></span><br><span class="line">空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</span><br><span class="line"></span><br><span class="line">解决内存分配并发问题：</span><br><span class="line"></span><br><span class="line">cas：虚拟机采用**CAS配上失败重试**的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</span><br><span class="line"></span><br><span class="line">本地线程分配缓存（TLAB）：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，**-XX:+/- UseTLAB**参数来设定</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、初始化零值</span><br><span class="line"></span><br><span class="line">内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、设置对象头</span><br><span class="line"></span><br><span class="line">对象头：</span><br><span class="line"></span><br><span class="line">markword标记字段、自身运行时数据（hashcode，对象分代年龄、锁状态标志位、线程持有的锁、偏向线程id、偏向时间戳）；Klass指针：指向方法区的类元数据，非java对象的<span class="class"><span class="keyword">class</span>；数组长度：针对数组类型，存储长度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">实例数据：对象本身的数据存储</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">对齐填充位：对于大部分处理器，对象以8字节整数倍来对齐填充都是最高效的存取方式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">5、执行<span class="title">init</span>方法</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">这里区别下类加载过程的准备和初始化阶段：类加载过程中的准备阶段是针对静态变量赋默认值，比如<span class="title">int</span>类型就是0，引用类型就是<span class="title">null</span>；类加载过程中的初始化阶段也是针对静态变量和静态代码块</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">指针压缩：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">关于指针压缩个人理解：32位最大表示内存4<span class="title">g</span>，当使用32位地址记录超过4<span class="title">g</span>内存地址时，采用一定的压缩算法，将本来需要超过32位表示的地址压缩成能够使用32位地址来表示，<span class="title">cpu</span>寄存器在使用使用时通过对应的解码算法算出对应的超过32位的地址寻址，使得32位地址可以表示超过4<span class="title">g</span>内存</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">指针压缩好处：在64位平台的<span class="title">HotSpot</span>中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，**占用较大宽带，同时<span class="title">GC</span>也会承受较大压力**</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">二、对象内存分配</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">一般来说，新创建的对象内存一般是在堆上分配，但是也有在栈上分配的。为了减少临时对象在堆内分配的数量，<span class="title">JVM</span>通过**逃逸分析**确定该对象不会被外部访问。如果不会逃逸可以将该对象在**栈上分配**内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。对象逃逸分析就是分析对象的动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<span class="title">Jvm</span>不会创建该对象，而是将该对象分解成若干个被这个方法使用的成员变量所替代，这些代替的成员变量在栈帧或寄存器上分配空间。这样就不会因为没有一大片连续空间导致对象内存不够分配。标量：就是不可被进一步分解的量，二<span class="title">java</span>的基本类型就是标量，标量对应的就是可以被进一步分解的量，这种就聚合量，在<span class="title">java</span>中对象就是可以被进一步分解的量。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">大多数对象都是分配在<span class="title">eden</span>，<span class="title">eden</span>内存不够时，就会触发<span class="title">minor</span> <span class="title">gc</span> / <span class="title">young</span> <span class="title">gc</span></span>;</span><br><span class="line"></span><br><span class="line">minor gc /young gc：指在年轻代发生的gc，minor gc非常频繁，回收速度一般也比较快。</span><br><span class="line"></span><br><span class="line">major gc / full gc：一般时回收老年代，年轻代，方法区中的垃圾，major gc 的速度一般也比minor gc 慢十倍以上。</span><br><span class="line"></span><br><span class="line">新生代分为eden、survivor 区（s0,s1）比例为<span class="number">8</span>：<span class="number">1</span>：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">**大对象直接进入老年代**</span><br><span class="line"></span><br><span class="line">大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</span><br><span class="line"></span><br><span class="line">比如设置JVM参数：-XX:PretenureSizeThreshold=<span class="number">1000000</span> (单位是字节)  -XX:+UseSerialGC  ，再执行下上面的第一个程序会发现大对象直接进了老年代</span><br><span class="line"></span><br><span class="line">**为什么要这样呢？**</span><br><span class="line"></span><br><span class="line">为了避免为大对象分配内存时的复制操作而降低效率。</span><br><span class="line"></span><br><span class="line">**长期存活的对象将进入老年代**</span><br><span class="line"></span><br><span class="line">既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</span><br><span class="line"></span><br><span class="line">如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为<span class="number">1</span>。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加<span class="number">1</span>岁，当它的年龄增加到一定程度（默认为<span class="number">15</span>岁，CMS收集器默认<span class="number">6</span>岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 **-XX:MaxTenuringThreshold** 来设置。</span><br><span class="line"></span><br><span class="line">**老年代空间分配担保机制**</span><br><span class="line"></span><br><span class="line">年轻代每次**minor gc**之前JVM都会计算下老年代**剩余可用空间**</span><br><span class="line"></span><br><span class="line">如果这个可用空间小于年轻代里现有的所有对象大小之和(**包括垃圾对象**)</span><br><span class="line"></span><br><span class="line">就会看一个“-XX:-HandlePromotionFailure”(jdk1<span class="number">.8</span>默认就设置了)的参数是否设置了</span><br><span class="line"></span><br><span class="line">如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的**平均大小**。</span><br><span class="line"></span><br><span class="line">如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生<span class="string">&quot;OOM&quot;</span></span><br><span class="line"></span><br><span class="line">当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</span><br><span class="line"></span><br><span class="line">三、**对象内存回收**</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、引用计数法</span><br><span class="line"></span><br><span class="line">给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加<span class="number">1</span>；当引用失效，计数器就减<span class="number">1</span>；任何时候计数器为<span class="number">0</span>的对象就是不可能再被使用的。</span><br><span class="line"></span><br><span class="line">**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、可达性分析算法</span><br><span class="line"></span><br><span class="line">将**“GC Roots”** 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为**非垃圾对象**，其余未标记的对象都是垃圾对象</span><br><span class="line"></span><br><span class="line">**GC Roots**根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、常见引用类型</span><br><span class="line"></span><br><span class="line">java的引用类型一般分为四种：**强引用**、**软引用**、弱引用、虚引用</span><br><span class="line"></span><br><span class="line">**强引用**：普通的变量引用</span><br><span class="line"></span><br><span class="line">**软引用**：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。**软引用可用来实现内存敏感的高速缓存。**</span><br><span class="line"></span><br><span class="line">**弱引用**：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，**GC会直接回收掉**，很少用</span><br><span class="line"></span><br><span class="line">**虚引用：**虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</span><br><span class="line"></span><br><span class="line">**finalize()方法最终判定对象是否存活**</span><br><span class="line"></span><br><span class="line">即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</span><br><span class="line"></span><br><span class="line">**标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。**</span><br><span class="line"></span><br><span class="line">**<span class="number">1.</span> 第一次标记并进行一次筛选。**</span><br><span class="line"></span><br><span class="line">筛选的条件是此对象是否有必要执行finalize()方法。</span><br><span class="line"></span><br><span class="line">当对象没有覆盖finalize方法，对象将直接被回收。</span><br><span class="line"></span><br><span class="line">**<span class="number">2.</span> 第二次标记**</span><br><span class="line"></span><br><span class="line">如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、如何判断一个类是无用的类</span><br><span class="line"></span><br><span class="line">- 该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</span><br><span class="line">- 加载该类的 ClassLoader 已经被回收。【一般是自定义类加载器比如tomcat自定义的类加载jsp类加载器】</span><br><span class="line">- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>性能调优</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战</title>
    <url>/2022/08/18/03-04-02-RocketMQ%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h1 id="一、RocketMQ的使用"><a href="#一、RocketMQ的使用" class="headerlink" title="一、RocketMQ的使用"></a>一、RocketMQ的使用</h1><h2 id="1-1环境搭建"><a href="#1-1环境搭建" class="headerlink" title="1.1环境搭建"></a>1.1环境搭建</h2><p>新建maven项目，引入如下依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.7</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-2RocketMQ的编程模型"><a href="#1-2RocketMQ的编程模型" class="headerlink" title="1.2RocketMQ的编程模型"></a>1.2RocketMQ的编程模型</h2><ul>
<li><p>消息发送者的固定步骤</p>
<p>1.创建消息生产者producer，并制定生产者组名<br>2.指定Nameserver地址<br>3.启动producer<br>4.创建消息对象，指定主题Topic、Tag和消息体<br>5.发送消息<br>6.关闭生产者producer</p>
</li>
<li><p>消息消费者的固定步骤</p>
<p>1.创建消费者Consumer，制定消费者组名<br>2.指定Nameserver地址<br>3.订阅主题Topic和Tag<br>4.设置回调函数，处理消息<br>5.启动消费者consumer</p>
</li>
</ul>
<h2 id="1-3RocketMQ的消息类型"><a href="#1-3RocketMQ的消息类型" class="headerlink" title="1.3RocketMQ的消息类型"></a>1.3RocketMQ的消息类型</h2><h3 id="1-3-1基本消息"><a href="#1-3-1基本消息" class="headerlink" title="1.3.1基本消息"></a>1.3.1基本消息</h3><ul>
<li><p>1、同步发送消息</p>
<blockquote>
<p>生产者发送完消息，收到broker响应之后才继续往下执行</p>
<p>等待消息返回后再继续进行下面的操作。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单样例：同步发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>);</span><br><span class="line"><span class="comment">//        producer.setNamesrvAddr(&quot;192.168.232.128:9876&quot;);</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    <span class="comment">//同步传递消息，消息会发给集群中的一个Broker节点。</span></span><br><span class="line">                     SendResult sendResult = producer.send(msg);</span><br><span class="line"><span class="comment">//                    System.out.printf(&quot;%s%n&quot;, sendResult);</span></span><br><span class="line">                   <span class="comment">// producer.sendOneway(msg);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>2、异步发送消息</p>
<blockquote>
<p>这个示例有个比较有趣的地方就是引入了一个countDownLatch来保证所有消息回调方法都执行完了再关闭Producer。 所以从这里可以看出，RocketMQ的Producer也是一个服务端，在往Broker发送消息的时候也要作为服务端提供服务。</p>
<p>通过回调的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//简单样例：异步发送消息</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException, UnsupportedEncodingException </span>&#123;</span><br><span class="line"></span><br><span class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Jodie_Daily_test&quot;</span>);</span><br><span class="line">&gt;<span class="comment">//        producer.setNamesrvAddr(&quot;192.168.232.128:9876&quot;);</span></span><br><span class="line">      producer.start();</span><br><span class="line">      producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> messageCount = <span class="number">100</span>;</span><br><span class="line">      <span class="comment">//由于是异步发送，这里引入一个countDownLatch，保证所有Producer发送消息的回调方法都执行完了再停止Producer服务。</span></span><br><span class="line">      <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(messageCount);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">              Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">              producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                      countDownLatch.countDown();</span><br><span class="line">                      System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                      countDownLatch.countDown();</span><br><span class="line">                      System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">              System.out.println(<span class="string">&quot;消息发送完成&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>3、单向发送消息</p>
<blockquote>
<p>关键点就是使用producer.sendOneWay方式来发送消息，这个方法没有返回值，也没有回调。就是只管把消息发出去就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Wait for sending to complete</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);        </span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>4、使用消费者消费消息</p>
<blockquote>
<p>消费者消费消息有两种模式，一种是消费者主动去Broker上拉取消息的拉模式，另一种是消费者等待Broker把消息推送过来的推模式。</p>
<ul>
<li><p>拉模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; OFFSE_TABLE = <span class="keyword">new</span> HashMap&lt;MessageQueue, Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPullConsumer consumer = <span class="keyword">new</span> DefaultMQPullConsumer(<span class="string">&quot;please_rename_unique_group_name_5&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">&quot;TopicTest&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Consume from the queue: %s%n&quot;</span>, mq);</span><br><span class="line">            SINGLE_MQ:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PullResult pullResult =</span><br><span class="line">                        consumer.pullBlockIfNotFound(mq, <span class="keyword">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, pullResult);</span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                            <span class="keyword">break</span> SINGLE_MQ;</span><br><span class="line">                        <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        Long offset = OFFSE_TABLE.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        OFFSE_TABLE.put(mq, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>推模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;CID_JODIE_1&quot;</span>);</span><br><span class="line"><span class="comment">//        consumer.setNamesrvAddr(&quot;192.168.232.128:9876&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">//wrong time format 2017_0422_221800</span></span><br><span class="line">        consumer.setConsumeTimestamp(<span class="string">&quot;20181109221800&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，用推模式比较简单。</p>
<p>实际上RocketMQ的推模式也是由拉模式封装出来的。</p>
<p>4.7.1版本中DefaultMQPullConsumerImpl这个消费者类已标记为过期，但是还是可以使用的。替换的类是DefaultLitePullConsumerImpl。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="1-3-2顺序消息"><a href="#1-3-2顺序消息" class="headerlink" title="1.3.2顺序消息"></a>1.3.2顺序消息</h3><ul>
<li><p>顺序消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line"><span class="comment">//            producer.setNamesrvAddr(&quot;192.168.232.128:9876&quot;);</span></span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> orderId = i;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">5</span> ; j ++)&#123;</span><br><span class="line">                    Message msg =</span><br><span class="line">                            <span class="keyword">new</span> Message(<span class="string">&quot;OrderTopicTest&quot;</span>, <span class="string">&quot;order_&quot;</span>+orderId, <span class="string">&quot;KEY&quot;</span> + orderId,</span><br><span class="line">                                    (<span class="string">&quot;order_&quot;</span>+orderId+<span class="string">&quot; step &quot;</span> + j).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                            Integer id = (Integer) arg;</span><br><span class="line">                            <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                            <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, orderId);</span><br><span class="line"></span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>顺序消息消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_3&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;OrderTopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">for</span>(MessageExt msg:msgs)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到消息内容 &quot;</span>+<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        这样是保证不了最终消费顺序的。</span></span><br><span class="line"><span class="comment">//        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span></span><br><span class="line"><span class="comment">//                for(MessageExt msg:msgs)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;收到消息内容 &quot;+new String(msg.getBody()));</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>验证时，可以启动多个Consumer实例，观察下每一个订单的消息分配以及每个订单下多个步骤的消费顺序。</p>
<p>不管订单在多个Consumer实例之前是如何分配的，每个订单下的多条消息顺序都是固定从0~5的。</p>
<p>RocketMQ保证的是消息的局部有序，而不是全局有序。</p>
</blockquote>
<blockquote>
<p>先从控制台上看下List<MessageQueue> mqs是什么。</MessageQueue></p>
<p>再回看我们的样例，实际上，RocketMQ也只保证了每个OrderID的所有消息有序(发到了同一个queue)，而并不能保证所有消息都有序。所以这就涉及到了RocketMQ消息有序的原理。要保证最终消费到的消息是有序的，需要从Producer、Broker、Consumer三个步骤都保证消息有序才行。</p>
<p>首先在发送者端：在默认情况下，消息发送者会采取Round Robin轮询方式把消息发送到不同的MessageQueue(分区队列)，而消费者消费的时候也从多个MessageQueue上拉取消息，这种情况下消息是不能保证顺序的。而只有当一组有序的消息发送到同一个MessageQueue上时，才能利用MessageQueue先进先出的特性保证这一组消息有序。</p>
<p>而Broker中一个队列内的消息是可以保证有序的。</p>
<p>然后在消费者端：消费者会从多个消息队列上去拿消息。这时虽然每个消息队列上的消息是有序的，但是多个队列之间的消息仍然是乱序的。消费者端要保证消息有序，就需要按队列一个一个来取消息，即取完一个队列的消息后，再去取下一个队列的消息。而给consumer注入的MessageListenerOrderly对象，在RocketMQ内部就会通过锁队列的方式保证消息是一个一个队列来取的。MessageListenerConcurrently这个消息监听器则不会锁队列，每次都是从多个Message中取一批数据（默认不超过32条）。因此也无法保证消息有序。</p>
</blockquote>
</li>
</ul>
<h3 id="1-3-3广播消息"><a href="#1-3-3广播消息" class="headerlink" title="1.3.3广播消息"></a>1.3.3广播消息</h3><blockquote>
<p>广播消息并没有特定的消息消费者样例，这是因为这涉及到消费者的集群消费模式。在集群状态(MessageModel.CLUSTERING)下，每一条消息只会被同一个消费者组中的一个实例消费到(这跟kafka和rabbitMQ的集群模式是一样的)。而广播模式则是把消息发给了所有订阅了对应主题的消费者，而不管消费者是不是同一个消费者组。广播消息跟生产者没有关系，只跟消费者有关。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">        <span class="comment">/** 广播消费模式 跟其它模式的不同 */</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="params"><span class="function">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Broadcast Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-3-4-延时消息"><a href="#1-3-4-延时消息" class="headerlink" title="1.3.4 延时消息"></a>1.3.4 延时消息</h3><blockquote>
<p>延迟消息实现的效果就是在调用producer.send方法后，消息并不会立即发送出去，而是会等一段时间再发送出去。这是RocketMQ特有的一个功能。</p>
<p>那会延迟多久呢？延迟时间的设置就是在Message消息对象上设置一个延迟级别message.setDelayTimeLevel(3);</p>
<p>开源版本的RocketMQ中，对延迟消息并不支持任意时间的延迟设定(商业版本中支持)，而是只支持18个固定的延迟级别，1到18分别对应messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。这从哪里看出来的？其实从rocketmq-console控制台就能看出来。而这18个延迟级别也支持自行定义，不过一般情况下最好不要自定义修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         <span class="comment">// Instantiate a producer to send scheduled messages</span></span><br><span class="line">         DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">         <span class="comment">// Launch producer</span></span><br><span class="line">         producer.start();</span><br><span class="line">         <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">             Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">             <span class="comment">// This message will be delivered to consumer 10 seconds later.</span></span><br><span class="line">             message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">             <span class="comment">// Send the message</span></span><br><span class="line">             producer.send(message);</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">         <span class="comment">// Shutdown producer after use.</span></span><br><span class="line">         producer.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-3-5批量消息"><a href="#1-3-5批量消息" class="headerlink" title="1.3.5批量消息"></a>1.3.5批量消息</h3><blockquote>
<p>批量消息是指将多条消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。</p>
<p>在官网测试代码中关键的注释：如果批量消息大于1MB就不要用一个批次发送，而要拆分成多个批次消息发送。也就是说，一个批次消息的大小不要超过1MB</p>
<p>实际使用时，这个1MB的限制可以稍微扩大点，实际最大的限制是4194304字节，大概4MB。但是使用批量消息时，这个消息长度确实是必须考虑的一个问题。而且批量消息的使用是有一定限制的，这些消息应该有相同的Topic，相同的waitStoreMsgOK。而且不能是延迟消息、事务消息等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBatchProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;BatchProducerGroupName&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If you just send messages of no more than 1MiB at a time, it is easy to use batch</span></span><br><span class="line">        <span class="comment">//Messages of the same batch should have: same topic, same waitStoreMsgOK and no schedule support</span></span><br><span class="line">        String topic = <span class="string">&quot;BatchTest&quot;</span>;</span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;Tag&quot;</span>, <span class="string">&quot;OrderID001&quot;</span>, <span class="string">&quot;Hello world 0&quot;</span>.getBytes()));</span><br><span class="line">        messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;Tag&quot;</span>, <span class="string">&quot;OrderID002&quot;</span>, <span class="string">&quot;Hello world 1&quot;</span>.getBytes()));</span><br><span class="line">        messages.add(<span class="keyword">new</span> Message(topic, <span class="string">&quot;Tag&quot;</span>, <span class="string">&quot;OrderID003&quot;</span>, <span class="string">&quot;Hello world 2&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        producer.send(messages);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-3-6过滤消息"><a href="#1-3-6过滤消息" class="headerlink" title="1.3.6过滤消息"></a>1.3.6过滤消息</h3><p>在大多数情况下，可以使用Message的Tag属性来简单快速的过滤信息。</p>
<p>使用Tag过滤消息的消息生产者案例见：org.apache.rocketmq.example.filter.TagFilterProducer</p>
<p>使用Tag过滤消息的消息消费者案例见：org.apache.rocketmq.example.filter.TagFilterConsumer</p>
<blockquote>
<p>主要是看消息消费者。consumer.subscribe(“TagFilterTest”, “TagA || TagC”); 这句只订阅TagA和TagC的消息。</p>
<p>TAG是RocketMQ中特有的一个消息属性。RocketMQ的最佳实践中就建议，使用RocketMQ时，一个应用可以就用一个Topic，而应用中的不同业务就用TAG来区分。</p>
</blockquote>
<p>但是，这种方式有一个很大的限制，就是一个消息只能有一个TAG，这在一些比较复杂的场景就有点不足了。 这时候，可以使用SQL表达式来对消息进行过滤。</p>
<p>SQL过滤的消息生产者案例见：org.apache.rocketmq.example.filter.SqlFilterProducer</p>
<p>SQL过滤的消息消费者案例见：org.apache.rocketmq.example.filter.SqlFilterConsumer</p>
<blockquote>
<p>这个模式的关键是在消费者端使用MessageSelector.bySql(String sql)返回的一个MessageSelector。这里面的sql语句是按照SQL92标准来执行的。sql中可以使用的参数有默认的TAGS和一个在生产者中加入的a属性。</p>
<p>SQL92语法：</p>
<p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较，比如：**&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；**</li>
<li>字符比较，比如：**=，&lt;&gt;，IN；**</li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：**’abc’，必须用单引号包裹起来；**</li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>使用注意：只有推模式的消费者可以使用SQL过滤。拉模式是用不了的。</p>
</blockquote>
<h3 id="1-3-7事务消息"><a href="#1-3-7事务消息" class="headerlink" title="1.3.7事务消息"></a>1.3.7事务消息</h3><p>事务消息只跟消息发送者有关</p>
<p>这个事务消息是RocketMQ提供的一个非常有特色的功能，需要着重理解。</p>
<p> <strong>首先</strong>，我们了解下什么是事务消息。官网的介绍是：事务消息是在分布式系统中保证最终一致性的两阶段提交的消息实现。他可以保证本地事务执行与消息发送两个操作的原子性，也就是这两个操作一起成功或者一起失败。</p>
<p> <strong>其次</strong>，我们来理解下事务消息的编程模型。事务消息只保证消息发送者的本地事务与发消息这两个操作的原子性，因此，事务消息的示例只涉及到消息发送者，对于消息消费者来说，并没有什么特别的。</p>
<p>事务消息生产者的案例见：org.apache.rocketmq.example.transaction.TransactionProducer</p>
<blockquote>
<p>事务消息的关键是在TransactionMQProducer中指定了一个TransactionListener事务监听器，这个事务监听器就是事务消息的关键控制器。源码中的案例有点复杂，我这里准备了一个更清晰明了的事务监听器示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"> <span class="comment">//在提交完事务消息后执行。</span></span><br><span class="line"> <span class="comment">//返回COMMIT_MESSAGE状态的消息会立即被消费者消费到。</span></span><br><span class="line"> <span class="comment">//返回ROLLBACK_MESSAGE状态的消息会被丢弃。</span></span><br><span class="line"> <span class="comment">//返回UNKNOWN状态的消息会由Broker过一段时间再来回查事务的状态。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        String tags = msg.getTags();</span><br><span class="line">        <span class="comment">//TagA的消息会立即被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        <span class="comment">//TagB的消息会被丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        <span class="comment">//其他消息会等待Broker进行事务状态回查。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//在对UNKNOWN状态的消息进行状态回查时执行。返回的结果是一样的。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">  String tags = msg.getTags();</span><br><span class="line">        <span class="comment">//TagC的消息过一段时间会被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagC&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        <span class="comment">//TagD的消息也会在状态回查时被丢弃掉</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagD&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        <span class="comment">//剩下TagE的消息会在多次状态回查后最终丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>然后</strong>，我们要了解下事务消息的使用限制：</p>
<p> 1、事务消息不支持延迟消息和批量消息。</p>
<p> 2、为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</p>
<blockquote>
<p>回查次数是由BrokerConfig.transactionCheckMax这个参数来配置的，默认15次，可以在broker.conf中覆盖。<br>然后实际的检查次数会在message中保存一个用户属性MessageConst.PROPERTY_TRANSACTION_CHECK_TIMES。这个属性值大于transactionCheckMax，就会丢弃。 这个用户属性值会按回查次数递增，也可以在Producer中自行覆盖这个属性。</p>
</blockquote>
<p> 3、事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</p>
<blockquote>
<p>由BrokerConfig.transactionTimeOut这个参数来配置。默认6秒，可以在broker.conf中进行修改。<br>另外，也可以给消息配置一个MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS属性来给消息指定一个特定的消息回查时间。<br>msg.putUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS, “10000”); 这样就是10秒。</p>
</blockquote>
<p> 4、事务性消息可能不止一次被检查或消费。</p>
<p> 5、提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</p>
<p> 6、事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</p>
<p> <strong>接下来</strong>，我们还要了解下事务消息的实现机制，参见下图：</p>
<p><img src="/2022/08/18/03-04-02-RocketMQ%E5%AE%9E%E6%88%98/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt="RocketMQ事务消息"></p>
<p>half消息：一种经过特殊处理的普通消息，它对下游不可见，发送half消息，可以检测rocket mq 的状态。half消息会被存放到系统主题RMQ_SYS_TRANS_HALF_TOPIC中<br>执行本地事务：本地事务可能执行成功，可能执行失败，执行成功，rocket mq会发送消息给下游，执行失败，消息回滚，不会发送消息给下游，保证了本地事务和下游事务的一致性（同时执行，同时不执行）<br>状态回查：可能执行本地事务时间较长，rocket mq会过段时间再进行回查<br>整个流程的作用：保证本地事务和消息发送的原子性<br>rocketMQ事务消息只保证了分布式事务的一半，如果下游系统执行失败，本地事务没法进行回滚</p>
<p> 事务消息机制的关键是在发送消息时，会将消息转为一个half半消息，并存入RocketMQ内部的一个 RMQ_SYS_TRANS_HALF_TOPIC 这个Topic，这样对消费者是不可见的。再经过一系列事务检查通过后，再将消息转存到目标Topic，这样对消费者就可见了。</p>
<p> <strong>最后</strong>，我们还需要思考下事务消息的作用。</p>
<p> 大家想一下这个事务消息跟分布式事务有什么关系？为什么扯到了分布式事务相关的两阶段提交上了？事务消息只保证了发送者本地事务和发送消息这两个操作的原子性，但是并不保证消费者本地事务的原子性，所以，事务消息只保证了分布式事务的一半。但是即使这样，<strong>对于复杂的分布式事务，RocketMQ提供的事务消息也是目前业内最佳的降级方案</strong>。</p>
<h3 id="3-8-ACL权限控制"><a href="#3-8-ACL权限控制" class="headerlink" title="3.8 ACL权限控制"></a>3.8 ACL权限控制</h3><p> 权限控制（ACL）主要为RocketMQ提供Topic资源级别的用户访问控制。用户在使用RocketMQ权限控制时，可以在Client客户端通过 RPCHook注入AccessKey和SecretKey签名；同时，将对应的权限控制属性（包括Topic访问权限、IP白名单和AccessKey和SecretKey签名等）设置在$ROCKETMQ_HOME/conf/plain_acl.yml的配置文件中。Broker端对AccessKey所拥有的权限进行校验，校验不过，抛出异常； ACL客户端可以参考：<strong>org.apache.rocketmq.example.simple</strong>包下面的<strong>AclClient</strong>代码。</p>
<blockquote>
<p>注意，如果要在自己的客户端中使用RocketMQ的ACL功能，还需要引入一个单独的依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;rocketmq-acl&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.7.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p> 而Broker端具体的配置信息可以参见源码包下docs/cn/acl/user_guide.md。主要是在broker.conf中打开acl的标志：aclEnable=true。然后就可以用plain_acl.yml来进行权限配置了。并且这个配置文件是热加载的，也就是说要修改配置时，只要修改配置文件就可以了，不用重启Broker服务。我们来简单分析下源码中的plan_acl.yml的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全局白名单，不受ACL控制</span></span><br><span class="line"><span class="comment">#通常需要将主从架构中的所有节点加进来</span></span><br><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.10</span><span class="number">.103</span><span class="string">.*</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line"><span class="comment">#第一个账户</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span> <span class="comment">#默认Topic访问策略是拒绝</span></span><br><span class="line">  <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span> <span class="comment">#默认Group访问策略是只允许订阅</span></span><br><span class="line">  <span class="attr">topicPerms:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicA=DENY</span> <span class="comment">#topicA拒绝</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span> <span class="comment">#topicB允许发布和订阅消息</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicC=SUB</span> <span class="comment">#topicC只允许订阅</span></span><br><span class="line">  <span class="attr">groupPerms:</span></span><br><span class="line">  <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupA=DENY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupB=PUB|SUB</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupC=SUB</span></span><br><span class="line"><span class="comment">#第二个账户，只要是来自192.168.1.*的IP，就可以访问所有资源</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="string">.*</span></span><br><span class="line">  <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>acl配置支持热加载<br>acl生产上通常用的比较少，权限控制有其它方法</p>
</blockquote>
<h3 id="3-9-消息轨迹"><a href="#3-9-消息轨迹" class="headerlink" title="3.9 消息轨迹"></a>3.9 消息轨迹</h3><p>消息轨迹可以做链路跟踪用<br>broker端设置配置：traceTopicEnable=true<br>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    SendResult sendResult = producer.send(msg);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TracePushConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// Here,we use the default message track trace topic name</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;CID_JODIE_1&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// Wrong time format 2017_0422_221800</span></span><br><span class="line">        consumer.setConsumeTimestamp(<span class="string">&quot;20181109221800&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、SpringBoot整合RocketMQ"><a href="#二、SpringBoot整合RocketMQ" class="headerlink" title="二、SpringBoot整合RocketMQ"></a>二、SpringBoot整合RocketMQ</h1><h2 id="1、快速实战"><a href="#1、快速实战" class="headerlink" title="1、快速实战"></a>1、快速实战</h2><p>这部分我们看下SpringBoot如何快速集成RocketMQ。</p>
<blockquote>
<p>在使用SpringBoot的starter集成包时，要特别注意版本。因为SpringBoot集成RocketMQ的starter依赖是由Spring社区提供的，目前正在快速迭代的过程当中，不同版本之间的差距非常大，甚至基础的底层对象都会经常有改动。例如如果使用rocketmq-spring-boot-starter:2.0.4版本开发的代码，升级到目前最新的rocketmq-spring-boot-starter:2.1.1后，基本就用不了了。</p>
</blockquote>
<p>我们创建一个maven工程，引入关键依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>rocketmq-spring-boot-starter:2.1.1引入的SpringBoot包版本是2.0.5.RELEASE，这里把SpringBoot的依赖包升级了一下。</p>
</blockquote>
<p>然后我们以SpringBoot的方式，快速创建一个简单的Demo</p>
<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQScApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RocketMQScApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件 application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#NameServer地址</span></span><br><span class="line"><span class="meta">rocketmq.name-server</span>=<span class="string">192.168.232.128:9876</span></span><br><span class="line"><span class="comment">#默认的消息生产者组</span></span><br><span class="line"><span class="meta">rocketmq.producer.group</span>=<span class="string">springBootGroup</span></span><br></pre></td></tr></table></figure>

<p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.rocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"> <span class="comment">//发送普通消息的示例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String topic,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rocketMQTemplate.convertAndSend(topic,msg);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//发送事务消息的示例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageInTransaction</span><span class="params">(String topic,String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Message&lt;String&gt; message = MessageBuilder.withPayload(msg).build();</span><br><span class="line">            String destination =topic+<span class="string">&quot;:&quot;</span>+tags[i % tags.length];</span><br><span class="line">            SendResult sendResult = rocketMQTemplate.sendMessageInTransaction(destination, message,destination);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.rocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.annotation.RocketMQMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;MyConsumerGroup&quot;, topic = &quot;TestTopic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConsumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message : &quot;</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SpringBoot集成RocketMQ，消费者部分的核心就在这个@RocketMQMessageListener注解上。所有消费者的核心功能也都会集成到这个注解中。所以我们还要注意下这个注解里面的属性：</p>
<p>例如：消息过滤可以由里面的selectorType属性和selectorExpression来定制</p>
<p>消息有序消费还是并发消费则由consumeMode属性定制。</p>
<p>消费者是集群部署还是广播部署由messageModel属性定制。</p>
</blockquote>
<p>然后关于事务消息，还需要配置一个事务消息监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.rocket.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.LocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQLocalTransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQLocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.support.RocketMQUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.converter.StringMessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;rocketMQTemplate&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransactionImpl</span> <span class="keyword">implements</span> <span class="title">RocketMQLocalTransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Object, String&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RocketMQLocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        Object id = msg.getHeaders().get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String destination = arg.toString();</span><br><span class="line">        localTrans.put(id,destination);</span><br><span class="line">        org.apache.rocketmq.common.message.Message message = RocketMQUtil.convertToRocketMessage(<span class="keyword">new</span> StringMessageConverter(),<span class="string">&quot;UTF-8&quot;</span>,destination, msg);</span><br><span class="line">        String tags = message.getTags();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RocketMQLocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//SpringBoot的消息对象中，并没有transactionId这个属性。跟原生API不一样。</span></span><br><span class="line"><span class="comment">//        String destination = localTrans.get(msg.getTransactionId());</span></span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们启动应用后，就能够通过访问 <a href="http://localhost:8080/MQTest/sendMessage?message=123">http://localhost:8080/MQTest/sendMessage?message=123</a> 接口来发送一条简单消息。并在SpringConsumer中消费到。</p>
<p>也可以通过访问<a href="http://localhost:8080/MQTest/sendTransactionMessage?message=123">http://localhost:8080/MQTest/sendTransactionMessage?message=123</a> ，来发送一条事务消息。</p>
<blockquote>
<p>这里可以看到，对事务消息，SpringBoot进行封装时，就缺少了transactionId，这在事务控制中是非常关键的。</p>
</blockquote>
<h2 id="2、其他更多消息类型："><a href="#2、其他更多消息类型：" class="headerlink" title="2、其他更多消息类型："></a>2、其他更多消息类型：</h2><p>对于其他的消息类型，文档中就不一一记录了。具体可以参见源码中的junit测试案例。</p>
<h2 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h2><ul>
<li>SpringBoot 引入org.apache.rocketmq:rocketmq-spring-boot-starter依赖后，就可以通过内置的RocketMQTemplate来与RocketMQ交互。相关属性都以rockemq.开头。具体所有的配置信息可以参见org.apache.rocketmq.spring.autoconfigure.RocketMQProperties这个类。</li>
<li>SpringBoot依赖中的Message对象和RocketMQ-client中的Message对象是两个不同的对象，这在使用的时候要非常容易弄错。例如RocketMQ-client中的Message里的TAG属性，在SpringBoot依赖中的Message中就没有。Tag属性被移到了发送目标中，与Topic一起，以Topic:Tag的方式指定。</li>
<li>最后强调一次，一定要注意版本。rocketmq-spring-boot-starter的更新进度一般都会略慢于RocketMQ的版本更新，并且版本不同会引发很多奇怪的问题。apache有一个官方的rocketmq-spring示例，地址：<a href="https://github.com/apache/rocketmq-spring.git">https://github.com/apache/rocketmq-spring.git</a> 以后如果版本更新了，可以参考下这个示例代码。</li>
</ul>
<h1 id="三、SpringCloudStream整合RocketMQ"><a href="#三、SpringCloudStream整合RocketMQ" class="headerlink" title="三、SpringCloudStream整合RocketMQ"></a>三、SpringCloudStream整合RocketMQ</h1><p> SpringCloudStream是Spring社区提供的一个统一的消息驱动框架，目的是想要以一个统一的编程模型来对接所有的MQ消息中间件产品。我们还是来看看SpringCloudStream如何来集成RocketMQ。</p>
<h2 id="1、快速实战-1"><a href="#1、快速实战-1" class="headerlink" title="1、快速实战"></a>1、快速实战</h2><p> 创建Maven工程，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@EnableBinding(&#123;Source.class, Sink.class&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScRocketMQApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ScRocketMQApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这个@EnableBinding({Source.class, Sink.class})注解，这是SpringCloudStream引入的Binder配置。</p>
</blockquote>
<p>然后增加配置文件application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ScStream通用的配置以spring.cloud.stream开头</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">TestTopic</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">scGroup</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">TestTopic</span></span><br><span class="line"><span class="comment">#rocketMQ的个性化配置以spring.cloud.stream.rocketmq开头</span></span><br><span class="line"><span class="comment">#spring.cloud.stream.rocketmq.binder.name-server=192.168.232.128:9876;192.168.232.129:9876;192.168.232.130:9876</span></span><br><span class="line"><span class="meta">spring.cloud.stream.rocketmq.binder.name-server</span>=<span class="string">192.168.232.128:9876</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SpringCloudStream中，一个binding对应一个消息通道。这其中配置的input，是在Sink.class中定义的，对应一个消息消费者。而output，是在Source.class中定义的，对应一个消息生产者。</p>
</blockquote>
<p>然后就可以增加消息消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.scrocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.StreamListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String messsage)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;received message:&quot;</span>+messsage+<span class="string">&quot; from binding:&quot;</span>+ Sink.INPUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.scrocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageConst;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        headers.put(MessageConst.PROPERTY_TAGS, <span class="string">&quot;testTag&quot;</span>);</span><br><span class="line">        MessageHeaders messageHeaders = <span class="keyword">new</span> MessageHeaders(headers);</span><br><span class="line">        Message&lt;String&gt; message = MessageBuilder.createMessage(msg, messageHeaders);</span><br><span class="line">        <span class="keyword">this</span>.source.output().send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后增加一个Controller类用于测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.scrocket.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.roy.scrocket.basic.ScProducer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/MQTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ScProducer producer;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        producer.sendMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息发送完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动应用后，就可以访问<a href="http://localhost:8080/MQTest/sendMessage?message=123%EF%BC%8C%E7%BB%99RocketMQ%E5%8F%91%E9%80%81%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E5%88%B0TestTopic%EF%BC%8C%E5%B9%B6%E5%9C%A8ScConsumer%E4%B8%AD%E6%B6%88%E8%B4%B9%E5%88%B0%E4%BA%86%E3%80%82">http://localhost:8080/MQTest/sendMessage?message=123，给RocketMQ发送一条消息到TestTopic，并在ScConsumer中消费到了。</a></p>
<h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><ul>
<li>关于SpringCloudStream。这是一套几乎通用的消息中间件编程框架，例如从对接RocketMQ换到对接Kafka，业务代码几乎不需要动，只需要更换pom依赖并且修改配置文件就行了。但是，由于各个MQ产品都有自己的业务模型，差距非常大，所以使用使用SpringCloudStream时要注意业务模型转换。并且在实际使用中，要非常注意各个MQ的个性化配置属性。例如RocketMQ的个性化属性都是以spring.cloud.stream.rocketmq开头，只有通过这些属性才能用上RocketMQ的延迟消息、排序消息、事务消息等个性化功能。</li>
<li>SpringCloudStream是Spring社区提供的一套统一框架，但是官方目前只封装了kafka、kafka Stream、RabbitMQ的具体依赖。而RocketMQ的依赖是交由厂商自己维护的，也就是由阿里巴巴自己来维护。这个维护力度显然是有不小差距的。所以一方面可以看到之前在使用SpringBoot时着重强调的版本问题，在使用SpringCloudStream中被放大了很多。spring-cloud-starter-stream-rocketmq目前最新的2.2.3.RELEASE版本中包含的rocketmq-client版本还是4.4.0。这个差距就非常大了。另一方面，RocketMQ这帮大神不屑于写文档的问题也特别严重，SpringCloudStream中关于RocketMQ的个性化配置几乎很难找到完整的文档。</li>
<li>总之，对于RocketMQ来说，SpringCloudStream目前来说还并不是一个非常好的集成方案。这方面跟kafka和Rabbit还没法比。所以使用时要慎重。</li>
</ul>
<p><a href="https://www.processon.com/view/link/62d96be7f346fb1ede177e68">RocketMQ_思维导图</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka快速实战与基本原理详解</title>
    <url>/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p id="hitokoto">正在加载一言...</p>

<h2 id="Kafka快速实战与基本原理详解"><a href="#Kafka快速实战与基本原理详解" class="headerlink" title="Kafka快速实战与基本原理详解"></a>Kafka快速实战与基本原理详解</h2><h3 id="1、Kafka的使用场景"><a href="#1、Kafka的使用场景" class="headerlink" title="1、Kafka的使用场景"></a>1、<strong>Kafka的使用场景</strong></h3><ul>
<li>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等。</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
</ul>
<h3 id="2、Kafka基本概念"><a href="#2、Kafka基本概念" class="headerlink" title="2、Kafka基本概念"></a>2、<strong>Kafka基本概念</strong></h3><p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了JMS规范的思想，但是确并<strong>没有完全遵循JMS规范。</strong></p>
<p>首先，让我们来看一下基础的消息(Message)相关术语：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Broker</td>
<td>消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群</td>
</tr>
<tr>
<td>Topic</td>
<td>Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic逻辑概念，真正消息发送在partition</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，向Broker发送消息的客户端</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，从Broker读取消息的客户端</td>
</tr>
<tr>
<td>ConsumerGroup</td>
<td>每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个Consumer Group中只能有一个Consumer能够消费该消息</td>
</tr>
<tr>
<td>Partition</td>
<td>物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的</td>
</tr>
</tbody></table>
<p>因此，从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer来进行消费，如下图：</p>
<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220728013835791.png" alt="image-20220728013835791"></p>
<blockquote>
<p>服务端(brokers)和客户端(producer、consumer)之间通信通过<strong>TCP协议</strong>来完成。</p>
</blockquote>
<h3 id="3、kafka环境搭建"><a href="#3、kafka环境搭建" class="headerlink" title="3、kafka环境搭建"></a>3、kafka环境搭建</h3><ul>
<li><p>安装jdk</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install java-<span class="number">1.8</span><span class="number">.0</span>-openjdk* -y</span><br></pre></td></tr></table></figure></li>
<li><p>kafka依赖zookeeper，所以需要先安装zookeeper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//archive.apache.org/dist/zookeeper/zookeeper-3.5.8/apache-zookeeper-3.5.8-bin.tar.gz</span></span><br><span class="line">tar -zxvf apache-zookeeper-<span class="number">3.5</span><span class="number">.8</span>-bin.tar.gz</span><br><span class="line">cd  apache-zookeeper-<span class="number">3.5</span><span class="number">.8</span>-bin</span><br><span class="line">cp conf/zoo_sample.cfg conf/zoo.cfg</span><br><span class="line"></span><br><span class="line"># 启动zookeeper</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line">bin/zkCli.sh </span><br><span class="line">ls /			#查看zk的根目录相关节点</span><br></pre></td></tr></table></figure></li>
<li><p><strong>下载安装包</strong></p>
<p>下载2.4.1 release版本，并解压：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//archive.apache.org/dist/kafka/2.4.1/kafka_2.11-2.4.1.tgz  # 2.11是scala的版本，2.4.1是kafka的版本</span></span><br><span class="line">tar -xzf kafka_2<span class="number">.11</span>-<span class="number">2.4</span><span class="number">.1</span>.tgz</span><br><span class="line">cd kafka_2<span class="number">.11</span>-<span class="number">2.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>修改配置</strong></p>
<p>修改配置文件config/server.properties:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#broker.id属性在kafka集群中必须要是唯一</span><br><span class="line">broker.id=<span class="number">0</span></span><br><span class="line">#kafka部署的机器ip和提供服务的端口号</span><br><span class="line">listeners=PLAINTEXT:<span class="comment">//192.168.65.60:9092   </span></span><br><span class="line">#kafka的消息存储文件</span><br><span class="line">log.dir=/usr/local/data/kafka-logs</span><br><span class="line">#kafka连接zookeeper的地址</span><br><span class="line">zookeeper.connect=<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>启动服务</strong></p>
<p>现在来启动kafka服务：</p>
<p>启动脚本语法：<code>kafka-server-start.sh [-daemon] server.properties</code>&gt;</p>
<p>可以看到，<code>server.properties</code>&gt;的配置路径是一个强制的参数，-daemon表示以后台进程运行，否则ssh客户端退出后，就会停止服务。(注意，在启动kafka时会使用linux主机名关联的ip地址，所以需要把主机名和linux的ip映射配置到本地host里，用vim /etc/hosts)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动kafka，运行日志在logs目录的server.log文件里</span><br><span class="line">bin/kafka-server-start.sh -daemon config/server.properties   #后台启动，不会打印日志到控制台 </span><br><span class="line">或者用 </span><br><span class="line">bin/kafka-server-start.sh config/server.properties &amp; </span><br><span class="line">#我们进入zookeeper目录通过zookeeper客户端查看下zookeeper的目录树   </span><br><span class="line">bin/zkCli.sh  </span><br><span class="line">ls / #查看zk的根目录kafka相关节点 </span><br><span class="line">ls /brokers/ids	#查看kafka节点 </span><br><span class="line"># 停止kafka </span><br><span class="line">bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure>

<p>启动报错日志可以查看server.log</p>
<p><strong>server.properties核心配置详解：</strong></p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Default</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>broker.id</td>
<td>0</td>
<td>每个broker都可以用一个唯一的非负整数id进行标识；这个id可以作为broker的“名字”，你可以选择任意你喜欢的数字作为id，只要id是唯一的即可。</td>
</tr>
<tr>
<td>log.dirs</td>
<td>/tmp/kafka-logs</td>
<td>kafka存放数据的路径。这个路径并不是唯一的，可以是多个，路径之间只需要使用逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进行。</td>
</tr>
<tr>
<td>listeners</td>
<td>PLAINTEXT://192.168.65.60:9092</td>
<td>server接受客户端连接的端口，ip配置kafka本机ip即可</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td>localhost:2181</td>
<td>zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接方式为 hostname1:port1, hostname2:port2, hostname3:port3</td>
</tr>
<tr>
<td>log.retention.hours</td>
<td>168</td>
<td>每个日志文件删除之前保存的时间。默认数据保存时间对所有topic都一样。</td>
</tr>
<tr>
<td>num.partitions</td>
<td>1</td>
<td>创建topic的默认分区数</td>
</tr>
<tr>
<td>default.replication.factor</td>
<td>1</td>
<td>自动创建topic的默认副本数量，建议设置为大于等于2</td>
</tr>
<tr>
<td>min.insync.replicas</td>
<td>1</td>
<td>当producer设置acks为-1时，min.insync.replicas指定replicas的最小数目（必须确认每一个repica的写数据都是成功的），如果这个数目没有达到，producer发送消息会产生异常</td>
</tr>
<tr>
<td>delete.topic.enable</td>
<td>false</td>
<td>是否允许删除主题</td>
</tr>
</tbody></table>
</li>
<li><p><strong>创建主题</strong> </p>
<p>现在我们来创建一个名字为“test”的Topic，这个topic只有一个partition，并且备份因子也设置为1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper <span class="number">192.168</span><span class="number">.31</span><span class="number">.139</span>:<span class="number">2181</span> --replication-factor <span class="number">1</span> --partitions <span class="number">1</span> --topic test</span><br></pre></td></tr></table></figure>

<p>查看kafka中目前存在的topic</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure>

<p>除了我们通过手工的方式创建Topic，当producer发布一个消息到某个指定的Topic，这个Topic如果不存在，就自动创建。</p>
</li>
<li><p><strong>删除主题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --delete --topic test --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>发送消息</strong></p>
<p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。</p>
<p>首先我们要运行发布消息的脚本，然后在命令中输入要发送的消息的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --topic test </span><br><span class="line">&gt;<span class="keyword">this</span> is a msg</span><br><span class="line">&gt;<span class="keyword">this</span> is a another msg </span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费消息</strong></p>
<p><strong>kafka消费消息默认是消费消费者启动之后的消息，也就是说在消费者启动之前的消息不会消费，可以通过配置进行修改（</strong>from-beginning<strong>）</strong></p>
<p>对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输出，<strong>默认是消费最新的消息</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --topic test   </span><br></pre></td></tr></table></figure>

<p>如果想要消费之前的消息可以通过–from-beginning参数指定，如下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --from-beginning --topic test </span><br></pre></td></tr></table></figure>

<p>如果你是通过不同的终端窗口来运行以上的命令，你将会看到在producer终端输入的内容，很快就会在consumer的终端窗口上显示出来。</p>
<p>以上所有的命令都有一些附加的选项；当我们不携带任何参数运行命令的时候，将会显示出这个命令的详细用法。</p>
</li>
<li><p><strong>消费多主题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --whitelist <span class="string">&quot;test|test-2&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>单播消费（rocketmq中的集群消费，同一个消费者组中只有一个消费者可以消费到某个消息）</strong></p>
<p>一条消息只能被某一个消费者消费的模式，类似queue模式，只需让所有消费者在同一个消费组里即可</p>
<p>分别在两个客户端执行如下消费命令，然后往主题里发送消息，结果只有一个客户端能收到消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span>  --consumer-property group.id=testGroup --topic test</span><br></pre></td></tr></table></figure></li>
<li><p><strong>多播消费（rocketmq中的广播消费）</strong></p>
<p>一条消息能被多个消费者消费的模式，类似publish-subscribe模式费，针对Kafka同一条消息只能被同一个消费组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费组即可。我们再增加一个消费者，该消费者属于testGroup-2消费组，结果两个客户端都能收到消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --consumer-property group.id=testGroup-<span class="number">2</span> --topic test </span><br></pre></td></tr></table></figure></li>
<li><p><strong>查看消费组名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --list </span><br></pre></td></tr></table></figure></li>
<li><p><strong>查看消费组的消费偏移量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span> --describe --group testGroup</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220728014609405.png" alt="image-20220728014609405"></p>
<p><strong>current-offset：</strong>当前消费组的已消费偏移量</p>
<p><strong>log-end-offset：</strong>主题对应分区消息的结束偏移量(HW)</p>
<p><strong>lag：</strong>当前消费组未消费的消息数</p>
<p>总结：</p>
<p>对于某个单分区的topic来说，单播消费模式：所有的消费者都属于同一个消费者组；</p>
<p>多播模式：所有的消费者属于不同的几个消费者组，每个消费者组都会消费消息，但是消费者组内部只有一个消费者可以消费消息</p>
</li>
</ul>
<h3 id="4、主题Topic和消息日志Log"><a href="#4、主题Topic和消息日志Log" class="headerlink" title="4、主题Topic和消息日志Log"></a><strong>4、主题Topic和消息日志Log</strong></h3><blockquote>
<p><strong>主题topic是一个逻辑概念，分区时物理概念，实际消息存储在分区上</strong></p>
</blockquote>
<p><strong>可以理解Topic是一个类别的名称，同类消息发送到同一个Topic下面。对于每一个Topic，下面可以有多个分区(Partition)日志文件:</strong></p>
<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729001332197.png" alt="image-20220729001332197"></p>
<p>Partition是一个<strong>有序的message序列</strong>，这些message按顺序添加到一个叫做<strong>commit log的文件</strong>中。每个partition中的消息都有一个唯一的编号，称之为offset，用来唯一标示某个分区中的message。 </p>
<p><strong>每个partition，都对应一个commit log文件</strong>。一个partition中的message的offset都是唯一的，但是不同的partition中的message的offset可能是相同的。</p>
<p>kafka一般不会删除消息，不管这些消息有没有被消费。只会根据配置的日志保留时间(log.retention.hours，默认168h，一周)确认消息多久被删除，默认保留最近一周的日志消息。kafka的性能与保留的消息数据量大小没有关系，因此保存大量的数据消息日志信息不会有什么影响。</p>
<p><strong>每个consumer是基于自己在commit log中的消费进度(offset)来进行工作的</strong>。在kafka中，<strong>消费offset由consumer自己来维护</strong>；一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息，或者跳过某些消息。</p>
<p>这意味kafka中的consumer对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer来说，都是没有影响的，因为每个consumer维护各自的消费offset。</p>
<p><strong>多个分区的原因：消息分片存储，存储到不同的机器上，避免单机存储的瓶颈，一个topic下的分区可以在不同的broker上，分布式存储；多个分区，提高消息消费的并行度</strong></p>
<p><strong>创建多个分区的主题：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span> --replication-factor <span class="number">1</span> --partitions <span class="number">2</span> --topic test1</span><br></pre></td></tr></table></figure>

<p><strong>查看下topic的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span> --topic test1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729001441279.png" alt="image-20220729001441279"></p>
<p>以下是输出内容的解释，第一行是所有分区的概要信息，之后的每一行表示每一个partition的信息。</p>
<ul>
<li>leader节点负责给定partition的所有读写请求。</li>
<li>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。</li>
<li>isr 是replicas的一个子集，它只列出当前还存活着的，并且<strong>已同步备份</strong>了该partition的节点。</li>
</ul>
<p>我们可以运行相同的命令查看之前创建的名称为”test“的topic</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span> --topic test </span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729001502295.png" alt="image-20220729001502295"></p>
<p>之前设置了topic的partition数量为1，备份因子为1，因此显示就如上所示了。</p>
<p>可以进入kafka的数据文件存储目录查看test和test1主题的消息日志文件：</p>
<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729001512351.png" alt="image-20220729001512351"></p>
<p>消息日志文件主要存放在分区文件夹里的以log结尾的日志文件里，如下是test1主题对应的分区0的消息日志：</p>
<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729001521868.png" alt="image-20220729001521868"></p>
<p>当然我们也可以通过如下命令**增加topic的分区数量(目前kafka不支持减少分区)**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh -alter --partitions <span class="number">3</span> --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span> --topic test     <span class="comment">// 3 表示增加到3个</span></span><br></pre></td></tr></table></figure>

<p>分区之后，消费者会进行rebalance，重新分配</p>
<p><strong>可以这么来理解Topic，Partition和Broker</strong></p>
<p>一个topic，代表逻辑上的一个业务数据集，比如按数据库里不同表的数据操作消息区分放入不同topic，订单相关操作消息放入订单topic，用户相关操作消息放入用户topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在topic内部划分多个partition来分片存储数据，不同的partition可以位于不同的机器上，每台机器上都运行一个Kafka的进程Broker。</p>
<p><strong>为什么要对Topic下数据进行分区存储？</strong></p>
<p>1、commit log文件会受到所在机器的文件系统大小的限制，分区之后可以将不同的分区放在不同的机器上，相当于对数据做了<strong>分布式存储</strong>，理论上一个topic可以处理任意数量的数据。</p>
<p>2、为了<strong>提高并行度</strong>。</p>
<h3 id="5、kafka集群实战"><a href="#5、kafka集群实战" class="headerlink" title="5、kafka集群实战"></a>5、<strong>kafka集群实战</strong></h3><blockquote>
<p>对于kafka来说，一个单独的broker意味着kafka集群中只有一个节点。要想增加kafka集群中的节点数量，只需要多启动几个broker实例即可。为了有更好的理解，现在我们在一台机器上同时启动三个broker实例。</p>
</blockquote>
<p>首先，我们需要建立好其他2个broker的配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cp config/server.properties config/server-<span class="number">1.</span>properties</span><br><span class="line">cp config/server.properties config/server-<span class="number">2.</span>properties</span><br></pre></td></tr></table></figure>

<p>配置文件的需要修改的内容分别如下：</p>
<p>config/server-1.properties:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#broker.id属性在kafka集群中必须要是唯一</span><br><span class="line">broker.id=<span class="number">1</span></span><br><span class="line">#kafka部署的机器ip和提供服务的端口号</span><br><span class="line">listeners=PLAINTEXT:<span class="comment">//192.168.65.60:9093   </span></span><br><span class="line">log.dir=/usr/local/data/kafka-logs-<span class="number">1</span></span><br><span class="line">#kafka连接zookeeper的地址，要把多个kafka实例组成集群，对应连接的zookeeper必须相同</span><br><span class="line">zookeeper.connect=<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure>

<p>config/server-2.properties:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">broker.id=<span class="number">2</span></span><br><span class="line">listeners=PLAINTEXT:<span class="comment">//192.168.65.60:9094</span></span><br><span class="line">log.dir=/usr/local/data/kafka-logs-<span class="number">2</span></span><br><span class="line">zookeeper.connect=<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure>

<p>启动kafka实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh -daemon config/server-<span class="number">1.</span>properties</span><br><span class="line">bin/kafka-server-start.sh -daemon config/server-<span class="number">2.</span>properties</span><br></pre></td></tr></table></figure>

<p><strong>查看zookeeper确认集群节点是否都注册成功：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ls /brokers/ids</span><br></pre></td></tr></table></figure>

<p>现在我们创建一个新的topic，副本数设置为3，分区数设置为2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span> --replication-factor <span class="number">3</span> --partitions <span class="number">2</span> --topic my-replicated-topic</span><br><span class="line"><span class="comment">// 表示创建了一个2个分区，每个分区3个副本 副本的作用时做容灾</span></span><br></pre></td></tr></table></figure>

<p><strong>查看下topic的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">2181</span> --topic my-replicated-topic</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729002031601.png" alt="image-20220729002031601"></p>
<blockquote>
<p>以下是输出内容的解释，第一行是所有分区的概要信息（主题名称，分区数量，副本数量，配置信息），之后的每一行表示每一个partition的信息。</p>
<ul>
<li>leader节点负责给定partition的所有读写请求，同一个主题不同分区leader副本一般不一样(指在不同的broker上，为了容灾)</li>
<li>replicas 表示某个partition在哪几个broker上存在备份。不管这个节点是不是”leader“，甚至这个节点挂了，也会列出。</li>
<li>isr 是replicas的一个子集，它只列出当前还存活着的，并且<strong>已同步备份</strong>了该partition的节点。</li>
</ul>
</blockquote>
<p>现在我们向新建的 my-replicated-topic 中发送一些message，kafka集群可以加上所有kafka节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span>,<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9093</span>,<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9094</span> --topic my-replicated-topic</span><br><span class="line">&gt;my test msg <span class="number">1</span></span><br><span class="line">&gt;my test msg <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>现在开始消费：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span>,<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9093</span>,<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9094</span> --from-beginning --topic my-replicated-topic</span><br><span class="line">my test msg <span class="number">1</span></span><br><span class="line">my test msg <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p><strong>kafka将很多集群关键信息记录在zookeeper里，保证自己的无状态，从而在水平扩容时非常方便。</strong></p>
<h3 id="6、kafka消费模式"><a href="#6、kafka消费模式" class="headerlink" title="6、kafka消费模式"></a>6、kafka消费模式</h3><p><strong>集群消费</strong></p>
<hr>
<p>log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。kafka集群支持配置一个partition备份的数量。</p>
<p>针对每个partition，都有一个broker起到“leader”的作用，0个或多个其他的broker作为“follwers”的作用。**leader处理所有的针对这个partition的读写请求，而followers被动复制leader的结果，不提供读写(主要是为了保证多副本数据与消费的一致性)**。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。</p>
<p><strong>Producers</strong></p>
<p>生产者将消息发送到topic中去，同时负责选择将message发送到topic的哪一个partition中。通过round-robin做简单的负载均衡。也可以根据消息中的某一个关键字来进行区分。通常第二种方式使用的更多。</p>
<p><strong>Consumers</strong></p>
<p>传统的消息传递模式有2种：队列( queue) 和（publish-subscribe）</p>
<ul>
<li>queue模式：多个consumer从服务器中读取数据，消息只会到达一个consumer。</li>
<li>publish-subscribe模式：消息会被广播给所有的consumer。</li>
</ul>
<p>Kafka基于这2种模式提供了一种consumer的抽象概念：consumer group。</p>
<ul>
<li><p>queue模式：所有的consumer都位于同一个consumer group 下。</p>
</li>
<li><p>publish-subscribe模式：所有的consumer都有着自己唯一的consumer group。</p>
<p><img src="/2022/07/28/03-05-01-Kafka%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20220729002258501.png" alt="image-20220729002258501"></p>
</li>
</ul>
<p>上图说明：由2个broker组成的kafka集群，某个主题总共有4个partition(P0-P3)，分别位于不同的broker上。这个集群由2个Consumer Group消费， A有2个consumer instances ，B有4个。</p>
<p>通常一个topic会有几个consumer group，每个consumer group都是一个逻辑上的订阅者（ logical subscriber ）。每个consumer group由多个consumer instance组成，从而达到可扩展和容灾的功能。</p>
<p><strong>消费顺序</strong></p>
<p>一个partition同一个时刻在一个consumer group中只能有一个consumer instance在消费，从而保证消费顺序。</p>
<p><strong>consumer group中的consumer instance的数量不能比一个Topic中的partition的数量多，否则，多出来的consumer消费不到消息。</strong></p>
<p>Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。</p>
<p>如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer instance数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。</p>
<h3 id="7、Java客户端访问Kafka"><a href="#7、Java客户端访问Kafka" class="headerlink" title="7、Java客户端访问Kafka"></a>7、<strong>Java客户端访问Kafka</strong></h3><p><strong>maven依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>消息发送端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.kafka.kafkaDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">&quot;my-replicated-topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.31.139:9092,192.168.31.139:9093,192.168.31.139:9094&quot;);</span></span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.31.139:9092,192.168.31.139:9093,192.168.31.139:9094&quot;</span>);</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         发出消息持久化机制参数</span></span><br><span class="line"><span class="comment">        （1）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。</span></span><br><span class="line"><span class="comment">        （2）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一</span></span><br><span class="line"><span class="comment">             条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</span></span><br><span class="line"><span class="comment">        （3）acks=-1或all： 需要等待 min.insync.replicas(默认为1，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略</span></span><br><span class="line"><span class="comment">            会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        发送失败会重试，默认重试间隔100ms，重试能保证消息发送的可靠性，但是也可能造成消息重复发送，比如网络抖动，所以需要在</span></span><br><span class="line"><span class="comment">        接收者那边做好消息接收的幂等性处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//重试间隔设置</span></span><br><span class="line">        props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">300</span>);</span><br><span class="line">        <span class="comment">//设置发送消息的本地缓冲区，如果设置了该缓冲区，消息会先发送到本地缓冲区，可以提高消息发送性能，默认值是33554432，即32MB</span></span><br><span class="line">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        kafka本地线程会从缓冲区取数据，批量发送到broker，</span></span><br><span class="line"><span class="comment">        设置批量发送消息的大小，默认值是16384，即16kb，就是说一个batch满了16kb就发送出去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        默认值是0，意思就是消息必须立即被发送，但这样会影响性能</span></span><br><span class="line"><span class="comment">        一般设置10毫秒左右，就是说这个消息发送完后会进入本地的一个batch，如果10毫秒内，这个batch满了16kb就会随batch一起被发送出去</span></span><br><span class="line"><span class="comment">        如果10毫秒内，batch没满，那么也必须把消息发送出去，不能让消息的发送延迟时间太长</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//把发送的key从字符串序列化为字节数组</span></span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">//把发送消息value从字符串序列化为字节数组</span></span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> msgNum = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(msgNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= msgNum; i++) &#123;</span><br><span class="line">            Order order = <span class="keyword">new</span> Order(i, <span class="number">100</span> + i, <span class="number">1</span>, <span class="number">1000.00</span>);</span><br><span class="line">            <span class="comment">//指定发送分区</span></span><br><span class="line">            <span class="comment">/*ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;String, String&gt;(TOPIC_NAME</span></span><br><span class="line"><span class="comment">                    , 0, order.getOrderId().toString(), JSON.toJSONString(order));*/</span></span><br><span class="line">            <span class="comment">//未指定发送分区，具体发送的分区计算公式：hash(key)%partitionNum</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME</span><br><span class="line">                    , order.getOrderId().toString(), JSON.toJSONString(order));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待消息发送成功的同步阻塞方法</span></span><br><span class="line">            RecordMetadata metadata = producer.send(producerRecord).get();</span><br><span class="line">            System.out.println(<span class="string">&quot;同步方式发送消息结果：&quot;</span> + <span class="string">&quot;topic-&quot;</span> + metadata.topic() + <span class="string">&quot;|partition-&quot;</span></span><br><span class="line">                    + metadata.partition() + <span class="string">&quot;|offset-&quot;</span> + metadata.offset());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//异步回调方式发送消息</span></span><br><span class="line">            <span class="comment">/*producer.send(producerRecord, new Callback() &#123;</span></span><br><span class="line"><span class="comment">                public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span></span><br><span class="line"><span class="comment">                    if (exception != null) &#123;</span></span><br><span class="line"><span class="comment">                        System.err.println(&quot;发送消息失败：&quot; + exception.getStackTrace());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (metadata != null) &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(&quot;异步方式发送消息结果：&quot; + &quot;topic-&quot; + metadata.topic() + &quot;|partition-&quot;</span></span><br><span class="line"><span class="comment">                                + metadata.partition() + &quot;|offset-&quot; + metadata.offset());</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    countDownLatch.countDown();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//送积分 TODO</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>消息发送的关键参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、ProducerConfig.BOOTSTRAP_SERVERS_CONFIG(bootstrap.servers)  kafka的服务端地址</span><br><span class="line">2、ProducerConfig.ACKS_CONFIG(acks) 发出消息持久化机制参数</span><br><span class="line">（1）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。</span><br><span class="line">（2）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一</span><br><span class="line">条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</span><br><span class="line">（3）acks=-1或all： 需要等待 min.insync.replicas(默认为1，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略</span><br><span class="line">会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。</span><br><span class="line">3、ProducerConfig.RETRIES_CONFIG(retries)重试参数，客户端发送消息没成功，kafka会默认帮忙重试。比如客户端发送消息到kafka服务端，kafka响应客户端ack的时候出现了网络分区，那么客户端没收到ack响应，会重新发送消息</span><br><span class="line">4、ProducerConfig.BUFFER_MEMORY_CONFIG（buffer.memory）本地缓冲区，生产者发送消息会先发送到缓冲区中，然后会有一个线程消费缓冲区数据</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>消息消费端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.kafka.kafkaDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">&quot;my-replicated-topic&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONSUMER_GROUP_NAME = <span class="string">&quot;testGroup&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.65.60:9092,192.168.65.60:9093,192.168.65.60:9094&quot;</span>);</span><br><span class="line">        <span class="comment">// 消费分组名</span></span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);</span><br><span class="line">        <span class="comment">// 是否自动提交offset，默认就是true</span></span><br><span class="line">        <span class="comment">/*props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, &quot;true&quot;);</span></span><br><span class="line"><span class="comment">        // 自动提交offset的间隔时间</span></span><br><span class="line"><span class="comment">        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, &quot;1000&quot;);*/</span></span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        当消费主题的是一个新的消费组，或者指定offset的消费方式，offset不存在，那么应该如何消费</span></span><br><span class="line"><span class="comment">        latest(默认) ：只消费自己启动之后发送到主题的消息</span></span><br><span class="line"><span class="comment">        earliest：第一次从头开始消费，以后按照消费offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		consumer给broker发送心跳的间隔时间，broker接收到心跳如果此时有rebalance发生会通过心跳响应将</span></span><br><span class="line"><span class="comment">		rebalance方案下发给consumer，这个时间可以稍微短一点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        服务端broker多久感知不到一个consumer心跳就认为他故障了，会将其踢出消费组，</span></span><br><span class="line"><span class="comment">        对应的Partition也会被重新分配给其他consumer，默认是10秒</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一次poll最大拉取消息的条数，如果消费者处理速度很快，可以设置大点，如果处理速度一般，可以设置小点</span></span><br><span class="line">        props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果两次poll操作间隔超过了这个时间，broker就会认为这个consumer处理能力太弱，</span></span><br><span class="line"><span class="comment">        会将其踢出消费组，将分区分配给别的consumer消费</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(Arrays.asList(TOPIC_NAME));</span><br><span class="line">        <span class="comment">// 消费指定分区</span></span><br><span class="line">        <span class="comment">//consumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0)));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息回溯消费  消息从头消费</span></span><br><span class="line">        <span class="comment">/*consumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0)));</span></span><br><span class="line"><span class="comment">        consumer.seekToBeginning(Arrays.asList(new TopicPartition(TOPIC_NAME, 0)));*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定offset消费</span></span><br><span class="line">        <span class="comment">/*consumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0)));</span></span><br><span class="line"><span class="comment">        consumer.seek(new TopicPartition(TOPIC_NAME, 0), 10);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从指定时间点开始消费</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*List&lt;PartitionInfo&gt; topicPartitions = consumer.partitionsFor(TOPIC_NAME);</span></span><br><span class="line"><span class="comment">        //从1小时前开始消费</span></span><br><span class="line"><span class="comment">        long fetchDataTime = new Date().getTime() - 1000 * 60 * 60;</span></span><br><span class="line"><span class="comment">        Map&lt;TopicPartition, Long&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (PartitionInfo par : topicPartitions) &#123;</span></span><br><span class="line"><span class="comment">            map.put(new TopicPartition(TOPIC_NAME, par.partition()), fetchDataTime);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap = consumer.offsetsForTimes(map);</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : parMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">            TopicPartition key = entry.getKey();</span></span><br><span class="line"><span class="comment">            OffsetAndTimestamp value = entry.getValue();</span></span><br><span class="line"><span class="comment">            if (key == null || value == null) continue;</span></span><br><span class="line"><span class="comment">            Long offset = value.offset();</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;partition-&quot; + key.partition() + &quot;|offset-&quot; + offset);</span></span><br><span class="line"><span class="comment">            System.out.println();</span></span><br><span class="line"><span class="comment">            //根据消费里的timestamp确定offset</span></span><br><span class="line"><span class="comment">            if (value != null) &#123;</span></span><br><span class="line"><span class="comment">                consumer.assign(Arrays.asList(key));</span></span><br><span class="line"><span class="comment">                consumer.seek(key, offset);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * poll() API 是拉取消息的长轮询</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;收到消息：partition = %d,offset = %d, key = %s, value = %s%n&quot;</span>, record.partition(),</span><br><span class="line">                        record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (records.count() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 手动同步提交offset，当前线程会阻塞直到offset提交成功</span></span><br><span class="line">                <span class="comment">// 一般使用同步提交，因为提交之后一般也没有什么逻辑代码了</span></span><br><span class="line">                <span class="comment">//consumer.commitSync();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动异步提交offset，当前线程提交offset不会阻塞，可以继续处理后面的程序逻辑</span></span><br><span class="line">                <span class="comment">/*consumer.commitAsync(new OffsetCommitCallback() &#123;</span></span><br><span class="line"><span class="comment">                    @Override</span></span><br><span class="line"><span class="comment">                    public void onComplete(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception) &#123;</span></span><br><span class="line"><span class="comment">                        if (exception != null) &#123;</span></span><br><span class="line"><span class="comment">                            System.err.println(&quot;Commit failed for &quot; + offsets);</span></span><br><span class="line"><span class="comment">                            System.err.println(&quot;Commit failed exception: &quot; + exception.getStackTrace());</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;);*/</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8、Spring-Boot整合Kafka"><a href="#8、Spring-Boot整合Kafka" class="headerlink" title="8、Spring Boot整合Kafka"></a>8、<strong>Spring Boot整合Kafka</strong></h3><p><strong>maven坐标</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>application.yml配置如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  kafka:</span><br><span class="line">    bootstrap-servers: <span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9092</span>,<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9093</span>,<span class="number">192.168</span><span class="number">.65</span><span class="number">.60</span>:<span class="number">9094</span></span><br><span class="line">    producer: # 生产者</span><br><span class="line">      retries: <span class="number">3</span> # 设置大于<span class="number">0</span>的值，则客户端会将发送失败的记录重新发送</span><br><span class="line">      batch-size: <span class="number">16384</span></span><br><span class="line">      buffer-memory: <span class="number">33554432</span></span><br><span class="line">      acks: <span class="number">1</span></span><br><span class="line">      # 指定消息key和消息体的编解码方式</span><br><span class="line">      key-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">      value-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">    consumer:</span><br><span class="line">      group-id: <span class="keyword">default</span>-group</span><br><span class="line">      enable-auto-commit: <span class="keyword">false</span></span><br><span class="line">      auto-offset-reset: earliest</span><br><span class="line">      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">    listener:</span><br><span class="line">      # 当每一条记录被消费者监听器（ListenerConsumer）处理之后提交</span><br><span class="line">      # RECORD</span><br><span class="line">      # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交</span><br><span class="line">      # BATCH</span><br><span class="line">      # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交</span><br><span class="line">      # TIME</span><br><span class="line">      # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交</span><br><span class="line">      # COUNT</span><br><span class="line">      # TIME |　COUNT　有一个条件满足时提交</span><br><span class="line">      # COUNT_TIME</span><br><span class="line">      # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后, 手动调用Acknowledgment.acknowledge()后提交</span><br><span class="line">      # MANUAL</span><br><span class="line">      # 手动调用Acknowledgment.acknowledge()后立即提交，一般使用这种</span><br><span class="line">      # MANUAL_IMMEDIATE</span><br><span class="line">      ack-mode: manual_immediate</span><br></pre></td></tr></table></figure>

<p><strong>发送者代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">&quot;my-replicated-topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(TOPIC_NAME, <span class="number">0</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;this is a msg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.support.Acknowledgment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@KafkaListener</span>(groupId = &quot;testGroup&quot;, topicPartitions = &#123;</span></span><br><span class="line"><span class="comment">     *             <span class="doctag">@TopicPartition</span>(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;, &quot;1&quot;&#125;),</span></span><br><span class="line"><span class="comment">     *             <span class="doctag">@TopicPartition</span>(topic = &quot;topic2&quot;, partitions = &quot;0&quot;,</span></span><br><span class="line"><span class="comment">     *                     partitionOffsets = <span class="doctag">@PartitionOffset</span>(partition = &quot;1&quot;, initialOffset = &quot;100&quot;))</span></span><br><span class="line"><span class="comment">     *     &#125;,concurrency = &quot;6&quot;)</span></span><br><span class="line"><span class="comment">     *  //concurrency就是同组下的消费者个数，就是并发消费数，必须小于等于分区总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;my-replicated-topic&quot;,groupId = &quot;zhugeGroup&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenZhugeGroup</span><span class="params">(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">        String value = record.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(record);</span><br><span class="line">        <span class="comment">//手动提交offset</span></span><br><span class="line">        ack.acknowledge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*//配置多个消费组</span></span><br><span class="line"><span class="comment">    @KafkaListener(topics = &quot;my-replicated-topic&quot;,groupId = &quot;tulingGroup&quot;)</span></span><br><span class="line"><span class="comment">    public void listenTulingGroup(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack) &#123;</span></span><br><span class="line"><span class="comment">        String value = record.value();</span></span><br><span class="line"><span class="comment">        System.out.println(value);</span></span><br><span class="line"><span class="comment">        System.out.println(record);</span></span><br><span class="line"><span class="comment">        ack.acknowledge();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
        <category>分布式</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
</search>
